{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"api/overview/","text":"Overview \u00b6 anomaly \u00b6 Anomaly detection. The estimators in the anomaly module have a slightly different API. Instead of a predict_one method, each anomaly detector has a score_one . The latter returns an anomaly score for a given set of features. High scores indicate anomalies, whereas low scores indicate normal observations. Note that the range of the scores is relative to each estimator. HalfSpaceTrees base \u00b6 Base interfaces. Every estimator in river is a class, and as such inherits from at least one base interface. These are used to categorize, organize, and standardize the many estimators that river contains. This module contains mixin classes, which are all suffixed by Mixin . Their purpose is to provide additional functionality to an estimator, and thus need to be used in conjunction with a non-mixin base class. This module also contains utilities for type hinting and tagging estimators. AnomalyDetector Base Classifier Clusterer DriftDetector EnsembleMixin Estimator MiniBatchClassifier MiniBatchRegressor MultiOutputMixin Regressor SupervisedTransformer Transformer WrapperMixin cluster \u00b6 Unsupervised clustering. CluStream DenStream KMeans compat \u00b6 Compatibility tools. This module contains adapters for making river estimators compatible with other libraries, and vice-versa whenever possible. The relevant adapters will only be usable if you have installed the necessary library. For instance, you have to install scikit-learn in order to use the compat.convert_sklearn_to_river function. Classes River2SKLClassifier River2SKLClusterer River2SKLRegressor River2SKLTransformer SKL2RiverClassifier SKL2RiverRegressor Functions convert_river_to_sklearn convert_sklearn_to_river compose \u00b6 Model composition. This module contains utilities for merging multiple modeling steps into a single pipeline. Although pipelines are not the only way to process a stream of data, we highly encourage you to use them. Discard FuncTransformer Grouper Pipeline Renamer Select SelectType TransformerUnion datasets \u00b6 Datasets. This module contains a collection of datasets for multiple tasks: classification, regression, etc. The data corresponds to popular datasets and are conveniently wrapped to easily iterate over the data in a stream fashion. All datasets have fixed size. Please refer to river.synth if you are interested in infinite synthetic data generators. AirlinePassengers Bananas Bikes ChickWeights CreditCard Elec2 HTTP Higgs ImageSegments Insects MaliciousURL MovieLens100K Music Phishing Restaurants SMSSpam SMTP SolarFlare TREC07 Taxis TrumpApproval drift \u00b6 Concept Drift Detection. This module contains concept drift detection methods. The purpose of a drift detector is to raise an alarm if the data distribution changes. A good drift detector method is the one that maximizes the true positives while keeping the number of false positives to a minimum. ADWIN DDM EDDM HDDM_A HDDM_W KSWIN PageHinkley dummy \u00b6 Dummy estimators. This module is here for testing purposes, as well as providing baseline performances. NoChangeClassifier PriorClassifier StatisticRegressor ensemble \u00b6 Ensemble learning. This module includes ensemble methods. This kind of methods improve predictive performance by combining the prediction of their members. ADWINBaggingClassifier AdaBoostClassifier AdaptiveRandomForestClassifier AdaptiveRandomForestRegressor BaggingClassifier BaggingRegressor LeveragingBaggingClassifier SRPClassifier evaluate \u00b6 Model evaluation. This module provides utilities to evaluate an online model. The goal is to reproduce a real-world scenario with high fidelity. The core function of this module is progressive_val_score , which allows to evaluate a model via progressive validation. This module also exposes \"tracks\". A track is a predefined combination of a dataset and one or more metrics. This allows a principled manner to compare models with each other. For instance, the load_binary_clf_tracks returns tracks that are to be used to evaluate the performance of a binary classification model. The benchmarks directory at the root of the River repository uses these tracks. load_binary_clf_tracks progressive_val_score expert \u00b6 Expert learning. This module regroups a variety of methods that may be used for performing model selection. An expert learner is provided with a list of models, which are also called experts, and is tasked with performing at least as well as the best expert. Indeed, initially the best model is not known. The performance of each model becomes more apparent as time goes by. Different strategies are possible, each one offering a different tradeoff in terms of accuracy and computational performance. Expert learning can be used for tuning the hyperparameters of a model. This may be done by creating a copy of the model for each set of hyperparameters, and treating each copy as a separate model. The utils.expand_param_grid function can be used for this purpose. Note that this differs from the ensemble module in that methods from the latter are designed to improve the performance of a single model. Both modules may thus be used in conjunction with one another. EWARegressor EpsilonGreedyRegressor StackingClassifier SuccessiveHalvingClassifier SuccessiveHalvingRegressor UCBRegressor facto \u00b6 Factorization machines. FFMClassifier FFMRegressor FMClassifier FMRegressor FwFMClassifier FwFMRegressor HOFMClassifier HOFMRegressor feature_extraction \u00b6 Feature extraction. This module can be used to extract information from raw features. This includes encoding categorical data as well as looking at interactions between existing features. This differs from the processing module in that the latter's purpose is rather to clean the data so that it may be processed by a particular machine learning algorithm. Agg BagOfWords PolynomialExtender RBFSampler TFIDF TargetAgg feature_selection \u00b6 Feature selection. PoissonInclusion SelectKBest VarianceThreshold imblearn \u00b6 Sampling methods. HardSamplingClassifier HardSamplingRegressor RandomOverSampler RandomSampler RandomUnderSampler linear_model \u00b6 Linear models. ALMAClassifier LinearRegression LogisticRegression PAClassifier PARegressor Perceptron SoftmaxRegression meta \u00b6 Meta-models. BoxCoxRegressor PredClipper TransformedTargetRegressor metrics \u00b6 Evaluation metrics. All the metrics are updated one sample at a time. This way we can track performance of predictive methods over time. Accuracy BalancedAccuracy BinaryMetric ClassificationMetric ClassificationReport CohenKappa ConfusionMatrix CrossEntropy ExactMatch ExampleF1 ExampleFBeta ExamplePrecision ExampleRecall F1 FBeta GeometricMean Hamming HammingLoss Jaccard KappaM KappaT LogLoss MAE MCC MSE MacroF1 MacroFBeta MacroPrecision MacroRecall Metric Metrics MicroF1 MicroFBeta MicroPrecision MicroRecall MultiClassMetric MultiFBeta MultiLabelConfusionMatrix MultiOutputClassificationMetric MultiOutputRegressionMetric Precision R2 RMSE RMSLE ROCAUC Recall RegressionMetric RegressionMultiOutput Rolling SMAPE TimeRolling WeightedF1 WeightedFBeta WeightedPrecision WeightedRecall WrapperMetric multiclass \u00b6 Multi-class classification. OneVsOneClassifier OneVsRestClassifier OutputCodeClassifier multioutput \u00b6 Multi-output models. ClassifierChain MonteCarloClassifierChain ProbabilisticClassifierChain RegressorChain naive_bayes \u00b6 Naive Bayes algorithms. BernoulliNB ComplementNB GaussianNB MultinomialNB neighbors \u00b6 Neighbors-based learning. Also known as lazy methods. In these methods, generalisation of the training data is delayed until a query is received. KNNADWINClassifier KNNClassifier KNNRegressor SAMKNNClassifier neural_net \u00b6 Neural networks. MLPRegressor activations \u00b6 Identity ReLU Sigmoid optim \u00b6 Stochastic optimization. AMSGrad AdaBound AdaDelta AdaGrad AdaMax Adam Averager FTRLProximal Momentum Nadam NesterovMomentum Optimizer RMSProp SGD initializers \u00b6 Weight initializers. Constant Normal Zeros losses \u00b6 Loss functions. Each loss function is intended to work with both single values as well as numpy vectors. Absolute BinaryFocalLoss BinaryLoss Cauchy CrossEntropy EpsilonInsensitiveHinge Hinge Log MultiClassLoss Poisson Quantile RegressionLoss Squared schedulers \u00b6 Learning rate schedulers. Constant InverseScaling Optimal Scheduler preprocessing \u00b6 Feature preprocessing. The purpose of this module is to modify an existing set of features so that they can be processed by a machine learning algorithm. This may be done by scaling numeric parts of the data or by one-hot encoding categorical features. The difference with the feature_extraction module is that the latter extracts new information from the data AdaptiveStandardScaler Binarizer FeatureHasher LDA MaxAbsScaler MinMaxScaler Normalizer OneHotEncoder PreviousImputer RobustScaler StandardScaler StatImputer proba \u00b6 Probability distributions. Gaussian Multinomial reco \u00b6 Recommender systems. Baseline BiasedMF FunkMF RandomNormal stats \u00b6 Running statistics AbsMax AutoCorr BayesianMean Bivariate Count Cov EWMean EWVar Entropy IQR Kurtosis Link Max Mean Min Mode NUnique PeakToPeak PearsonCorr Quantile RollingAbsMax RollingCov RollingIQR RollingMax RollingMean RollingMin RollingMode RollingPeakToPeak RollingPearsonCorr RollingQuantile RollingSEM RollingSum RollingVar SEM Shift Skew Sum Univariate Var stream \u00b6 Streaming utilities. The module includes tools to iterate over data streams. Classes Cache Functions iter_arff iter_array iter_csv iter_libsvm iter_pandas iter_sklearn_dataset iter_sql shuffle simulate_qa synth \u00b6 Synthetic datasets. Each synthetic dataset is a stream generator. The benefit of using a generator is that they do not store the data and each data sample is generated on the fly. Except for a couple of methods, the majority of these methods are infinite data generators. Agrawal AnomalySine ConceptDriftStream Friedman FriedmanDrift Hyperplane LED LEDDrift Logical Mixed Mv Planes2D RandomRBF RandomRBFDrift RandomTree SEA STAGGER Sine Waveform time_series \u00b6 Time series forecasting. Detrender GroupDetrender SNARIMAX tree \u00b6 ExtremelyFastDecisionTreeClassifier HoeffdingAdaptiveTreeClassifier HoeffdingAdaptiveTreeRegressor HoeffdingTreeClassifier HoeffdingTreeRegressor LabelCombinationHoeffdingTreeClassifier iSOUPTreeRegressor utils \u00b6 Utility classes and functions. Classes Histogram SDFT Skyline SortedWindow VectorDict Window Functions check_estimator dict2numpy expand_param_grid numpy2dict math \u00b6 Mathematical utility functions (intended for internal purposes). A lot of this is experimental and has a high probability of changing in the future. argmax chain_dot clamp dot dotvecmat matmul2d minkowski_distance norm outer prod sherman_morrison sigmoid sign softmax pretty \u00b6 Helper functions for making things readable by humans. humanize_bytes print_table","title":"Overview"},{"location":"api/overview/#overview","text":"","title":"Overview"},{"location":"api/overview/#anomaly","text":"Anomaly detection. The estimators in the anomaly module have a slightly different API. Instead of a predict_one method, each anomaly detector has a score_one . The latter returns an anomaly score for a given set of features. High scores indicate anomalies, whereas low scores indicate normal observations. Note that the range of the scores is relative to each estimator. HalfSpaceTrees","title":"anomaly"},{"location":"api/overview/#base","text":"Base interfaces. Every estimator in river is a class, and as such inherits from at least one base interface. These are used to categorize, organize, and standardize the many estimators that river contains. This module contains mixin classes, which are all suffixed by Mixin . Their purpose is to provide additional functionality to an estimator, and thus need to be used in conjunction with a non-mixin base class. This module also contains utilities for type hinting and tagging estimators. AnomalyDetector Base Classifier Clusterer DriftDetector EnsembleMixin Estimator MiniBatchClassifier MiniBatchRegressor MultiOutputMixin Regressor SupervisedTransformer Transformer WrapperMixin","title":"base"},{"location":"api/overview/#cluster","text":"Unsupervised clustering. CluStream DenStream KMeans","title":"cluster"},{"location":"api/overview/#compat","text":"Compatibility tools. This module contains adapters for making river estimators compatible with other libraries, and vice-versa whenever possible. The relevant adapters will only be usable if you have installed the necessary library. For instance, you have to install scikit-learn in order to use the compat.convert_sklearn_to_river function. Classes River2SKLClassifier River2SKLClusterer River2SKLRegressor River2SKLTransformer SKL2RiverClassifier SKL2RiverRegressor Functions convert_river_to_sklearn convert_sklearn_to_river","title":"compat"},{"location":"api/overview/#compose","text":"Model composition. This module contains utilities for merging multiple modeling steps into a single pipeline. Although pipelines are not the only way to process a stream of data, we highly encourage you to use them. Discard FuncTransformer Grouper Pipeline Renamer Select SelectType TransformerUnion","title":"compose"},{"location":"api/overview/#datasets","text":"Datasets. This module contains a collection of datasets for multiple tasks: classification, regression, etc. The data corresponds to popular datasets and are conveniently wrapped to easily iterate over the data in a stream fashion. All datasets have fixed size. Please refer to river.synth if you are interested in infinite synthetic data generators. AirlinePassengers Bananas Bikes ChickWeights CreditCard Elec2 HTTP Higgs ImageSegments Insects MaliciousURL MovieLens100K Music Phishing Restaurants SMSSpam SMTP SolarFlare TREC07 Taxis TrumpApproval","title":"datasets"},{"location":"api/overview/#drift","text":"Concept Drift Detection. This module contains concept drift detection methods. The purpose of a drift detector is to raise an alarm if the data distribution changes. A good drift detector method is the one that maximizes the true positives while keeping the number of false positives to a minimum. ADWIN DDM EDDM HDDM_A HDDM_W KSWIN PageHinkley","title":"drift"},{"location":"api/overview/#dummy","text":"Dummy estimators. This module is here for testing purposes, as well as providing baseline performances. NoChangeClassifier PriorClassifier StatisticRegressor","title":"dummy"},{"location":"api/overview/#ensemble","text":"Ensemble learning. This module includes ensemble methods. This kind of methods improve predictive performance by combining the prediction of their members. ADWINBaggingClassifier AdaBoostClassifier AdaptiveRandomForestClassifier AdaptiveRandomForestRegressor BaggingClassifier BaggingRegressor LeveragingBaggingClassifier SRPClassifier","title":"ensemble"},{"location":"api/overview/#evaluate","text":"Model evaluation. This module provides utilities to evaluate an online model. The goal is to reproduce a real-world scenario with high fidelity. The core function of this module is progressive_val_score , which allows to evaluate a model via progressive validation. This module also exposes \"tracks\". A track is a predefined combination of a dataset and one or more metrics. This allows a principled manner to compare models with each other. For instance, the load_binary_clf_tracks returns tracks that are to be used to evaluate the performance of a binary classification model. The benchmarks directory at the root of the River repository uses these tracks. load_binary_clf_tracks progressive_val_score","title":"evaluate"},{"location":"api/overview/#expert","text":"Expert learning. This module regroups a variety of methods that may be used for performing model selection. An expert learner is provided with a list of models, which are also called experts, and is tasked with performing at least as well as the best expert. Indeed, initially the best model is not known. The performance of each model becomes more apparent as time goes by. Different strategies are possible, each one offering a different tradeoff in terms of accuracy and computational performance. Expert learning can be used for tuning the hyperparameters of a model. This may be done by creating a copy of the model for each set of hyperparameters, and treating each copy as a separate model. The utils.expand_param_grid function can be used for this purpose. Note that this differs from the ensemble module in that methods from the latter are designed to improve the performance of a single model. Both modules may thus be used in conjunction with one another. EWARegressor EpsilonGreedyRegressor StackingClassifier SuccessiveHalvingClassifier SuccessiveHalvingRegressor UCBRegressor","title":"expert"},{"location":"api/overview/#facto","text":"Factorization machines. FFMClassifier FFMRegressor FMClassifier FMRegressor FwFMClassifier FwFMRegressor HOFMClassifier HOFMRegressor","title":"facto"},{"location":"api/overview/#feature_extraction","text":"Feature extraction. This module can be used to extract information from raw features. This includes encoding categorical data as well as looking at interactions between existing features. This differs from the processing module in that the latter's purpose is rather to clean the data so that it may be processed by a particular machine learning algorithm. Agg BagOfWords PolynomialExtender RBFSampler TFIDF TargetAgg","title":"feature_extraction"},{"location":"api/overview/#feature_selection","text":"Feature selection. PoissonInclusion SelectKBest VarianceThreshold","title":"feature_selection"},{"location":"api/overview/#imblearn","text":"Sampling methods. HardSamplingClassifier HardSamplingRegressor RandomOverSampler RandomSampler RandomUnderSampler","title":"imblearn"},{"location":"api/overview/#linear_model","text":"Linear models. ALMAClassifier LinearRegression LogisticRegression PAClassifier PARegressor Perceptron SoftmaxRegression","title":"linear_model"},{"location":"api/overview/#meta","text":"Meta-models. BoxCoxRegressor PredClipper TransformedTargetRegressor","title":"meta"},{"location":"api/overview/#metrics","text":"Evaluation metrics. All the metrics are updated one sample at a time. This way we can track performance of predictive methods over time. Accuracy BalancedAccuracy BinaryMetric ClassificationMetric ClassificationReport CohenKappa ConfusionMatrix CrossEntropy ExactMatch ExampleF1 ExampleFBeta ExamplePrecision ExampleRecall F1 FBeta GeometricMean Hamming HammingLoss Jaccard KappaM KappaT LogLoss MAE MCC MSE MacroF1 MacroFBeta MacroPrecision MacroRecall Metric Metrics MicroF1 MicroFBeta MicroPrecision MicroRecall MultiClassMetric MultiFBeta MultiLabelConfusionMatrix MultiOutputClassificationMetric MultiOutputRegressionMetric Precision R2 RMSE RMSLE ROCAUC Recall RegressionMetric RegressionMultiOutput Rolling SMAPE TimeRolling WeightedF1 WeightedFBeta WeightedPrecision WeightedRecall WrapperMetric","title":"metrics"},{"location":"api/overview/#multiclass","text":"Multi-class classification. OneVsOneClassifier OneVsRestClassifier OutputCodeClassifier","title":"multiclass"},{"location":"api/overview/#multioutput","text":"Multi-output models. ClassifierChain MonteCarloClassifierChain ProbabilisticClassifierChain RegressorChain","title":"multioutput"},{"location":"api/overview/#naive_bayes","text":"Naive Bayes algorithms. BernoulliNB ComplementNB GaussianNB MultinomialNB","title":"naive_bayes"},{"location":"api/overview/#neighbors","text":"Neighbors-based learning. Also known as lazy methods. In these methods, generalisation of the training data is delayed until a query is received. KNNADWINClassifier KNNClassifier KNNRegressor SAMKNNClassifier","title":"neighbors"},{"location":"api/overview/#neural_net","text":"Neural networks. MLPRegressor","title":"neural_net"},{"location":"api/overview/#activations","text":"Identity ReLU Sigmoid","title":"activations"},{"location":"api/overview/#optim","text":"Stochastic optimization. AMSGrad AdaBound AdaDelta AdaGrad AdaMax Adam Averager FTRLProximal Momentum Nadam NesterovMomentum Optimizer RMSProp SGD","title":"optim"},{"location":"api/overview/#initializers","text":"Weight initializers. Constant Normal Zeros","title":"initializers"},{"location":"api/overview/#losses","text":"Loss functions. Each loss function is intended to work with both single values as well as numpy vectors. Absolute BinaryFocalLoss BinaryLoss Cauchy CrossEntropy EpsilonInsensitiveHinge Hinge Log MultiClassLoss Poisson Quantile RegressionLoss Squared","title":"losses"},{"location":"api/overview/#schedulers","text":"Learning rate schedulers. Constant InverseScaling Optimal Scheduler","title":"schedulers"},{"location":"api/overview/#preprocessing","text":"Feature preprocessing. The purpose of this module is to modify an existing set of features so that they can be processed by a machine learning algorithm. This may be done by scaling numeric parts of the data or by one-hot encoding categorical features. The difference with the feature_extraction module is that the latter extracts new information from the data AdaptiveStandardScaler Binarizer FeatureHasher LDA MaxAbsScaler MinMaxScaler Normalizer OneHotEncoder PreviousImputer RobustScaler StandardScaler StatImputer","title":"preprocessing"},{"location":"api/overview/#proba","text":"Probability distributions. Gaussian Multinomial","title":"proba"},{"location":"api/overview/#reco","text":"Recommender systems. Baseline BiasedMF FunkMF RandomNormal","title":"reco"},{"location":"api/overview/#stats","text":"Running statistics AbsMax AutoCorr BayesianMean Bivariate Count Cov EWMean EWVar Entropy IQR Kurtosis Link Max Mean Min Mode NUnique PeakToPeak PearsonCorr Quantile RollingAbsMax RollingCov RollingIQR RollingMax RollingMean RollingMin RollingMode RollingPeakToPeak RollingPearsonCorr RollingQuantile RollingSEM RollingSum RollingVar SEM Shift Skew Sum Univariate Var","title":"stats"},{"location":"api/overview/#stream","text":"Streaming utilities. The module includes tools to iterate over data streams. Classes Cache Functions iter_arff iter_array iter_csv iter_libsvm iter_pandas iter_sklearn_dataset iter_sql shuffle simulate_qa","title":"stream"},{"location":"api/overview/#synth","text":"Synthetic datasets. Each synthetic dataset is a stream generator. The benefit of using a generator is that they do not store the data and each data sample is generated on the fly. Except for a couple of methods, the majority of these methods are infinite data generators. Agrawal AnomalySine ConceptDriftStream Friedman FriedmanDrift Hyperplane LED LEDDrift Logical Mixed Mv Planes2D RandomRBF RandomRBFDrift RandomTree SEA STAGGER Sine Waveform","title":"synth"},{"location":"api/overview/#time_series","text":"Time series forecasting. Detrender GroupDetrender SNARIMAX","title":"time_series"},{"location":"api/overview/#tree","text":"ExtremelyFastDecisionTreeClassifier HoeffdingAdaptiveTreeClassifier HoeffdingAdaptiveTreeRegressor HoeffdingTreeClassifier HoeffdingTreeRegressor LabelCombinationHoeffdingTreeClassifier iSOUPTreeRegressor","title":"tree"},{"location":"api/overview/#utils","text":"Utility classes and functions. Classes Histogram SDFT Skyline SortedWindow VectorDict Window Functions check_estimator dict2numpy expand_param_grid numpy2dict","title":"utils"},{"location":"api/overview/#math","text":"Mathematical utility functions (intended for internal purposes). A lot of this is experimental and has a high probability of changing in the future. argmax chain_dot clamp dot dotvecmat matmul2d minkowski_distance norm outer prod sherman_morrison sigmoid sign softmax","title":"math"},{"location":"api/overview/#pretty","text":"Helper functions for making things readable by humans. humanize_bytes print_table","title":"pretty"},{"location":"api/anomaly/HalfSpaceTrees/","text":"HalfSpaceTrees \u00b6 Half-Space Trees (HST). Half-space trees are an online variant of isolation forests. They work well when anomalies are spread out. However, they do not work well if anomalies are packed together in windows. By default, this implementation assumes that each feature has values that are comprised between 0 and 1. If this isn't the case, then you can manually specify the limits via the limits argument. If you do not know the limits in advance, then you can use a preprocessing.MinMaxScaler as an initial preprocessing step. The current implementation builds the trees the first time the learn_one method is called. Therefore, the first learn_one call might be slow, whereas subsequent calls will be very fast in comparison. In general, the computation time of both learn_one and score_one scales linearly with the number of trees, and exponentially with the height of each tree. Note that high scores indicate anomalies, whereas low scores indicate normal observations. Parameters \u00b6 n_trees \u2013 defaults to 10 Number of trees to use. height \u2013 defaults to 8 Height of each tree. Note that a tree of height h is made up of h + 1 levels and therefore contains 2 ** (h + 1) - 1 nodes. window_size \u2013 defaults to 250 Number of observations to use for calculating the mass at each node in each tree. limits ( Dict[Hashable, Tuple[float, float]] ) \u2013 defaults to None Specifies the range of each feature. By default each feature is assumed to be in range [0, 1] . seed ( int ) \u2013 defaults to None Random number seed. Attributes \u00b6 size_limit This is the threshold under which the node search stops during the scoring phase. The value .1 is a magic constant indicated in the original paper. Examples \u00b6 >>> from river import anomaly >>> X = [ 0.5 , 0.45 , 0.43 , 0.44 , 0.445 , 0.45 , 0.0 ] >>> hst = anomaly . HalfSpaceTrees ( ... n_trees = 5 , ... height = 3 , ... window_size = 3 , ... seed = 42 ... ) >>> for x in X [: 3 ]: ... hst = hst . learn_one ({ 'x' : x }) # Warming up >>> for x in X : ... features = { 'x' : x } ... hst = hst . learn_one ( features ) ... print ( f 'Anomaly score for x= { x : .3f } : { hst . score_one ( features ) : .3f } ' ) Anomaly score for x = 0.500 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.430 : 0.107 Anomaly score for x = 0.440 : 0.107 Anomaly score for x = 0.445 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.000 : 0.853 The feature values are all comprised between 0 and 1. This is what is assumed by the model by default. In the following example, we construct a pipeline that scales the data online and ensures that the values of each feature are comprised between 0 and 1. >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees ( seed = 42 ) ... ) >>> auc = metrics . ROCAUC () >>> for x , y in datasets . CreditCard () . take ( 8000 ): ... score = model . score_one ( x ) ... model = model . learn_one ( x , y ) ... auc = auc . update ( y , score ) >>> auc ROCAUC : 0.940431 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a References \u00b6 Tan, S.C., Ting, K.M. and Liu, T.F., 2011, June. Fast anomaly detection for streaming data. In Twenty-Second International Joint Conference on Artificial Intelligence. \u21a9","title":"HalfSpaceTrees"},{"location":"api/anomaly/HalfSpaceTrees/#halfspacetrees","text":"Half-Space Trees (HST). Half-space trees are an online variant of isolation forests. They work well when anomalies are spread out. However, they do not work well if anomalies are packed together in windows. By default, this implementation assumes that each feature has values that are comprised between 0 and 1. If this isn't the case, then you can manually specify the limits via the limits argument. If you do not know the limits in advance, then you can use a preprocessing.MinMaxScaler as an initial preprocessing step. The current implementation builds the trees the first time the learn_one method is called. Therefore, the first learn_one call might be slow, whereas subsequent calls will be very fast in comparison. In general, the computation time of both learn_one and score_one scales linearly with the number of trees, and exponentially with the height of each tree. Note that high scores indicate anomalies, whereas low scores indicate normal observations.","title":"HalfSpaceTrees"},{"location":"api/anomaly/HalfSpaceTrees/#parameters","text":"n_trees \u2013 defaults to 10 Number of trees to use. height \u2013 defaults to 8 Height of each tree. Note that a tree of height h is made up of h + 1 levels and therefore contains 2 ** (h + 1) - 1 nodes. window_size \u2013 defaults to 250 Number of observations to use for calculating the mass at each node in each tree. limits ( Dict[Hashable, Tuple[float, float]] ) \u2013 defaults to None Specifies the range of each feature. By default each feature is assumed to be in range [0, 1] . seed ( int ) \u2013 defaults to None Random number seed.","title":"Parameters"},{"location":"api/anomaly/HalfSpaceTrees/#attributes","text":"size_limit This is the threshold under which the node search stops during the scoring phase. The value .1 is a magic constant indicated in the original paper.","title":"Attributes"},{"location":"api/anomaly/HalfSpaceTrees/#examples","text":">>> from river import anomaly >>> X = [ 0.5 , 0.45 , 0.43 , 0.44 , 0.445 , 0.45 , 0.0 ] >>> hst = anomaly . HalfSpaceTrees ( ... n_trees = 5 , ... height = 3 , ... window_size = 3 , ... seed = 42 ... ) >>> for x in X [: 3 ]: ... hst = hst . learn_one ({ 'x' : x }) # Warming up >>> for x in X : ... features = { 'x' : x } ... hst = hst . learn_one ( features ) ... print ( f 'Anomaly score for x= { x : .3f } : { hst . score_one ( features ) : .3f } ' ) Anomaly score for x = 0.500 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.430 : 0.107 Anomaly score for x = 0.440 : 0.107 Anomaly score for x = 0.445 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.000 : 0.853 The feature values are all comprised between 0 and 1. This is what is assumed by the model by default. In the following example, we construct a pipeline that scales the data online and ensures that the values of each feature are comprised between 0 and 1. >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees ( seed = 42 ) ... ) >>> auc = metrics . ROCAUC () >>> for x , y in datasets . CreditCard () . take ( 8000 ): ... score = model . score_one ( x ) ... model = model . learn_one ( x , y ) ... auc = auc . update ( y , score ) >>> auc ROCAUC : 0.940431","title":"Examples"},{"location":"api/anomaly/HalfSpaceTrees/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/anomaly/HalfSpaceTrees/#references","text":"Tan, S.C., Ting, K.M. and Liu, T.F., 2011, June. Fast anomaly detection for streaming data. In Twenty-Second International Joint Conference on Artificial Intelligence. \u21a9","title":"References"},{"location":"api/base/AnomalyDetector/","text":"AnomalyDetector \u00b6 An anomaly detector. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"AnomalyDetector"},{"location":"api/base/AnomalyDetector/#anomalydetector","text":"An anomaly detector.","title":"AnomalyDetector"},{"location":"api/base/AnomalyDetector/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/base/Base/","text":"Base \u00b6 Base class that is inherited by the majority of classes in River. This base class allows us to handle the following tasks in a uniform manner: Getting and setting parameters. - Displaying information. - Cloning. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Base"},{"location":"api/base/Base/#base","text":"Base class that is inherited by the majority of classes in River. This base class allows us to handle the following tasks in a uniform manner: Getting and setting parameters. - Displaying information. - Cloning.","title":"Base"},{"location":"api/base/Base/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/base/Classifier/","text":"Classifier \u00b6 A classifier. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Classifier"},{"location":"api/base/Classifier/#classifier","text":"A classifier.","title":"Classifier"},{"location":"api/base/Classifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/base/Clusterer/","text":"Clusterer \u00b6 A clustering model. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Clusterer"},{"location":"api/base/Clusterer/#clusterer","text":"A clustering model.","title":"Clusterer"},{"location":"api/base/Clusterer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Methods"},{"location":"api/base/DriftDetector/","text":"DriftDetector \u00b6 A drift detector. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"DriftDetector"},{"location":"api/base/DriftDetector/#driftdetector","text":"A drift detector.","title":"DriftDetector"},{"location":"api/base/DriftDetector/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/base/DriftDetector/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/base/EnsembleMixin/","text":"EnsembleMixin \u00b6 An ensemble model. Parameters \u00b6 models","title":"EnsembleMixin"},{"location":"api/base/EnsembleMixin/#ensemblemixin","text":"An ensemble model.","title":"EnsembleMixin"},{"location":"api/base/EnsembleMixin/#parameters","text":"models","title":"Parameters"},{"location":"api/base/Estimator/","text":"Estimator \u00b6 An estimator. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Estimator"},{"location":"api/base/Estimator/#estimator","text":"An estimator.","title":"Estimator"},{"location":"api/base/Estimator/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/base/MiniBatchClassifier/","text":"MiniBatchClassifier \u00b6 A classifier that can can operate on mini-batches. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"MiniBatchClassifier"},{"location":"api/base/MiniBatchClassifier/#minibatchclassifier","text":"A classifier that can can operate on mini-batches.","title":"MiniBatchClassifier"},{"location":"api/base/MiniBatchClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/base/MiniBatchRegressor/","text":"MiniBatchRegressor \u00b6 A regressor that can operate on mini-batches. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"MiniBatchRegressor"},{"location":"api/base/MiniBatchRegressor/#minibatchregressor","text":"A regressor that can operate on mini-batches.","title":"MiniBatchRegressor"},{"location":"api/base/MiniBatchRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/base/MultiOutputMixin/","text":"MultiOutputMixin \u00b6 A multi-output estimator.","title":"MultiOutputMixin"},{"location":"api/base/MultiOutputMixin/#multioutputmixin","text":"A multi-output estimator.","title":"MultiOutputMixin"},{"location":"api/base/Regressor/","text":"Regressor \u00b6 A regressor. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Regressor"},{"location":"api/base/Regressor/#regressor","text":"A regressor.","title":"Regressor"},{"location":"api/base/Regressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/base/SupervisedTransformer/","text":"SupervisedTransformer \u00b6 A supervised transformer. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) kwargs Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"SupervisedTransformer"},{"location":"api/base/SupervisedTransformer/#supervisedtransformer","text":"A supervised transformer.","title":"SupervisedTransformer"},{"location":"api/base/SupervisedTransformer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) kwargs Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/base/Transformer/","text":"Transformer \u00b6 A transformer. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Transformer"},{"location":"api/base/Transformer/#transformer","text":"A transformer.","title":"Transformer"},{"location":"api/base/Transformer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/base/WrapperMixin/","text":"WrapperMixin \u00b6 A wrapper model.","title":"WrapperMixin"},{"location":"api/base/WrapperMixin/#wrappermixin","text":"A wrapper model.","title":"WrapperMixin"},{"location":"api/cluster/CluStream/","text":"CluStream \u00b6 CluStream The CluStream algorithm 1 maintains statistical information about the data using micro-clusters. These micro-clusters are temporal extensions of cluster feature vectors. The micro-clusters are stored at snapshots in time following a pyramidal pattern. This pattern allows to recall summary statistics from different time horizons. Training with a new point p is performed in two main tasks: Determinate closest micro-cluster to p Check whether p fits (memory) into the closest micro-cluster: if p fits, put into micro-cluster if p does not fit, free some space to insert a new micro-cluster. This is done in two ways, delete an old micro-cluster or merge the two micro-clusters closest to each other. Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions. time_window ( int ) \u2013 defaults to 1000 If the current time is T and the time window is h , we only consider the data that arrived within the period (T-h,T) . max_micro_clusters ( int ) \u2013 defaults to 100 The maximum number of micro-clusters to use. micro_cluster_r_factor ( int ) \u2013 defaults to 2 Multiplier for the micro-cluster radius. When deciding to add a new data point to a micro-cluster, the maximum boundary is defined as a factor of the micro_cluster_r_factor of the RMS deviation of the data points in the micro-cluster from the centroid. n_macro_clusters ( int ) \u2013 defaults to 5 The number of clusters (k) for the k-means algorithm. kwargs Other parameters passed to the incremental kmeans at cluster.KMeans . Attributes \u00b6 centers ( dict ) Central positions of each cluster. Examples \u00b6 In the following example, max_micro_clusters and time_window are set relatively low due to the limited number of training points. Moreover, all points are learnt before any predictions are made. The halflife is set at 0.4, to show that you can pass cluster.KMeans parameters via keyword arguments. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ] ... ] >>> clustream = cluster . CluStream ( time_window = 1 , ... max_micro_clusters = 3 , ... n_macro_clusters = 2 , ... seed = 0 , ... halflife = 0.4 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... clustream = clustream . learn_one ( x ) >>> clustream . predict_one ({ 0 : 1 , 1 : 1 }) 1 >>> clustream . predict_one ({ 0 : 4 , 1 : 3 }) 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number. References \u00b6 Aggarwal, C.C., Philip, S.Y., Han, J. and Wang, J., 2003, A framework for clustering evolving data streams. In Proceedings 2003 VLDB conference (pp. 81-92). Morgan Kaufmann. \u21a9","title":"CluStream"},{"location":"api/cluster/CluStream/#clustream","text":"CluStream The CluStream algorithm 1 maintains statistical information about the data using micro-clusters. These micro-clusters are temporal extensions of cluster feature vectors. The micro-clusters are stored at snapshots in time following a pyramidal pattern. This pattern allows to recall summary statistics from different time horizons. Training with a new point p is performed in two main tasks: Determinate closest micro-cluster to p Check whether p fits (memory) into the closest micro-cluster: if p fits, put into micro-cluster if p does not fit, free some space to insert a new micro-cluster. This is done in two ways, delete an old micro-cluster or merge the two micro-clusters closest to each other.","title":"CluStream"},{"location":"api/cluster/CluStream/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions. time_window ( int ) \u2013 defaults to 1000 If the current time is T and the time window is h , we only consider the data that arrived within the period (T-h,T) . max_micro_clusters ( int ) \u2013 defaults to 100 The maximum number of micro-clusters to use. micro_cluster_r_factor ( int ) \u2013 defaults to 2 Multiplier for the micro-cluster radius. When deciding to add a new data point to a micro-cluster, the maximum boundary is defined as a factor of the micro_cluster_r_factor of the RMS deviation of the data points in the micro-cluster from the centroid. n_macro_clusters ( int ) \u2013 defaults to 5 The number of clusters (k) for the k-means algorithm. kwargs Other parameters passed to the incremental kmeans at cluster.KMeans .","title":"Parameters"},{"location":"api/cluster/CluStream/#attributes","text":"centers ( dict ) Central positions of each cluster.","title":"Attributes"},{"location":"api/cluster/CluStream/#examples","text":"In the following example, max_micro_clusters and time_window are set relatively low due to the limited number of training points. Moreover, all points are learnt before any predictions are made. The halflife is set at 0.4, to show that you can pass cluster.KMeans parameters via keyword arguments. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ] ... ] >>> clustream = cluster . CluStream ( time_window = 1 , ... max_micro_clusters = 3 , ... n_macro_clusters = 2 , ... seed = 0 , ... halflife = 0.4 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... clustream = clustream . learn_one ( x ) >>> clustream . predict_one ({ 0 : 1 , 1 : 1 }) 1 >>> clustream . predict_one ({ 0 : 4 , 1 : 3 }) 0","title":"Examples"},{"location":"api/cluster/CluStream/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/CluStream/#references","text":"Aggarwal, C.C., Philip, S.Y., Han, J. and Wang, J., 2003, A framework for clustering evolving data streams. In Proceedings 2003 VLDB conference (pp. 81-92). Morgan Kaufmann. \u21a9","title":"References"},{"location":"api/cluster/DenStream/","text":"DenStream \u00b6 DenStream DenStream 1 is a clustering algorithm for evolving data streams. DenStream can discover clusters with arbitrary shape and is robust against noise (outliers). \"Dense\" micro-clusters (named core-micro-clusters) summarise the clusters of arbitrary shape. A pruning strategy based on the concepts of potential and outlier micro-clusters guarantees the precision of the weights of the micro-clusters with limited memory. The algorithm is divided into two parts: Online micro-cluster maintenance (learning) For a new point p : Try to merge p into either the nearest p-micro-cluster (potential), o-micro-cluster (outlier), or create a new o-micro-cluster and insert it into the outlier buffer. For each T_p iterations, consider the weights of all potential and outlier micro-clusters. If their weights are smaller than a certain threshold (different for each type of micro-clusters), the micro-cluster is deleted. Offline generation of clusters on-demand (clustering) A variant of the DBSCAN algorithm 2 is used, such that all density-connected p-micro-clusters determine the final clusters. Parameters \u00b6 decaying_factor ( float ) \u2013 defaults to 0.25 Parameter that controls the importance of historical data to current cluster. Note that decaying_factor has to be different from 0 . core_weight_threshold ( float ) \u2013 defaults to 5 Parameter to determine the threshold of outlier relative to core micro-clusters. Note that core_weight_threshold * tolerance_factor has to be greater than 1 or less than 0 . tolerance_factor ( float ) \u2013 defaults to 0.5 Parameter to determine the threshold of outliers relative to core micro-cluster. In a normal setting, this parameter is usuallly set within the range [0,1] . Once again, note that core_weight_threshold * tolerance_factor has to be greater than 1 or less than 0 . radius ( float ) \u2013 defaults to 2 This parameter is passed onto the DBSCAN offline algorithm as the \\(\\epsilon\\) parameter when a clustering request arrives. Attributes \u00b6 n_clusters Number of clusters generated by the algorithm. clusters A set of final clusters of type MicroCluster , which means that these cluster include all the required information, including number of points, creation time, weight, (weighted) linear sum, (weighted) square sum, center and radius. p_micro_clusters The p micro-clusters that are generated by the algorithm. When a generating cluster request arrives, these p-micro-clusters will go through a variant of DBSCAN algorithm to determine the final clusters. o_micro_clusters The outlier buffer, separating the processing of the potential core-micro-cluster and outlier-micro-clusters. Examples \u00b6 The following example uses the default parameters of the algorithm to test its functionality. It can easily be seen that the set of evolving points X are designed so that there can be a clear picture drawn on how the clusters can be generated. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 0.5 ], [ 1 , 0.625 ], [ 1 , 0.75 ], [ 1 , 1.125 ], [ 1 , 1.5 ], [ 1 , 1.75 ], ... [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ] ... ] >>> denstream = cluster . DenStream ( decaying_factor = 0.25 , ... core_weight_threshold = 2 , ... tolerance_factor = 0.75 , ... radius = 0.5 ) >>> for x , _ in stream . iter_array ( X ): ... denstream = denstream . learn_one ( x ) >>> denstream . predict_one ({ 0 : 1 , 1 : 2 }) 0 >>> denstream . predict_one ({ 0 : 5 , 1 : 2 }) 0 >>> denstream . n_clusters 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number. References \u00b6 Feng et al (2006, pp 328-339). Density-Based Clustering over an Evolving Data Stream with Noise. In Proceedings of the Sixth SIAM International Conference on Data Mining, April 20\u201322, 2006, Bethesda, MD, USA. \u21a9 Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In KDD-96 Proceedings, AAAI. \u21a9","title":"DenStream"},{"location":"api/cluster/DenStream/#denstream","text":"DenStream DenStream 1 is a clustering algorithm for evolving data streams. DenStream can discover clusters with arbitrary shape and is robust against noise (outliers). \"Dense\" micro-clusters (named core-micro-clusters) summarise the clusters of arbitrary shape. A pruning strategy based on the concepts of potential and outlier micro-clusters guarantees the precision of the weights of the micro-clusters with limited memory. The algorithm is divided into two parts: Online micro-cluster maintenance (learning) For a new point p : Try to merge p into either the nearest p-micro-cluster (potential), o-micro-cluster (outlier), or create a new o-micro-cluster and insert it into the outlier buffer. For each T_p iterations, consider the weights of all potential and outlier micro-clusters. If their weights are smaller than a certain threshold (different for each type of micro-clusters), the micro-cluster is deleted. Offline generation of clusters on-demand (clustering) A variant of the DBSCAN algorithm 2 is used, such that all density-connected p-micro-clusters determine the final clusters.","title":"DenStream"},{"location":"api/cluster/DenStream/#parameters","text":"decaying_factor ( float ) \u2013 defaults to 0.25 Parameter that controls the importance of historical data to current cluster. Note that decaying_factor has to be different from 0 . core_weight_threshold ( float ) \u2013 defaults to 5 Parameter to determine the threshold of outlier relative to core micro-clusters. Note that core_weight_threshold * tolerance_factor has to be greater than 1 or less than 0 . tolerance_factor ( float ) \u2013 defaults to 0.5 Parameter to determine the threshold of outliers relative to core micro-cluster. In a normal setting, this parameter is usuallly set within the range [0,1] . Once again, note that core_weight_threshold * tolerance_factor has to be greater than 1 or less than 0 . radius ( float ) \u2013 defaults to 2 This parameter is passed onto the DBSCAN offline algorithm as the \\(\\epsilon\\) parameter when a clustering request arrives.","title":"Parameters"},{"location":"api/cluster/DenStream/#attributes","text":"n_clusters Number of clusters generated by the algorithm. clusters A set of final clusters of type MicroCluster , which means that these cluster include all the required information, including number of points, creation time, weight, (weighted) linear sum, (weighted) square sum, center and radius. p_micro_clusters The p micro-clusters that are generated by the algorithm. When a generating cluster request arrives, these p-micro-clusters will go through a variant of DBSCAN algorithm to determine the final clusters. o_micro_clusters The outlier buffer, separating the processing of the potential core-micro-cluster and outlier-micro-clusters.","title":"Attributes"},{"location":"api/cluster/DenStream/#examples","text":"The following example uses the default parameters of the algorithm to test its functionality. It can easily be seen that the set of evolving points X are designed so that there can be a clear picture drawn on how the clusters can be generated. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 0.5 ], [ 1 , 0.625 ], [ 1 , 0.75 ], [ 1 , 1.125 ], [ 1 , 1.5 ], [ 1 , 1.75 ], ... [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ] ... ] >>> denstream = cluster . DenStream ( decaying_factor = 0.25 , ... core_weight_threshold = 2 , ... tolerance_factor = 0.75 , ... radius = 0.5 ) >>> for x , _ in stream . iter_array ( X ): ... denstream = denstream . learn_one ( x ) >>> denstream . predict_one ({ 0 : 1 , 1 : 2 }) 0 >>> denstream . predict_one ({ 0 : 5 , 1 : 2 }) 0 >>> denstream . n_clusters 1","title":"Examples"},{"location":"api/cluster/DenStream/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/DenStream/#references","text":"Feng et al (2006, pp 328-339). Density-Based Clustering over an Evolving Data Stream with Noise. In Proceedings of the Sixth SIAM International Conference on Data Mining, April 20\u201322, 2006, Bethesda, MD, USA. \u21a9 Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In KDD-96 Proceedings, AAAI. \u21a9","title":"References"},{"location":"api/cluster/KMeans/","text":"KMeans \u00b6 Incremental k-means. The most common way to implement batch k-means is to use Lloyd's algorithm, which consists in assigning all the data points to a set of cluster centers and then moving the centers accordingly. This requires multiple passes over the data and thus isn't applicable in a streaming setting. In this implementation we start by finding the cluster that is closest to the current observation. We then move the cluster's central position towards the new observation. The halflife parameter determines by how much to move the cluster toward the new observation. You will get better results if you scale your data appropriately. Parameters \u00b6 n_clusters \u2013 defaults to 5 Maximum number of clusters to assign. halflife \u2013 defaults to 0.5 Amount by which to move the cluster centers, a reasonable value if between 0 and 1. mu \u2013 defaults to 0 Mean of the normal distribution used to instantiate cluster positions. sigma \u2013 defaults to 1 Standard deviation of the normal distribution used to instantiate cluster positions. p \u2013 defaults to 2 Power parameter for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions. Attributes \u00b6 centers ( dict ) Central positions of each cluster. Examples \u00b6 In the following example the cluster assignments are exactly the same as when using sklearn 's batch implementation. However changing the halflife parameter will produce different outputs. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ] ... ] >>> k_means = cluster . KMeans ( n_clusters = 2 , halflife = 0.4 , sigma = 3 , seed = 0 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... k_means = k_means . learn_one ( x ) ... print ( f ' { X [ i ] } is assigned to cluster { k_means . predict_one ( x ) } ' ) [ 1 , 2 ] is assigned to cluster 1 [ 1 , 4 ] is assigned to cluster 1 [ 1 , 0 ] is assigned to cluster 0 [ 4 , 2 ] is assigned to cluster 0 [ 4 , 4 ] is assigned to cluster 0 [ 4 , 0 ] is assigned to cluster 0 >>> k_means . predict_one ({ 0 : 0 , 1 : 0 }) 1 >>> k_means . predict_one ({ 0 : 4 , 1 : 4 }) 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) Returns Clusterer : self learn_predict_one Equivalent to k_means.learn_one(x).predict_one(x) , but faster. Parameters x predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number. References \u00b6 Sequential k-Means Clustering \u21a9 Sculley, D., 2010, April. Web-scale k-means clustering. In Proceedings of the 19th international conference on World wide web (pp. 1177-1178 \u21a9","title":"KMeans"},{"location":"api/cluster/KMeans/#kmeans","text":"Incremental k-means. The most common way to implement batch k-means is to use Lloyd's algorithm, which consists in assigning all the data points to a set of cluster centers and then moving the centers accordingly. This requires multiple passes over the data and thus isn't applicable in a streaming setting. In this implementation we start by finding the cluster that is closest to the current observation. We then move the cluster's central position towards the new observation. The halflife parameter determines by how much to move the cluster toward the new observation. You will get better results if you scale your data appropriately.","title":"KMeans"},{"location":"api/cluster/KMeans/#parameters","text":"n_clusters \u2013 defaults to 5 Maximum number of clusters to assign. halflife \u2013 defaults to 0.5 Amount by which to move the cluster centers, a reasonable value if between 0 and 1. mu \u2013 defaults to 0 Mean of the normal distribution used to instantiate cluster positions. sigma \u2013 defaults to 1 Standard deviation of the normal distribution used to instantiate cluster positions. p \u2013 defaults to 2 Power parameter for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions.","title":"Parameters"},{"location":"api/cluster/KMeans/#attributes","text":"centers ( dict ) Central positions of each cluster.","title":"Attributes"},{"location":"api/cluster/KMeans/#examples","text":"In the following example the cluster assignments are exactly the same as when using sklearn 's batch implementation. However changing the halflife parameter will produce different outputs. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ] ... ] >>> k_means = cluster . KMeans ( n_clusters = 2 , halflife = 0.4 , sigma = 3 , seed = 0 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... k_means = k_means . learn_one ( x ) ... print ( f ' { X [ i ] } is assigned to cluster { k_means . predict_one ( x ) } ' ) [ 1 , 2 ] is assigned to cluster 1 [ 1 , 4 ] is assigned to cluster 1 [ 1 , 0 ] is assigned to cluster 0 [ 4 , 2 ] is assigned to cluster 0 [ 4 , 4 ] is assigned to cluster 0 [ 4 , 0 ] is assigned to cluster 0 >>> k_means . predict_one ({ 0 : 0 , 1 : 0 }) 1 >>> k_means . predict_one ({ 0 : 4 , 1 : 4 }) 0","title":"Examples"},{"location":"api/cluster/KMeans/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) Returns Clusterer : self learn_predict_one Equivalent to k_means.learn_one(x).predict_one(x) , but faster. Parameters x predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/KMeans/#references","text":"Sequential k-Means Clustering \u21a9 Sculley, D., 2010, April. Web-scale k-means clustering. In Proceedings of the 19th international conference on World wide web (pp. 1177-1178 \u21a9","title":"References"},{"location":"api/compat/River2SKLClassifier/","text":"River2SKLClassifier \u00b6 Compatibility layer from River to scikit-learn for classification. Parameters \u00b6 river_estimator ( base.Classifier ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y classes \u2013 defaults to None Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . predict_proba Predicts the target probability of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . score Return the mean accuracy on the given test data and labels. In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"River2SKLClassifier"},{"location":"api/compat/River2SKLClassifier/#river2sklclassifier","text":"Compatibility layer from River to scikit-learn for classification.","title":"River2SKLClassifier"},{"location":"api/compat/River2SKLClassifier/#parameters","text":"river_estimator ( base.Classifier )","title":"Parameters"},{"location":"api/compat/River2SKLClassifier/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y classes \u2013 defaults to None Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . predict_proba Predicts the target probability of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . score Return the mean accuracy on the given test data and labels. In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"Methods"},{"location":"api/compat/River2SKLClusterer/","text":"River2SKLClusterer \u00b6 Compatibility layer from River to scikit-learn for clustering. Parameters \u00b6 river_estimator ( base.Clusterer ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_predict Perform clustering on X and returns cluster labels. Parameters X y \u2013 defaults to None Returns ndarray of shape (n_samples,), dtype=np.int64 get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output. set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"River2SKLClusterer"},{"location":"api/compat/River2SKLClusterer/#river2sklclusterer","text":"Compatibility layer from River to scikit-learn for clustering.","title":"River2SKLClusterer"},{"location":"api/compat/River2SKLClusterer/#parameters","text":"river_estimator ( base.Clusterer )","title":"Parameters"},{"location":"api/compat/River2SKLClusterer/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_predict Perform clustering on X and returns cluster labels. Parameters X y \u2013 defaults to None Returns ndarray of shape (n_samples,), dtype=np.int64 get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output. set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"Methods"},{"location":"api/compat/River2SKLRegressor/","text":"River2SKLRegressor \u00b6 Compatibility layer from River to scikit-learn for regression. Parameters \u00b6 river_estimator ( base.Regressor ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns ndarray : Predicted target values for each row of X . score Return the coefficient of determination :math: R^2 of the prediction. The coefficient :math: R^2 is defined as :math: (1 - \\frac{u}{v}) , where :math: u is the residual sum of squares ((y_true - y_pred) ** 2).sum() and :math: v is the total sum of squares ((y_true - y_true.mean()) ** 2).sum() . The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y , disregarding the input features, would get a :math: R^2 score of 0.0. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"River2SKLRegressor"},{"location":"api/compat/River2SKLRegressor/#river2sklregressor","text":"Compatibility layer from River to scikit-learn for regression.","title":"River2SKLRegressor"},{"location":"api/compat/River2SKLRegressor/#parameters","text":"river_estimator ( base.Regressor )","title":"Parameters"},{"location":"api/compat/River2SKLRegressor/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns ndarray : Predicted target values for each row of X . score Return the coefficient of determination :math: R^2 of the prediction. The coefficient :math: R^2 is defined as :math: (1 - \\frac{u}{v}) , where :math: u is the residual sum of squares ((y_true - y_pred) ** 2).sum() and :math: v is the total sum of squares ((y_true - y_true.mean()) ** 2).sum() . The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y , disregarding the input features, would get a :math: R^2 score of 0.0. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"Methods"},{"location":"api/compat/River2SKLTransformer/","text":"River2SKLTransformer \u00b6 Compatibility layer from River to scikit-learn for transformation. Parameters \u00b6 river_estimator ( base.Transformer ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_transform Fit to data, then transform it. Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X . Parameters X y \u2013 defaults to None fit_params Returns ndarray array of shape (n_samples, n_features_new) get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y \u2013 defaults to None Returns self set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance transform Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output.","title":"River2SKLTransformer"},{"location":"api/compat/River2SKLTransformer/#river2skltransformer","text":"Compatibility layer from River to scikit-learn for transformation.","title":"River2SKLTransformer"},{"location":"api/compat/River2SKLTransformer/#parameters","text":"river_estimator ( base.Transformer )","title":"Parameters"},{"location":"api/compat/River2SKLTransformer/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_transform Fit to data, then transform it. Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X . Parameters X y \u2013 defaults to None fit_params Returns ndarray array of shape (n_samples, n_features_new) get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y \u2013 defaults to None Returns self set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance transform Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output.","title":"Methods"},{"location":"api/compat/SKL2RiverClassifier/","text":"SKL2RiverClassifier \u00b6 Compatibility layer from scikit-learn to River for classification. Parameters \u00b6 estimator ( sklearn.base.ClassifierMixin ) A scikit-learn regressor which has a partial_fit method. classes ( list ) Examples \u00b6 >>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_breast_cancer (), ... shuffle = True , ... seed = 42 ... ) >>> model = preprocessing . StandardScaler () >>> model |= compat . convert_sklearn_to_river ( ... estimator = linear_model . SGDClassifier ( ... loss = 'log' , ... eta0 = 0.01 , ... learning_rate = 'constant' ... ), ... classes = [ False , True ] ... ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.199554 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X Returns Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X Returns DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"SKL2RiverClassifier"},{"location":"api/compat/SKL2RiverClassifier/#skl2riverclassifier","text":"Compatibility layer from scikit-learn to River for classification.","title":"SKL2RiverClassifier"},{"location":"api/compat/SKL2RiverClassifier/#parameters","text":"estimator ( sklearn.base.ClassifierMixin ) A scikit-learn regressor which has a partial_fit method. classes ( list )","title":"Parameters"},{"location":"api/compat/SKL2RiverClassifier/#examples","text":">>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_breast_cancer (), ... shuffle = True , ... seed = 42 ... ) >>> model = preprocessing . StandardScaler () >>> model |= compat . convert_sklearn_to_river ( ... estimator = linear_model . SGDClassifier ( ... loss = 'log' , ... eta0 = 0.01 , ... learning_rate = 'constant' ... ), ... classes = [ False , True ] ... ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.199554","title":"Examples"},{"location":"api/compat/SKL2RiverClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X Returns Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X Returns DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/compat/SKL2RiverRegressor/","text":"SKL2RiverRegressor \u00b6 Compatibility layer from scikit-learn to River for regression. Parameters \u00b6 estimator ( sklearn.base.BaseEstimator ) A scikit-learn transformer which has a partial_fit method. Examples \u00b6 >>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_boston (), ... shuffle = True , ... seed = 42 ... ) >>> scaler = preprocessing . StandardScaler () >>> sgd_reg = compat . convert_sklearn_to_river ( linear_model . SGDRegressor ()) >>> model = scaler | sgd_reg >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 11.004415 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_many predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"SKL2RiverRegressor"},{"location":"api/compat/SKL2RiverRegressor/#skl2riverregressor","text":"Compatibility layer from scikit-learn to River for regression.","title":"SKL2RiverRegressor"},{"location":"api/compat/SKL2RiverRegressor/#parameters","text":"estimator ( sklearn.base.BaseEstimator ) A scikit-learn transformer which has a partial_fit method.","title":"Parameters"},{"location":"api/compat/SKL2RiverRegressor/#examples","text":">>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_boston (), ... shuffle = True , ... seed = 42 ... ) >>> scaler = preprocessing . StandardScaler () >>> sgd_reg = compat . convert_sklearn_to_river ( linear_model . SGDRegressor ()) >>> model = scaler | sgd_reg >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 11.004415","title":"Examples"},{"location":"api/compat/SKL2RiverRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_many predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/compat/convert-river-to-sklearn/","text":"convert_river_to_sklearn \u00b6 Wraps a river estimator to make it compatible with scikit-learn. Parameters \u00b6 estimator ( base.Estimator )","title":"convert_river_to_sklearn"},{"location":"api/compat/convert-river-to-sklearn/#convert_river_to_sklearn","text":"Wraps a river estimator to make it compatible with scikit-learn.","title":"convert_river_to_sklearn"},{"location":"api/compat/convert-river-to-sklearn/#parameters","text":"estimator ( base.Estimator )","title":"Parameters"},{"location":"api/compat/convert-sklearn-to-river/","text":"convert_sklearn_to_river \u00b6 Wraps a scikit-learn estimator to make it compatible with river. Parameters \u00b6 estimator ( sklearn.base.BaseEstimator ) classes ( list ) \u2013 defaults to None Class names necessary for classifiers.","title":"convert_sklearn_to_river"},{"location":"api/compat/convert-sklearn-to-river/#convert_sklearn_to_river","text":"Wraps a scikit-learn estimator to make it compatible with river.","title":"convert_sklearn_to_river"},{"location":"api/compat/convert-sklearn-to-river/#parameters","text":"estimator ( sklearn.base.BaseEstimator ) classes ( list ) \u2013 defaults to None Class names necessary for classifiers.","title":"Parameters"},{"location":"api/compose/Discard/","text":"Discard \u00b6 Removes features according to a blacklist. This can be used in a pipeline when you want to remove certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input. Parameters \u00b6 blacklist ( Tuple[Hashable] ) Key(s) to discard. Examples \u00b6 >>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Discard ( 'a' , 'b' ) . transform_one ( x ) { 'c' : 13 } You can chain a discarder with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Discard ( 'shop' , 'country' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Discard"},{"location":"api/compose/Discard/#discard","text":"Removes features according to a blacklist. This can be used in a pipeline when you want to remove certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input.","title":"Discard"},{"location":"api/compose/Discard/#parameters","text":"blacklist ( Tuple[Hashable] ) Key(s) to discard.","title":"Parameters"},{"location":"api/compose/Discard/#examples","text":">>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Discard ( 'a' , 'b' ) . transform_one ( x ) { 'c' : 13 } You can chain a discarder with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Discard ( 'shop' , 'country' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 }","title":"Examples"},{"location":"api/compose/Discard/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/FuncTransformer/","text":"FuncTransformer \u00b6 Wraps a function to make it usable in a pipeline. There is often a need to apply an arbitrary transformation to a set of features. For instance, this could involve parsing a date and then extracting the hour from said date. If you're processing a stream of data, then you can do this yourself by calling the necessary code at your leisure. On the other hand, if you want to do this as part of a pipeline, then you need to follow a simple convention. To use a function as part of a pipeline, take as input a dict of features and output a dict . Once you have initialized this class with your function, then you can use it like you would use any other (unsupervised) transformer. It is up to you if you want your function to be pure or not. By pure we refer to a function that doesn't modify its input. However, we recommend writing pure functions because this reduces the chances of inserting bugs into your pipeline. Parameters \u00b6 func ( Callable[[dict], dict] ) A function that takes as input a dict and outputs a dict . Examples \u00b6 >>> from pprint import pprint >>> import datetime as dt >>> from river import compose >>> x = { 'date' : '2019-02-14' } >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... x [ 'is_weekend' ] = date . day in ( 5 , 6 ) ... x [ 'hour' ] = date . hour ... return x >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } The above example is not pure because it modifies the input. The following example is pure and produces the same output: >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'hour' : 0 , 'is_weekend' : False } The previous example doesn't include the date feature because it returns a new dict . However, a common usecase is to add a feature to an existing set of features. You can do this in a pure way by unpacking the input dict into the output dict : >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour , ** x } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } You can add FuncTransformer to a pipeline just like you would with any other transformer. >>> from river import naive_bayes >>> pipeline = compose . FuncTransformer ( parse_date ) | naive_bayes . MultinomialNB () >>> pipeline Pipeline ( FuncTransformer ( func = \"parse_date\" ), MultinomialNB ( alpha = 1. ) ) If you provide a function with wrapping it, then the pipeline will do it for you: >>> pipeline = parse_date | naive_bayes . MultinomialNB () Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"FuncTransformer"},{"location":"api/compose/FuncTransformer/#functransformer","text":"Wraps a function to make it usable in a pipeline. There is often a need to apply an arbitrary transformation to a set of features. For instance, this could involve parsing a date and then extracting the hour from said date. If you're processing a stream of data, then you can do this yourself by calling the necessary code at your leisure. On the other hand, if you want to do this as part of a pipeline, then you need to follow a simple convention. To use a function as part of a pipeline, take as input a dict of features and output a dict . Once you have initialized this class with your function, then you can use it like you would use any other (unsupervised) transformer. It is up to you if you want your function to be pure or not. By pure we refer to a function that doesn't modify its input. However, we recommend writing pure functions because this reduces the chances of inserting bugs into your pipeline.","title":"FuncTransformer"},{"location":"api/compose/FuncTransformer/#parameters","text":"func ( Callable[[dict], dict] ) A function that takes as input a dict and outputs a dict .","title":"Parameters"},{"location":"api/compose/FuncTransformer/#examples","text":">>> from pprint import pprint >>> import datetime as dt >>> from river import compose >>> x = { 'date' : '2019-02-14' } >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... x [ 'is_weekend' ] = date . day in ( 5 , 6 ) ... x [ 'hour' ] = date . hour ... return x >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } The above example is not pure because it modifies the input. The following example is pure and produces the same output: >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'hour' : 0 , 'is_weekend' : False } The previous example doesn't include the date feature because it returns a new dict . However, a common usecase is to add a feature to an existing set of features. You can do this in a pure way by unpacking the input dict into the output dict : >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour , ** x } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } You can add FuncTransformer to a pipeline just like you would with any other transformer. >>> from river import naive_bayes >>> pipeline = compose . FuncTransformer ( parse_date ) | naive_bayes . MultinomialNB () >>> pipeline Pipeline ( FuncTransformer ( func = \"parse_date\" ), MultinomialNB ( alpha = 1. ) ) If you provide a function with wrapping it, then the pipeline will do it for you: >>> pipeline = parse_date | naive_bayes . MultinomialNB ()","title":"Examples"},{"location":"api/compose/FuncTransformer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Grouper/","text":"Grouper \u00b6 Applies a transformer within different groups. This transformer allows you to split your data into groups and apply a transformer within each group. This happens in a streaming manner, which means that the groups are discovered online. A separate copy of the provided transformer is made whenever a new group appears. The groups are defined according to one or more keys. Parameters \u00b6 transformer ( base.Transformer ) by ( Union[Hashable, List[Hashable]] ) The field on which to group the data. This can either by a single value, or a list of values. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Grouper"},{"location":"api/compose/Grouper/#grouper","text":"Applies a transformer within different groups. This transformer allows you to split your data into groups and apply a transformer within each group. This happens in a streaming manner, which means that the groups are discovered online. A separate copy of the provided transformer is made whenever a new group appears. The groups are defined according to one or more keys.","title":"Grouper"},{"location":"api/compose/Grouper/#parameters","text":"transformer ( base.Transformer ) by ( Union[Hashable, List[Hashable]] ) The field on which to group the data. This can either by a single value, or a list of values.","title":"Parameters"},{"location":"api/compose/Grouper/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Pipeline/","text":"Pipeline \u00b6 A pipeline of estimators. Pipelines allow you to chain different steps into a sequence. Typically, when doing supervised learning, a pipeline contains one ore more transformation steps, whilst it's is a regressor or a classifier. It is highly recommended to use pipelines with river . Indeed, in an online learning setting, it is very practical to have a model defined as a single object. Take a look at the user guide for further information and practical examples. One special thing to take notice to is the way transformers are handled. In a typical scenario, it is usual to predict something for a sample and wait for the ground truth to arrive. In such a case, the features are seen before the ground truth arrives. Therefore, the unsupervised parts of the pipeline are updated when predict_one and predict_proba_one are called. Usually the unsupervised parts of the pipeline are all the steps that precede the final step, which is a supervised model. However, some transformers are supervised and are therefore obtained during calls to learn_one . Parameters \u00b6 steps Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided. Examples \u00b6 The recommended way to declare a pipeline is to use the | operator. The latter allows you to chain estimators in a very terse manner: >>> from river import linear_model >>> from river import preprocessing >>> scaler = preprocessing . StandardScaler () >>> log_reg = linear_model . LinearRegression () >>> model = scaler | log_reg This results in a pipeline that stores each step inside a dictionary. >>> model Pipeline ( StandardScaler (), LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) ) You can access parts of a pipeline in the same manner as a dictionary: >>> model [ 'LinearRegression' ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) Note that you can also declare a pipeline by using the compose.Pipeline constructor method, which is slightly more verbose: >>> from river import compose >>> model = compose . Pipeline ( scaler , log_reg ) By using a compose.TransformerUnion , you can define complex pipelines that apply different steps to different parts of the data. For instance, we can extract word counts from text data, and extract polynomial features from numeric data. >>> from river import feature_extraction as fx >>> tfidf = fx . TFIDF ( 'text' ) >>> counts = fx . BagOfWords ( 'text' ) >>> text_part = compose . Select ( 'text' ) | ( tfidf + counts ) >>> num_part = compose . Select ( 'a' , 'b' ) | fx . PolynomialExtender () >>> model = text_part + num_part >>> model |= preprocessing . StandardScaler () >>> model |= linear_model . LinearRegression () You can obtain a visual representation of the pipeline by calling it's draw method. >>> dot = model . draw () The following shows an example of using debug_one to visualize how the information flows and changes throughout the pipeline. >>> from river import compose >>> from river import naive_bayes >>> dataset = [ ... ( 'A positive comment' , True ), ... ( 'A negative comment' , False ), ... ( 'A happy comment' , True ), ... ( 'A lovely comment' , True ), ... ( 'A harsh comment' , False ) ... ] >>> tfidf = fx . TFIDF () | compose . Renamer ( prefix = 'tfidf_' ) >>> counts = fx . BagOfWords () | compose . Renamer ( prefix = 'count_' ) >>> mnb = naive_bayes . MultinomialNB () >>> model = ( tfidf + counts ) | mnb >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> x = dataset [ 0 ][ 0 ] >>> report = model . debug_one ( dataset [ 0 ][ 0 ]) >>> print ( report ) 0. Input -------- A positive comment < BLANKLINE > 1. Transformer union -------------------- 1.0 TFIDF | Renamer ------------------- tfidf_comment : 0.47606 ( float ) tfidf_positive : 0.87942 ( float ) < BLANKLINE > 1.1 BagOfWords | Renamer ------------------------ count_comment : 1 ( int ) count_positive : 1 ( int ) < BLANKLINE > count_comment : 1 ( int ) count_positive : 1 ( int ) tfidf_comment : 0.50854 ( float ) tfidf_positive : 0.86104 ( float ) < BLANKLINE > 2. MultinomialNB ---------------- False : 0.19313 True : 0.80687 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Displays the state of a set of features as it goes through the pipeline. Parameters x ( dict ) show_types \u2013 defaults to True n_decimals \u2013 defaults to 5 draw Draws the pipeline using the graphviz library. forecast Return a forecast. Only works if each estimator has a transform_one method and the final estimator has a forecast method. This is the case of time series models from the time_series module. Parameters horizon ( int ) xs ( List[dict] ) \u2013 defaults to None learn_many Fit to a mini-batch. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None params learn_one Fit to a single instance. Parameters x ( dict ) y \u2013 defaults to None params predict_many predict_one predict_proba_many predict_proba_one score_one transform_many Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters X ( pandas.core.frame.DataFrame ) transform_one Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters x ( dict ) learn_unsupervised ( bool ) \u2013 defaults to True","title":"Pipeline"},{"location":"api/compose/Pipeline/#pipeline","text":"A pipeline of estimators. Pipelines allow you to chain different steps into a sequence. Typically, when doing supervised learning, a pipeline contains one ore more transformation steps, whilst it's is a regressor or a classifier. It is highly recommended to use pipelines with river . Indeed, in an online learning setting, it is very practical to have a model defined as a single object. Take a look at the user guide for further information and practical examples. One special thing to take notice to is the way transformers are handled. In a typical scenario, it is usual to predict something for a sample and wait for the ground truth to arrive. In such a case, the features are seen before the ground truth arrives. Therefore, the unsupervised parts of the pipeline are updated when predict_one and predict_proba_one are called. Usually the unsupervised parts of the pipeline are all the steps that precede the final step, which is a supervised model. However, some transformers are supervised and are therefore obtained during calls to learn_one .","title":"Pipeline"},{"location":"api/compose/Pipeline/#parameters","text":"steps Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.","title":"Parameters"},{"location":"api/compose/Pipeline/#examples","text":"The recommended way to declare a pipeline is to use the | operator. The latter allows you to chain estimators in a very terse manner: >>> from river import linear_model >>> from river import preprocessing >>> scaler = preprocessing . StandardScaler () >>> log_reg = linear_model . LinearRegression () >>> model = scaler | log_reg This results in a pipeline that stores each step inside a dictionary. >>> model Pipeline ( StandardScaler (), LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) ) You can access parts of a pipeline in the same manner as a dictionary: >>> model [ 'LinearRegression' ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) Note that you can also declare a pipeline by using the compose.Pipeline constructor method, which is slightly more verbose: >>> from river import compose >>> model = compose . Pipeline ( scaler , log_reg ) By using a compose.TransformerUnion , you can define complex pipelines that apply different steps to different parts of the data. For instance, we can extract word counts from text data, and extract polynomial features from numeric data. >>> from river import feature_extraction as fx >>> tfidf = fx . TFIDF ( 'text' ) >>> counts = fx . BagOfWords ( 'text' ) >>> text_part = compose . Select ( 'text' ) | ( tfidf + counts ) >>> num_part = compose . Select ( 'a' , 'b' ) | fx . PolynomialExtender () >>> model = text_part + num_part >>> model |= preprocessing . StandardScaler () >>> model |= linear_model . LinearRegression () You can obtain a visual representation of the pipeline by calling it's draw method. >>> dot = model . draw () The following shows an example of using debug_one to visualize how the information flows and changes throughout the pipeline. >>> from river import compose >>> from river import naive_bayes >>> dataset = [ ... ( 'A positive comment' , True ), ... ( 'A negative comment' , False ), ... ( 'A happy comment' , True ), ... ( 'A lovely comment' , True ), ... ( 'A harsh comment' , False ) ... ] >>> tfidf = fx . TFIDF () | compose . Renamer ( prefix = 'tfidf_' ) >>> counts = fx . BagOfWords () | compose . Renamer ( prefix = 'count_' ) >>> mnb = naive_bayes . MultinomialNB () >>> model = ( tfidf + counts ) | mnb >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> x = dataset [ 0 ][ 0 ] >>> report = model . debug_one ( dataset [ 0 ][ 0 ]) >>> print ( report ) 0. Input -------- A positive comment < BLANKLINE > 1. Transformer union -------------------- 1.0 TFIDF | Renamer ------------------- tfidf_comment : 0.47606 ( float ) tfidf_positive : 0.87942 ( float ) < BLANKLINE > 1.1 BagOfWords | Renamer ------------------------ count_comment : 1 ( int ) count_positive : 1 ( int ) < BLANKLINE > count_comment : 1 ( int ) count_positive : 1 ( int ) tfidf_comment : 0.50854 ( float ) tfidf_positive : 0.86104 ( float ) < BLANKLINE > 2. MultinomialNB ---------------- False : 0.19313 True : 0.80687","title":"Examples"},{"location":"api/compose/Pipeline/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Displays the state of a set of features as it goes through the pipeline. Parameters x ( dict ) show_types \u2013 defaults to True n_decimals \u2013 defaults to 5 draw Draws the pipeline using the graphviz library. forecast Return a forecast. Only works if each estimator has a transform_one method and the final estimator has a forecast method. This is the case of time series models from the time_series module. Parameters horizon ( int ) xs ( List[dict] ) \u2013 defaults to None learn_many Fit to a mini-batch. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None params learn_one Fit to a single instance. Parameters x ( dict ) y \u2013 defaults to None params predict_many predict_one predict_proba_many predict_proba_one score_one transform_many Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters X ( pandas.core.frame.DataFrame ) transform_one Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters x ( dict ) learn_unsupervised ( bool ) \u2013 defaults to True","title":"Methods"},{"location":"api/compose/Renamer/","text":"Renamer \u00b6 Renames keys based on given parameters. Parameters \u00b6 prefix \u2013 defaults to None suffix \u2013 defaults to None Examples \u00b6 >>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Renamer ( prefix = 'prefix_' , suffix = '_suffix' ) . transform_one ( x ) { 'prefix_a_suffix' : 42 , 'prefix_b_suffix' : 12 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Renamer"},{"location":"api/compose/Renamer/#renamer","text":"Renames keys based on given parameters.","title":"Renamer"},{"location":"api/compose/Renamer/#parameters","text":"prefix \u2013 defaults to None suffix \u2013 defaults to None","title":"Parameters"},{"location":"api/compose/Renamer/#examples","text":">>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Renamer ( prefix = 'prefix_' , suffix = '_suffix' ) . transform_one ( x ) { 'prefix_a_suffix' : 42 , 'prefix_b_suffix' : 12 }","title":"Examples"},{"location":"api/compose/Renamer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Select/","text":"Select \u00b6 Selects features according to a whitelist. This can be used in a pipeline when you want to remove certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input. Parameters \u00b6 whitelist ( Tuple[Hashable] ) Key(s) to keep. Examples \u00b6 >>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Select ( 'c' ) . transform_one ( x ) { 'c' : 13 } You can chain a selector with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Select ( 'sales' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Select"},{"location":"api/compose/Select/#select","text":"Selects features according to a whitelist. This can be used in a pipeline when you want to remove certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input.","title":"Select"},{"location":"api/compose/Select/#parameters","text":"whitelist ( Tuple[Hashable] ) Key(s) to keep.","title":"Parameters"},{"location":"api/compose/Select/#examples","text":">>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Select ( 'c' ) . transform_one ( x ) { 'c' : 13 } You can chain a selector with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Select ( 'sales' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 }","title":"Examples"},{"location":"api/compose/Select/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/SelectType/","text":"SelectType \u00b6 Selects features based on their type. This is practical when you want to apply different preprocessing steps to different kinds of features. For instance, a common usecase is to apply a preprocessing.StandardScaler to numeric features and a preprocessing.OneHotEncoder to categorical features. Parameters \u00b6 types ( Tuple[type] ) Python types which you want to select. Under the hood, the isinstance method will be used to check if a value is of a given type. Examples \u00b6 >>> import numbers >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> num = compose . SelectType ( numbers . Number ) | preprocessing . StandardScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder () >>> model = ( num + cat ) | linear_model . LogisticRegression () Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"SelectType"},{"location":"api/compose/SelectType/#selecttype","text":"Selects features based on their type. This is practical when you want to apply different preprocessing steps to different kinds of features. For instance, a common usecase is to apply a preprocessing.StandardScaler to numeric features and a preprocessing.OneHotEncoder to categorical features.","title":"SelectType"},{"location":"api/compose/SelectType/#parameters","text":"types ( Tuple[type] ) Python types which you want to select. Under the hood, the isinstance method will be used to check if a value is of a given type.","title":"Parameters"},{"location":"api/compose/SelectType/#examples","text":">>> import numbers >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> num = compose . SelectType ( numbers . Number ) | preprocessing . StandardScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder () >>> model = ( num + cat ) | linear_model . LogisticRegression ()","title":"Examples"},{"location":"api/compose/SelectType/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/TransformerUnion/","text":"TransformerUnion \u00b6 Packs multiple transformers into a single one. Pipelines allow you to apply steps sequentially. Therefore, the output of a step becomes the input of the next one. In many cases, you may want to pass the output of a step to multiple steps. This simple transformer allows you to do so. In other words, it enables you to apply particular steps to different parts of an input. A typical example is when you want to scale numeric features and one-hot encode categorical features. This transformer is essentially a list of transformers. Whenever it is updated, it loops through each transformer and updates them. Meanwhile, calling transform_one collects the output of each transformer and merges them into a single dictionary. Parameters \u00b6 transformers Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided. Examples \u00b6 Take the following dataset: >>> X = [ ... { 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'place' : 'Taco Bell' , 'revenue' : 50 } ... ] As an example, let's assume we want to compute two aggregates of a dataset. We therefore define two feature_extraction.Agg s and initialize a TransformerUnion with them: >>> from river import compose >>> from river import feature_extraction >>> from river import stats >>> mean = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Mean () ... ) >>> count = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Count () ... ) >>> agg = compose . TransformerUnion ( mean , count ) We can now update each transformer and obtain their output with a single function call: >>> from pprint import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint ( agg . transform_one ( x )) { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 42.0 } { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 16.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 50.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 50.0 } Note that you can use the + operator as a shorthand notation: agg = mean + count This allows you to build complex pipelines in a very terse manner. For instance, we can create a pipeline that scales each feature and fits a logistic regression as so: >>> from river import linear_model as lm >>> from river import preprocessing as pp >>> model = ( ... ( mean + count ) | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) Whice is equivalent to the following code: >>> model = compose . Pipeline ( ... compose . TransformerUnion ( mean , count ), ... pp . StandardScaler (), ... lm . LogisticRegression () ... ) Note that you access any part of a TransformerUnion by name: >>> model [ 'TransformerUnion' ][ 'Agg' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Mean () ) >>> model [ 'TransformerUnion' ][ 'Agg1' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Count () ) You can also manually provide a name for each step: >>> agg = compose . TransformerUnion ( ... ( 'Mean revenue by place' , mean ), ... ( '# by place' , count ) ... ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update each transformer. Parameters x ( dict ) y \u2013 defaults to None transform_one Passes the data through each transformer and packs the results together. Parameters x ( dict )","title":"TransformerUnion"},{"location":"api/compose/TransformerUnion/#transformerunion","text":"Packs multiple transformers into a single one. Pipelines allow you to apply steps sequentially. Therefore, the output of a step becomes the input of the next one. In many cases, you may want to pass the output of a step to multiple steps. This simple transformer allows you to do so. In other words, it enables you to apply particular steps to different parts of an input. A typical example is when you want to scale numeric features and one-hot encode categorical features. This transformer is essentially a list of transformers. Whenever it is updated, it loops through each transformer and updates them. Meanwhile, calling transform_one collects the output of each transformer and merges them into a single dictionary.","title":"TransformerUnion"},{"location":"api/compose/TransformerUnion/#parameters","text":"transformers Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.","title":"Parameters"},{"location":"api/compose/TransformerUnion/#examples","text":"Take the following dataset: >>> X = [ ... { 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'place' : 'Taco Bell' , 'revenue' : 50 } ... ] As an example, let's assume we want to compute two aggregates of a dataset. We therefore define two feature_extraction.Agg s and initialize a TransformerUnion with them: >>> from river import compose >>> from river import feature_extraction >>> from river import stats >>> mean = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Mean () ... ) >>> count = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Count () ... ) >>> agg = compose . TransformerUnion ( mean , count ) We can now update each transformer and obtain their output with a single function call: >>> from pprint import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint ( agg . transform_one ( x )) { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 42.0 } { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 16.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 50.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 50.0 } Note that you can use the + operator as a shorthand notation: agg = mean + count This allows you to build complex pipelines in a very terse manner. For instance, we can create a pipeline that scales each feature and fits a logistic regression as so: >>> from river import linear_model as lm >>> from river import preprocessing as pp >>> model = ( ... ( mean + count ) | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) Whice is equivalent to the following code: >>> model = compose . Pipeline ( ... compose . TransformerUnion ( mean , count ), ... pp . StandardScaler (), ... lm . LogisticRegression () ... ) Note that you access any part of a TransformerUnion by name: >>> model [ 'TransformerUnion' ][ 'Agg' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Mean () ) >>> model [ 'TransformerUnion' ][ 'Agg1' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Count () ) You can also manually provide a name for each step: >>> agg = compose . TransformerUnion ( ... ( 'Mean revenue by place' , mean ), ... ( '# by place' , count ) ... )","title":"Examples"},{"location":"api/compose/TransformerUnion/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update each transformer. Parameters x ( dict ) y \u2013 defaults to None transform_one Passes the data through each transformer and packs the results together. Parameters x ( dict )","title":"Methods"},{"location":"api/datasets/AirlinePassengers/","text":"AirlinePassengers \u00b6 Monthly number of international airline passengers. The stream contains 144 items and only one single feature, which is the month. The goal is to predict the number of passengers each month by capturing the trend and the seasonality of the data. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 International airline passengers: monthly totals in thousands. Jan 49 \u2013 Dec 60 \u21a9","title":"AirlinePassengers"},{"location":"api/datasets/AirlinePassengers/#airlinepassengers","text":"Monthly number of international airline passengers. The stream contains 144 items and only one single feature, which is the month. The goal is to predict the number of passengers each month by capturing the trend and the seasonality of the data.","title":"AirlinePassengers"},{"location":"api/datasets/AirlinePassengers/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/AirlinePassengers/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/AirlinePassengers/#references","text":"International airline passengers: monthly totals in thousands. Jan 49 \u2013 Dec 60 \u21a9","title":"References"},{"location":"api/datasets/Bananas/","text":"Bananas \u00b6 Bananas dataset. An artificial dataset where instances belongs to several clusters with a banana shape. There are two attributes that correspond to the x and y axis, respectively. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 OpenML page \u21a9","title":"Bananas"},{"location":"api/datasets/Bananas/#bananas","text":"Bananas dataset. An artificial dataset where instances belongs to several clusters with a banana shape. There are two attributes that correspond to the x and y axis, respectively.","title":"Bananas"},{"location":"api/datasets/Bananas/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/Bananas/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Bananas/#references","text":"OpenML page \u21a9","title":"References"},{"location":"api/datasets/Bikes/","text":"Bikes \u00b6 Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 A short introduction and conclusion to the OpenBikes 2016 Challenge \u21a9","title":"Bikes"},{"location":"api/datasets/Bikes/#bikes","text":"Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse.","title":"Bikes"},{"location":"api/datasets/Bikes/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Bikes/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Bikes/#references","text":"A short introduction and conclusion to the OpenBikes 2016 Challenge \u21a9","title":"References"},{"location":"api/datasets/ChickWeights/","text":"ChickWeights \u00b6 Chick weights along time. The stream contains 578 items and 3 features. The goal is to predict the weight of each chick along time, according to the diet the chick is on. The data is ordered by time and then by chick. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Chick weight dataset overview \u21a9","title":"ChickWeights"},{"location":"api/datasets/ChickWeights/#chickweights","text":"Chick weights along time. The stream contains 578 items and 3 features. The goal is to predict the weight of each chick along time, according to the diet the chick is on. The data is ordered by time and then by chick.","title":"ChickWeights"},{"location":"api/datasets/ChickWeights/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/ChickWeights/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/ChickWeights/#references","text":"Chick weight dataset overview \u21a9","title":"References"},{"location":"api/datasets/CreditCard/","text":"CreditCard \u00b6 Credit card frauds. The datasets contains transactions made by credit cards in September 2013 by european cardholders. This dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions. It contains only numerical input variables which are the result of a PCA transformation. Unfortunately, due to confidentiality issues, we cannot provide the original features and more background information about the data. Features V1, V2, ... V28 are the principal components obtained with PCA, the only features which have not been transformed with PCA are 'Time' and 'Amount'. Feature 'Time' contains the seconds elapsed between each transaction and the first transaction in the dataset. The feature 'Amount' is the transaction Amount, this feature can be used for example-dependant cost-senstive learning. Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015 \u21a9 Dal Pozzolo, Andrea; Caelen, Olivier; Le Borgne, Yann-Ael; Waterschoot, Serge; Bontempi, Gianluca. Learned lessons in credit card fraud detection from a practitioner perspective, Expert systems with applications,41,10,4915-4928,2014, Pergamon \u21a9 Dal Pozzolo, Andrea; Boracchi, Giacomo; Caelen, Olivier; Alippi, Cesare; Bontempi, Gianluca. Credit card fraud detection: a realistic modeling and a novel learning strategy, IEEE transactions on neural networks and learning systems,29,8,3784-3797,2018,IEEE \u21a9 Dal Pozzolo, Andrea Adaptive Machine learning for credit card fraud detection ULB MLG PhD thesis (supervised by G. Bontempi) \u21a9 Carcillo, Fabrizio; Dal Pozzolo, Andrea; Le Borgne, Yann-Ael; Caelen, Olivier; Mazzer, Yannis; Bontempi, Gianluca. Scarff: a scalable framework for streaming credit card fraud detection with Spark, Information fusion,41, 182-194,2018,Elsevier \u21a9 Carcillo, Fabrizio; Le Borgne, Yann-Ael; Caelen, Olivier; Bontempi, Gianluca. Streaming active learning strategies for real-life credit card fraud detection: assessment and visualization, International Journal of Data Science and Analytics, 5,4,285-300,2018,Springer International Publishing \u21a9 Bertrand Lebichot, Yann-Ael Le Borgne, Liyun He, Frederic Oble, Gianluca Bontempi Deep-Learning Domain Adaptation Techniques for Credit Cards Fraud Detection, INNSBDDL 2019: Recent Advances in Big Data and Deep Learning, pp 78-88, 2019 \u21a9 Fabrizio Carcillo, Yann-Ael Le Borgne, Olivier Caelen, Frederic Oble, Gianluca Bontempi Combining Unsupervised and Supervised Learning in Credit Card Fraud Detection Information Sciences, 2019 \u21a9","title":"CreditCard"},{"location":"api/datasets/CreditCard/#creditcard","text":"Credit card frauds. The datasets contains transactions made by credit cards in September 2013 by european cardholders. This dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions. It contains only numerical input variables which are the result of a PCA transformation. Unfortunately, due to confidentiality issues, we cannot provide the original features and more background information about the data. Features V1, V2, ... V28 are the principal components obtained with PCA, the only features which have not been transformed with PCA are 'Time' and 'Amount'. Feature 'Time' contains the seconds elapsed between each transaction and the first transaction in the dataset. The feature 'Amount' is the transaction Amount, this feature can be used for example-dependant cost-senstive learning. Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise.","title":"CreditCard"},{"location":"api/datasets/CreditCard/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/CreditCard/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/CreditCard/#references","text":"Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015 \u21a9 Dal Pozzolo, Andrea; Caelen, Olivier; Le Borgne, Yann-Ael; Waterschoot, Serge; Bontempi, Gianluca. Learned lessons in credit card fraud detection from a practitioner perspective, Expert systems with applications,41,10,4915-4928,2014, Pergamon \u21a9 Dal Pozzolo, Andrea; Boracchi, Giacomo; Caelen, Olivier; Alippi, Cesare; Bontempi, Gianluca. Credit card fraud detection: a realistic modeling and a novel learning strategy, IEEE transactions on neural networks and learning systems,29,8,3784-3797,2018,IEEE \u21a9 Dal Pozzolo, Andrea Adaptive Machine learning for credit card fraud detection ULB MLG PhD thesis (supervised by G. Bontempi) \u21a9 Carcillo, Fabrizio; Dal Pozzolo, Andrea; Le Borgne, Yann-Ael; Caelen, Olivier; Mazzer, Yannis; Bontempi, Gianluca. Scarff: a scalable framework for streaming credit card fraud detection with Spark, Information fusion,41, 182-194,2018,Elsevier \u21a9 Carcillo, Fabrizio; Le Borgne, Yann-Ael; Caelen, Olivier; Bontempi, Gianluca. Streaming active learning strategies for real-life credit card fraud detection: assessment and visualization, International Journal of Data Science and Analytics, 5,4,285-300,2018,Springer International Publishing \u21a9 Bertrand Lebichot, Yann-Ael Le Borgne, Liyun He, Frederic Oble, Gianluca Bontempi Deep-Learning Domain Adaptation Techniques for Credit Cards Fraud Detection, INNSBDDL 2019: Recent Advances in Big Data and Deep Learning, pp 78-88, 2019 \u21a9 Fabrizio Carcillo, Yann-Ael Le Borgne, Olivier Caelen, Frederic Oble, Gianluca Bontempi Combining Unsupervised and Supervised Learning in Credit Card Fraud Detection Information Sciences, 2019 \u21a9","title":"References"},{"location":"api/datasets/Elec2/","text":"Elec2 \u00b6 Electricity prices in New South Wales. This is a binary classification task, where the goal is to predict if the price of electricity will go up or down. This data was collected from the Australian New South Wales Electricity Market. In this market, prices are not fixed and are affected by demand and supply of the market. They are set every five minutes. Electricity transfers to/from the neighboring state of Victoria were done to alleviate fluctuations. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 SPLICE-2 Comparative Evaluation: Electricity Pricing \u21a9 DataHub description \u21a9","title":"Elec2"},{"location":"api/datasets/Elec2/#elec2","text":"Electricity prices in New South Wales. This is a binary classification task, where the goal is to predict if the price of electricity will go up or down. This data was collected from the Australian New South Wales Electricity Market. In this market, prices are not fixed and are affected by demand and supply of the market. They are set every five minutes. Electricity transfers to/from the neighboring state of Victoria were done to alleviate fluctuations.","title":"Elec2"},{"location":"api/datasets/Elec2/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Elec2/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Elec2/#references","text":"SPLICE-2 Comparative Evaluation: Electricity Pricing \u21a9 DataHub description \u21a9","title":"References"},{"location":"api/datasets/HTTP/","text":"HTTP \u00b6 HTTP dataset of the KDD 1999 cup. The goal is to predict whether or not an HTTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 HTTP (KDDCUP99) dataset \u21a9","title":"HTTP"},{"location":"api/datasets/HTTP/#http","text":"HTTP dataset of the KDD 1999 cup. The goal is to predict whether or not an HTTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.","title":"HTTP"},{"location":"api/datasets/HTTP/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/HTTP/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/HTTP/#references","text":"HTTP (KDDCUP99) dataset \u21a9","title":"References"},{"location":"api/datasets/Higgs/","text":"Higgs \u00b6 Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"Higgs"},{"location":"api/datasets/Higgs/#higgs","text":"Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes.","title":"Higgs"},{"location":"api/datasets/Higgs/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Higgs/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Higgs/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/ImageSegments/","text":"ImageSegments \u00b6 Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"ImageSegments"},{"location":"api/datasets/ImageSegments/#imagesegments","text":"Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass.","title":"ImageSegments"},{"location":"api/datasets/ImageSegments/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/ImageSegments/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/ImageSegments/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/Insects/","text":"Insects \u00b6 Insects dataset. This dataset has different variants, which are: abrupt_balanced - abrupt_imbalanced - gradual_balanced - gradual_imbalanced - incremental-abrupt_balanced - incremental-abrupt_imbalanced - incremental-reoccurring_balanced - incremental-reoccurring_imbalanced - incremental_balanced - incremental_imbalanced - out-of-control The number of samples and the difficulty change from one variant to another. The number of classes is always the same (6), except for the last variant (24). Parameters \u00b6 variant \u2013 defaults to abrupt_balanced Indicates which variant of the dataset to load. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 USP DS repository \u21a9 Souza, V., Reis, D.M.D., Maletzke, A.G. and Batista, G.E., 2020. Challenges in Benchmarking Stream Learning Algorithms with Real-world Data. arXiv preprint arXiv:2005.00113. \u21a9","title":"Insects"},{"location":"api/datasets/Insects/#insects","text":"Insects dataset. This dataset has different variants, which are: abrupt_balanced - abrupt_imbalanced - gradual_balanced - gradual_imbalanced - incremental-abrupt_balanced - incremental-abrupt_imbalanced - incremental-reoccurring_balanced - incremental-reoccurring_imbalanced - incremental_balanced - incremental_imbalanced - out-of-control The number of samples and the difficulty change from one variant to another. The number of classes is always the same (6), except for the last variant (24).","title":"Insects"},{"location":"api/datasets/Insects/#parameters","text":"variant \u2013 defaults to abrupt_balanced Indicates which variant of the dataset to load.","title":"Parameters"},{"location":"api/datasets/Insects/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Insects/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Insects/#references","text":"USP DS repository \u21a9 Souza, V., Reis, D.M.D., Maletzke, A.G. and Batista, G.E., 2020. Challenges in Benchmarking Stream Learning Algorithms with Real-world Data. arXiv preprint arXiv:2005.00113. \u21a9","title":"References"},{"location":"api/datasets/MaliciousURL/","text":"MaliciousURL \u00b6 Malicious URLs dataset. This dataset contains features about URLs that are classified as malicious or not. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Detecting Malicious URLs \u21a9 Identifying Suspicious URLs: An Application of Large-Scale Online Learning \u21a9","title":"MaliciousURL"},{"location":"api/datasets/MaliciousURL/#maliciousurl","text":"Malicious URLs dataset. This dataset contains features about URLs that are classified as malicious or not.","title":"MaliciousURL"},{"location":"api/datasets/MaliciousURL/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/MaliciousURL/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/MaliciousURL/#references","text":"Detecting Malicious URLs \u21a9 Identifying Suspicious URLs: An Application of Large-Scale Online Learning \u21a9","title":"References"},{"location":"api/datasets/MovieLens100K/","text":"MovieLens100K \u00b6 MovieLens 100K dataset. MovieLens datasets were collected by the GroupLens Research Project at the University of Minnesota. This dataset consists of 100,000 ratings (1-5) from 943 users on 1682 movies. Each user has rated at least 20 movies. User and movie information are provided. The data was collected through the MovieLens web site (movielens.umn.edu) during the seven-month period from September 19th, 1997 through April 22nd, 1998. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 The MovieLens Datasets: History and Context \u21a9","title":"MovieLens100K"},{"location":"api/datasets/MovieLens100K/#movielens100k","text":"MovieLens 100K dataset. MovieLens datasets were collected by the GroupLens Research Project at the University of Minnesota. This dataset consists of 100,000 ratings (1-5) from 943 users on 1682 movies. Each user has rated at least 20 movies. User and movie information are provided. The data was collected through the MovieLens web site (movielens.umn.edu) during the seven-month period from September 19th, 1997 through April 22nd, 1998.","title":"MovieLens100K"},{"location":"api/datasets/MovieLens100K/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/MovieLens100K/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/MovieLens100K/#references","text":"The MovieLens Datasets: History and Context \u21a9","title":"References"},{"location":"api/datasets/Music/","text":"Music \u00b6 Bike sharing station information from the city of Toulouse. The goal is to predict to which kinds of moods a song pertains to. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Read, J., Reutemann, P., Pfahringer, B. and Holmes, G., 2016. MEKA: a multi-label/multi-target extension to WEKA. The Journal of Machine Learning Research, 17(1), pp.667-671. \u21a9","title":"Music"},{"location":"api/datasets/Music/#music","text":"Bike sharing station information from the city of Toulouse. The goal is to predict to which kinds of moods a song pertains to.","title":"Music"},{"location":"api/datasets/Music/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Music/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Music/#references","text":"Read, J., Reutemann, P., Pfahringer, B. and Holmes, G., 2016. MEKA: a multi-label/multi-target extension to WEKA. The Journal of Machine Learning Research, 17(1), pp.667-671. \u21a9","title":"References"},{"location":"api/datasets/Phishing/","text":"Phishing \u00b6 Phishing websites. This dataset contains features from web pages that are classified as phishing or not. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"Phishing"},{"location":"api/datasets/Phishing/#phishing","text":"Phishing websites. This dataset contains features from web pages that are classified as phishing or not.","title":"Phishing"},{"location":"api/datasets/Phishing/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/Phishing/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Phishing/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/Restaurants/","text":"Restaurants \u00b6 Data from the Kaggle Recruit Restaurants challenge. The goal is to predict the number of visitors in each of 829 Japanese restaurants over a priod of roughly 16 weeks. The data is ordered by date and then by restaurant ID. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Recruit Restaurant Visitor Forecasting \u21a9","title":"Restaurants"},{"location":"api/datasets/Restaurants/#restaurants","text":"Data from the Kaggle Recruit Restaurants challenge. The goal is to predict the number of visitors in each of 829 Japanese restaurants over a priod of roughly 16 weeks. The data is ordered by date and then by restaurant ID.","title":"Restaurants"},{"location":"api/datasets/Restaurants/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Restaurants/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Restaurants/#references","text":"Recruit Restaurant Visitor Forecasting \u21a9","title":"References"},{"location":"api/datasets/SMSSpam/","text":"SMSSpam \u00b6 SMS Spam Collection dataset. The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Almeida, T.A., Hidalgo, J.M.G. and Yamakami, A., 2011, September. Contributions to the study of SMS spam filtering: new collection and results. In Proceedings of the 11th ACM symposium on Document engineering (pp. 259-262). \u21a9","title":"SMSSpam"},{"location":"api/datasets/SMSSpam/#smsspam","text":"SMS Spam Collection dataset. The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not.","title":"SMSSpam"},{"location":"api/datasets/SMSSpam/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/SMSSpam/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/SMSSpam/#references","text":"Almeida, T.A., Hidalgo, J.M.G. and Yamakami, A., 2011, September. Contributions to the study of SMS spam filtering: new collection and results. In Proceedings of the 11th ACM symposium on Document engineering (pp. 259-262). \u21a9","title":"References"},{"location":"api/datasets/SMTP/","text":"SMTP \u00b6 SMTP dataset from the KDD 1999 cup. The goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 SMTP (KDDCUP99) dataset \u21a9","title":"SMTP"},{"location":"api/datasets/SMTP/#smtp","text":"SMTP dataset from the KDD 1999 cup. The goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.","title":"SMTP"},{"location":"api/datasets/SMTP/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/SMTP/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/SMTP/#references","text":"SMTP (KDDCUP99) dataset \u21a9","title":"References"},{"location":"api/datasets/SolarFlare/","text":"SolarFlare \u00b6 Solar flare multi-output regression. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"SolarFlare"},{"location":"api/datasets/SolarFlare/#solarflare","text":"Solar flare multi-output regression.","title":"SolarFlare"},{"location":"api/datasets/SolarFlare/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/SolarFlare/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/SolarFlare/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/TREC07/","text":"TREC07 \u00b6 TREC's 2007 Spam Track dataset. The data contains 75,419 chronologically ordered items, i.e. 3 months of emails delivered to a particular server in 2007. Spam messages represent 66.6% of the dataset. The goal is to predict whether an email is a spam or not. The available raw features are: sender, recipients, date, subject, body. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 TREC 2007 Spam Track Overview \u21a9 Code ran to parse the dataset \u21a9","title":"TREC07"},{"location":"api/datasets/TREC07/#trec07","text":"TREC's 2007 Spam Track dataset. The data contains 75,419 chronologically ordered items, i.e. 3 months of emails delivered to a particular server in 2007. Spam messages represent 66.6% of the dataset. The goal is to predict whether an email is a spam or not. The available raw features are: sender, recipients, date, subject, body.","title":"TREC07"},{"location":"api/datasets/TREC07/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/TREC07/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/TREC07/#references","text":"TREC 2007 Spam Track Overview \u21a9 Code ran to parse the dataset \u21a9","title":"References"},{"location":"api/datasets/Taxis/","text":"Taxis \u00b6 Taxi ride durations in New York City. The goal is to predict the duration of taxi rides in New York City. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 New York City Taxi Trip Duration competition on Kaggle \u21a9","title":"Taxis"},{"location":"api/datasets/Taxis/#taxis","text":"Taxi ride durations in New York City. The goal is to predict the duration of taxi rides in New York City.","title":"Taxis"},{"location":"api/datasets/Taxis/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Taxis/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Taxis/#references","text":"New York City Taxi Trip Duration competition on Kaggle \u21a9","title":"References"},{"location":"api/datasets/TrumpApproval/","text":"TrumpApproval \u00b6 Donald Trump approval ratings. This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Trump Approval Ratings \u21a9","title":"TrumpApproval"},{"location":"api/datasets/TrumpApproval/#trumpapproval","text":"Donald Trump approval ratings. This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model.","title":"TrumpApproval"},{"location":"api/datasets/TrumpApproval/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/TrumpApproval/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/TrumpApproval/#references","text":"Trump Approval Ratings \u21a9","title":"References"},{"location":"api/drift/ADWIN/","text":"ADWIN \u00b6 Adaptive Windowing method for concept drift detection. ADWIN (ADaptive WINdowing) is a popular drift detection method with mathematical guarantees. ADWIN efficiently keeps a variable-length window of recent items; such that it holds that there has no been change in the data distribution. This window is further divided into two sub-windows \\((W_0, W_1)\\) used to determine if a change has happened. ADWIN compares the average of \\(W_0\\) and \\(W_1\\) to confirm that they correspond to the same distribution. Concept drift is detected if the distribution equality no longer holds. Upon detecting a drift, \\(W_0\\) is replaced by \\(W_1\\) and a new \\(W_1\\) is initialized. ADWIN uses a confidence value \\(\\delta=\\in(0,1)\\) to determine if the two sub-windows correspond to the same distribution. Input : value can be any numeric value related to the definition of concept change for the data analyzed. For example, using 0's or 1's to track drift in a classifier's performance as follows: 0: Means the learners prediction was wrong 1: Means the learners prediction was correct Parameters \u00b6 delta \u2013 defaults to 0.002 Confidence value. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. estimation Error estimation n_detections variance warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. width Window size Examples \u00b6 >>> import numpy as np >>> from river.drift import ADWIN >>> np . random . seed ( 12345 ) >>> adwin = ADWIN () >>> # Simulate a data stream composed by two data distributions >>> data_stream = np . concatenate (( np . random . randint ( 2 , size = 1000 ), ... np . random . randint ( 4 , high = 8 , size = 1000 ))) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = adwin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1023 , input value : 5 Change detected at index 1055 , input value : 7 Change detected at index 1087 , input value : 5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Apart from adding the element value to the window, by inserting it in the correct bucket, it will also update the relevant statistics, in this case the total sum of all values, the window width and the total variance. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple References \u00b6 Bifet, Albert, and Ricard Gavalda. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"ADWIN"},{"location":"api/drift/ADWIN/#adwin","text":"Adaptive Windowing method for concept drift detection. ADWIN (ADaptive WINdowing) is a popular drift detection method with mathematical guarantees. ADWIN efficiently keeps a variable-length window of recent items; such that it holds that there has no been change in the data distribution. This window is further divided into two sub-windows \\((W_0, W_1)\\) used to determine if a change has happened. ADWIN compares the average of \\(W_0\\) and \\(W_1\\) to confirm that they correspond to the same distribution. Concept drift is detected if the distribution equality no longer holds. Upon detecting a drift, \\(W_0\\) is replaced by \\(W_1\\) and a new \\(W_1\\) is initialized. ADWIN uses a confidence value \\(\\delta=\\in(0,1)\\) to determine if the two sub-windows correspond to the same distribution. Input : value can be any numeric value related to the definition of concept change for the data analyzed. For example, using 0's or 1's to track drift in a classifier's performance as follows: 0: Means the learners prediction was wrong 1: Means the learners prediction was correct","title":"ADWIN"},{"location":"api/drift/ADWIN/#parameters","text":"delta \u2013 defaults to 0.002 Confidence value.","title":"Parameters"},{"location":"api/drift/ADWIN/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. estimation Error estimation n_detections variance warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. width Window size","title":"Attributes"},{"location":"api/drift/ADWIN/#examples","text":">>> import numpy as np >>> from river.drift import ADWIN >>> np . random . seed ( 12345 ) >>> adwin = ADWIN () >>> # Simulate a data stream composed by two data distributions >>> data_stream = np . concatenate (( np . random . randint ( 2 , size = 1000 ), ... np . random . randint ( 4 , high = 8 , size = 1000 ))) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = adwin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1023 , input value : 5 Change detected at index 1055 , input value : 7 Change detected at index 1087 , input value : 5","title":"Examples"},{"location":"api/drift/ADWIN/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Apart from adding the element value to the window, by inserting it in the correct bucket, it will also update the relevant statistics, in this case the total sum of all values, the window width and the total variance. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple","title":"Methods"},{"location":"api/drift/ADWIN/#references","text":"Bifet, Albert, and Ricard Gavalda. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"References"},{"location":"api/drift/DDM/","text":"DDM \u00b6 Drift Detection Method. DDM (Drift Detection Method) is a concept change detection method based on the PAC learning model premise, that the learner's error rate will decrease as the number of analysed samples increase, as long as the data distribution is stationary. If the algorithm detects an increase in the error rate, that surpasses a calculated threshold, either change is detected or the algorithm will warn the user that change may occur in the near future, which is called the warning zone. The detection threshold is calculated in function of two statistics, obtained when \\((p_i + s_i)\\) is minimum: \\(p_{min}\\) : The minimum recorded error rate. \\(s_{min}\\) : The minimum recorded standard deviation. At instant \\(i\\) , the detection algorithm uses: \\(p_i\\) : The error rate at instant \\(i\\) . \\(s_i\\) : The standard deviation at instant \\(i\\) . The conditions for entering the warning zone and detecting change are as follows: if \\(p_i + s_i \\geq p_{min} + 2 * s_{min}\\) -> Warning zone if \\(p_i + s_i \\geq p_{min} + 3 * s_{min}\\) -> Change detected Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Parameters \u00b6 min_num_instances \u2013 defaults to 30 The minimum required number of analyzed samples so change can be detected. This is used to avoid false detections during the early moments of the detector, when the weight of one sample is important. warning_level \u2013 defaults to 2.0 Warning level. out_control_level \u2013 defaults to 3.0 Out-control level. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import numpy as np >>> from river.drift import DDM >>> np . random . seed ( 12345 ) >>> ddm = DDM () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = ddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1077 , input value : 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) References \u00b6 Jo\u00e3o Gama, Pedro Medas, Gladys Castillo, Pedro Pereira Rodrigues: Learning with Drift Detection. SBIA 2004: 286-295 \u21a9","title":"DDM"},{"location":"api/drift/DDM/#ddm","text":"Drift Detection Method. DDM (Drift Detection Method) is a concept change detection method based on the PAC learning model premise, that the learner's error rate will decrease as the number of analysed samples increase, as long as the data distribution is stationary. If the algorithm detects an increase in the error rate, that surpasses a calculated threshold, either change is detected or the algorithm will warn the user that change may occur in the near future, which is called the warning zone. The detection threshold is calculated in function of two statistics, obtained when \\((p_i + s_i)\\) is minimum: \\(p_{min}\\) : The minimum recorded error rate. \\(s_{min}\\) : The minimum recorded standard deviation. At instant \\(i\\) , the detection algorithm uses: \\(p_i\\) : The error rate at instant \\(i\\) . \\(s_i\\) : The standard deviation at instant \\(i\\) . The conditions for entering the warning zone and detecting change are as follows: if \\(p_i + s_i \\geq p_{min} + 2 * s_{min}\\) -> Warning zone if \\(p_i + s_i \\geq p_{min} + 3 * s_{min}\\) -> Change detected Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\)","title":"DDM"},{"location":"api/drift/DDM/#parameters","text":"min_num_instances \u2013 defaults to 30 The minimum required number of analyzed samples so change can be detected. This is used to avoid false detections during the early moments of the detector, when the weight of one sample is important. warning_level \u2013 defaults to 2.0 Warning level. out_control_level \u2013 defaults to 3.0 Out-control level.","title":"Parameters"},{"location":"api/drift/DDM/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/DDM/#examples","text":">>> import numpy as np >>> from river.drift import DDM >>> np . random . seed ( 12345 ) >>> ddm = DDM () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = ddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1077 , input value : 1","title":"Examples"},{"location":"api/drift/DDM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number )","title":"Methods"},{"location":"api/drift/DDM/#references","text":"Jo\u00e3o Gama, Pedro Medas, Gladys Castillo, Pedro Pereira Rodrigues: Learning with Drift Detection. SBIA 2004: 286-295 \u21a9","title":"References"},{"location":"api/drift/EDDM/","text":"EDDM \u00b6 Early Drift Detection Method. EDDM (Early Drift Detection Method) aims to improve the detection rate of gradual concept drift in DDM, while keeping a good performance against abrupt concept drift. This method works by keeping track of the average distance between two errors instead of only the error rate. For this, it is necessary to keep track of the running average distance and the running standard deviation, as well as the maximum distance and the maximum standard deviation. The algorithm works similarly to the DDM algorithm, by keeping track of statistics only. It works with the running average distance ( \\(p_i'\\) ) and the running standard deviation ( \\(s_i'\\) ), as well as \\(p'_{max}\\) and \\(s'_{max}\\) , which are the values of \\(p_i'\\) and \\(s_i'\\) when \\((p_i' + 2 * s_i')\\) reaches its maximum. Like DDM, there are two threshold values that define the borderline between no change, warning zone, and drift detected. These are as follows: if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\alpha\\) -> Warning zone if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\beta\\) -> Change detected \\(\\alpha\\) and \\(\\beta\\) are set to 0.95 and 0.9, respectively. Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import numpy as np >>> from river.drift import EDDM >>> np . random . seed ( 12345 ) >>> eddm = EDDM () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = eddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 53 , input value : 1 Change detected at index 121 , input value : 1 Change detected at index 185 , input value : 1 Change detected at index 272 , input value : 1 Change detected at index 336 , input value : 1 Change detected at index 391 , input value : 1 Change detected at index 571 , input value : 1 Change detected at index 627 , input value : 1 Change detected at index 686 , input value : 1 Change detected at index 754 , input value : 1 Change detected at index 1033 , input value : 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. References \u00b6 Early Drift Detection Method. Manuel Baena-Garcia, Jose Del Campo-Avila, Ra\u00fal Fidalgo, Albert Bifet, Ricard Gavalda, Rafael Morales-Bueno. In Fourth International Workshop on Knowledge Discovery from Data Streams, 2006. \u21a9","title":"EDDM"},{"location":"api/drift/EDDM/#eddm","text":"Early Drift Detection Method. EDDM (Early Drift Detection Method) aims to improve the detection rate of gradual concept drift in DDM, while keeping a good performance against abrupt concept drift. This method works by keeping track of the average distance between two errors instead of only the error rate. For this, it is necessary to keep track of the running average distance and the running standard deviation, as well as the maximum distance and the maximum standard deviation. The algorithm works similarly to the DDM algorithm, by keeping track of statistics only. It works with the running average distance ( \\(p_i'\\) ) and the running standard deviation ( \\(s_i'\\) ), as well as \\(p'_{max}\\) and \\(s'_{max}\\) , which are the values of \\(p_i'\\) and \\(s_i'\\) when \\((p_i' + 2 * s_i')\\) reaches its maximum. Like DDM, there are two threshold values that define the borderline between no change, warning zone, and drift detected. These are as follows: if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\alpha\\) -> Warning zone if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\beta\\) -> Change detected \\(\\alpha\\) and \\(\\beta\\) are set to 0.95 and 0.9, respectively. Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\)","title":"EDDM"},{"location":"api/drift/EDDM/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/EDDM/#examples","text":">>> import numpy as np >>> from river.drift import EDDM >>> np . random . seed ( 12345 ) >>> eddm = EDDM () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = eddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 53 , input value : 1 Change detected at index 121 , input value : 1 Change detected at index 185 , input value : 1 Change detected at index 272 , input value : 1 Change detected at index 336 , input value : 1 Change detected at index 391 , input value : 1 Change detected at index 571 , input value : 1 Change detected at index 627 , input value : 1 Change detected at index 686 , input value : 1 Change detected at index 754 , input value : 1 Change detected at index 1033 , input value : 1","title":"Examples"},{"location":"api/drift/EDDM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/EDDM/#references","text":"Early Drift Detection Method. Manuel Baena-Garcia, Jose Del Campo-Avila, Ra\u00fal Fidalgo, Albert Bifet, Ricard Gavalda, Rafael Morales-Bueno. In Fourth International Workshop on Knowledge Discovery from Data Streams, 2006. \u21a9","title":"References"},{"location":"api/drift/HDDM-A/","text":"HDDM_A \u00b6 Drift Detection Method based on Hoeffding\u2019s bounds with moving average-test. HDDM_A is a drift detection method based on the Hoeffding\u2019s inequality. HDDM_A uses the average as estimator. It receives as input a stream of real values and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA. Parameters \u00b6 drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning two_sided_test \u2013 defaults to False If True , will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided). Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import numpy as np >>> from river.drift import HDDM_A >>> np . random . seed ( 12345 ) >>> hddm_a = HDDM_A () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_a . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1013 , input value : 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. References \u00b6 Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"HDDM_A"},{"location":"api/drift/HDDM-A/#hddm_a","text":"Drift Detection Method based on Hoeffding\u2019s bounds with moving average-test. HDDM_A is a drift detection method based on the Hoeffding\u2019s inequality. HDDM_A uses the average as estimator. It receives as input a stream of real values and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA.","title":"HDDM_A"},{"location":"api/drift/HDDM-A/#parameters","text":"drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning two_sided_test \u2013 defaults to False If True , will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).","title":"Parameters"},{"location":"api/drift/HDDM-A/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/HDDM-A/#examples","text":">>> import numpy as np >>> from river.drift import HDDM_A >>> np . random . seed ( 12345 ) >>> hddm_a = HDDM_A () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_a . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1013 , input value : 1","title":"Examples"},{"location":"api/drift/HDDM-A/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/HDDM-A/#references","text":"Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"References"},{"location":"api/drift/HDDM-W/","text":"HDDM_W \u00b6 Drift Detection Method based on Hoeffding\u2019s bounds with moving weighted average-test. HDDM_W is an online drift detection method based on McDiarmid's bounds. HDDM_W uses the Exponentially Weighted Moving Average (EWMA) statistic as estimator. It receives as input a stream of real predictions and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA. Parameters \u00b6 drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning lambda_option \u2013 defaults to 0.05 The weight given to recent data. Smaller values mean less weight given to recent data. two_sided_test \u2013 defaults to False If True, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided). Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import numpy as np >>> from river.drift import HDDM_W >>> np . random . seed ( 12345 ) >>> hddm_w = HDDM_W () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_w . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1011 , input value : 1 Methods \u00b6 SampleInfo clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple References \u00b6 Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"HDDM_W"},{"location":"api/drift/HDDM-W/#hddm_w","text":"Drift Detection Method based on Hoeffding\u2019s bounds with moving weighted average-test. HDDM_W is an online drift detection method based on McDiarmid's bounds. HDDM_W uses the Exponentially Weighted Moving Average (EWMA) statistic as estimator. It receives as input a stream of real predictions and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 0 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA.","title":"HDDM_W"},{"location":"api/drift/HDDM-W/#parameters","text":"drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning lambda_option \u2013 defaults to 0.05 The weight given to recent data. Smaller values mean less weight given to recent data. two_sided_test \u2013 defaults to False If True, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).","title":"Parameters"},{"location":"api/drift/HDDM-W/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/HDDM-W/#examples","text":">>> import numpy as np >>> from river.drift import HDDM_W >>> np . random . seed ( 12345 ) >>> hddm_w = HDDM_W () >>> # Simulate a data stream as a normal distribution of 1's and 0's >>> data_stream = np . random . randint ( 2 , size = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = 1 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_w . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1011 , input value : 1","title":"Examples"},{"location":"api/drift/HDDM-W/#methods","text":"SampleInfo clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple","title":"Methods"},{"location":"api/drift/HDDM-W/#references","text":"Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"References"},{"location":"api/drift/KSWIN/","text":"KSWIN \u00b6 Kolmogorov-Smirnov Windowing method for concept drift detection. Parameters \u00b6 alpha \u2013 defaults to 0.005 Probability for the test statistic of the Kolmogorov-Smirnov-Test. The alpha parameter is very sensitive, therefore should be set below 0.01. window_size \u2013 defaults to 100 Size of the sliding window. stat_size \u2013 defaults to 30 Size of the statistic window. window \u2013 defaults to None Already collected data to avoid cold start. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import numpy as np >>> from river.drift import KSWIN >>> np . random . seed ( 12345 ) >>> kswin = KSWIN () >>> # Simulate a data stream composed by two data distributions >>> data_stream = np . concatenate (( np . random . randint ( 2 , size = 1000 ), ... np . random . randint ( 4 , high = 8 , size = 1000 ))) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = kswin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1014 , input value : 5 Change detected at index 1828 , input value : 6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Adds an element on top of the sliding window and removes the oldest one from the window. Afterwards, the KS-test is performed. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. Notes \u00b6 KSWIN (Kolmogorov-Smirnov Windowing) is a concept change detection method based on the Kolmogorov-Smirnov (KS) statistical test. KS-test is a statistical test with no assumption of underlying data distribution. KSWIN can monitor data or performance distributions. Note that the detector accepts one dimensional input as array. KSWIN maintains a sliding window \\(\\Psi\\) of fixed size \\(n\\) (window_size). The last \\(r\\) (stat_size) samples of \\(\\Psi\\) are assumed to represent the last concept considered as \\(R\\) . From the first \\(n-r\\) samples of \\(\\Psi\\) , \\(r\\) samples are uniformly drawn, representing an approximated last concept \\(W\\) . The KS-test is performed on the windows \\(R\\) and \\(W\\) of the same size. KS -test compares the distance of the empirical cumulative data distribution \\(dist(R,W)\\) . A concept drift is detected by KSWIN if: \\[ dist(R,W) > \\sqrt{-\\frac{ln\\alpha}{r}} \\] The difference in empirical data distributions between the windows \\(R\\) and \\(W\\) is too large since \\(R\\) and \\(W\\) come from the same distribution. References \u00b6 Christoph Raab, Moritz Heusinger, Frank-Michael Schleif, Reactive Soft Prototype Computing for Concept Drift Streams, Neurocomputing, 2020, \u21a9","title":"KSWIN"},{"location":"api/drift/KSWIN/#kswin","text":"Kolmogorov-Smirnov Windowing method for concept drift detection.","title":"KSWIN"},{"location":"api/drift/KSWIN/#parameters","text":"alpha \u2013 defaults to 0.005 Probability for the test statistic of the Kolmogorov-Smirnov-Test. The alpha parameter is very sensitive, therefore should be set below 0.01. window_size \u2013 defaults to 100 Size of the sliding window. stat_size \u2013 defaults to 30 Size of the statistic window. window \u2013 defaults to None Already collected data to avoid cold start.","title":"Parameters"},{"location":"api/drift/KSWIN/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/KSWIN/#examples","text":">>> import numpy as np >>> from river.drift import KSWIN >>> np . random . seed ( 12345 ) >>> kswin = KSWIN () >>> # Simulate a data stream composed by two data distributions >>> data_stream = np . concatenate (( np . random . randint ( 2 , size = 1000 ), ... np . random . randint ( 4 , high = 8 , size = 1000 ))) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = kswin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1014 , input value : 5 Change detected at index 1828 , input value : 6","title":"Examples"},{"location":"api/drift/KSWIN/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Adds an element on top of the sliding window and removes the oldest one from the window. Afterwards, the KS-test is performed. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/KSWIN/#notes","text":"KSWIN (Kolmogorov-Smirnov Windowing) is a concept change detection method based on the Kolmogorov-Smirnov (KS) statistical test. KS-test is a statistical test with no assumption of underlying data distribution. KSWIN can monitor data or performance distributions. Note that the detector accepts one dimensional input as array. KSWIN maintains a sliding window \\(\\Psi\\) of fixed size \\(n\\) (window_size). The last \\(r\\) (stat_size) samples of \\(\\Psi\\) are assumed to represent the last concept considered as \\(R\\) . From the first \\(n-r\\) samples of \\(\\Psi\\) , \\(r\\) samples are uniformly drawn, representing an approximated last concept \\(W\\) . The KS-test is performed on the windows \\(R\\) and \\(W\\) of the same size. KS -test compares the distance of the empirical cumulative data distribution \\(dist(R,W)\\) . A concept drift is detected by KSWIN if: \\[ dist(R,W) > \\sqrt{-\\frac{ln\\alpha}{r}} \\] The difference in empirical data distributions between the windows \\(R\\) and \\(W\\) is too large since \\(R\\) and \\(W\\) come from the same distribution.","title":"Notes"},{"location":"api/drift/KSWIN/#references","text":"Christoph Raab, Moritz Heusinger, Frank-Michael Schleif, Reactive Soft Prototype Computing for Concept Drift Streams, Neurocomputing, 2020, \u21a9","title":"References"},{"location":"api/drift/PageHinkley/","text":"PageHinkley \u00b6 Page-Hinkley method for concept drift detection. This change detection method works by computing the observed values and their mean up to the current moment. Page-Hinkley does not signal warning zones, only change detections. The method works by means of the Page-Hinkley test. In general lines it will detect a concept drift if the observed mean at some instant is greater then a threshold value lambda. Parameters \u00b6 min_instances \u2013 defaults to 30 The minimum number of instances before detecting change. delta \u2013 defaults to 0.005 The delta factor for the Page Hinkley test. threshold \u2013 defaults to 50 The change detection threshold (lambda). alpha \u2013 defaults to 0.9999 The forgetting factor, used to weight the observed value and the mean. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import numpy as np >>> from river.drift import PageHinkley >>> np . random . seed ( 12345 ) >>> ph = PageHinkley () >>> # Simulate a data stream composed by two data distributions >>> data_stream = np . concatenate (( np . random . randint ( 2 , size = 1000 ), ... np . random . randint ( 4 , high = 8 , size = 1000 ))) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = ph . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1009 , input value : 5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. References \u00b6 E. S. Page. 1954. Continuous Inspection Schemes. Biometrika 41, 1/2 (1954), 100\u2013115. \u21a9","title":"PageHinkley"},{"location":"api/drift/PageHinkley/#pagehinkley","text":"Page-Hinkley method for concept drift detection. This change detection method works by computing the observed values and their mean up to the current moment. Page-Hinkley does not signal warning zones, only change detections. The method works by means of the Page-Hinkley test. In general lines it will detect a concept drift if the observed mean at some instant is greater then a threshold value lambda.","title":"PageHinkley"},{"location":"api/drift/PageHinkley/#parameters","text":"min_instances \u2013 defaults to 30 The minimum number of instances before detecting change. delta \u2013 defaults to 0.005 The delta factor for the Page Hinkley test. threshold \u2013 defaults to 50 The change detection threshold (lambda). alpha \u2013 defaults to 0.9999 The forgetting factor, used to weight the observed value and the mean.","title":"Parameters"},{"location":"api/drift/PageHinkley/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/PageHinkley/#examples","text":">>> import numpy as np >>> from river.drift import PageHinkley >>> np . random . seed ( 12345 ) >>> ph = PageHinkley () >>> # Simulate a data stream composed by two data distributions >>> data_stream = np . concatenate (( np . random . randint ( 2 , size = 1000 ), ... np . random . randint ( 4 , high = 8 , size = 1000 ))) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = ph . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1009 , input value : 5","title":"Examples"},{"location":"api/drift/PageHinkley/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/PageHinkley/#references","text":"E. S. Page. 1954. Continuous Inspection Schemes. Biometrika 41, 1/2 (1954), 100\u2013115. \u21a9","title":"References"},{"location":"api/dummy/NoChangeClassifier/","text":"NoChangeClassifier \u00b6 Dummy classifier which returns the last class seen. The predict_one method will output the last class seen whilst predict_proba_one will return 1 for the last class seen and 0 for the others. Attributes \u00b6 last_class The last class seen. classes The set of classes seen. Examples \u00b6 Taken from example 2.1 from this page . >>> import pprint >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . NoChangeClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '\u2212' >>> pprint . pprint ( model . predict_proba_one ( new_sentence )) { '+' : 0 , '\u2212' : 1 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"NoChangeClassifier"},{"location":"api/dummy/NoChangeClassifier/#nochangeclassifier","text":"Dummy classifier which returns the last class seen. The predict_one method will output the last class seen whilst predict_proba_one will return 1 for the last class seen and 0 for the others.","title":"NoChangeClassifier"},{"location":"api/dummy/NoChangeClassifier/#attributes","text":"last_class The last class seen. classes The set of classes seen.","title":"Attributes"},{"location":"api/dummy/NoChangeClassifier/#examples","text":"Taken from example 2.1 from this page . >>> import pprint >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . NoChangeClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '\u2212' >>> pprint . pprint ( model . predict_proba_one ( new_sentence )) { '+' : 0 , '\u2212' : 1 }","title":"Examples"},{"location":"api/dummy/NoChangeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/dummy/PriorClassifier/","text":"PriorClassifier \u00b6 Dummy classifier which uses the prior distribution. The predict_one method will output the most common class whilst predict_proba_one will return the normalized class counts. Attributes \u00b6 counts ( collections.Counter ) Class counts. n ( int ) Total number of seen instances. Examples \u00b6 Taken from example 2.1 from this page >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . PriorClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '+' >>> model . predict_proba_one ( new_sentence ) { '+' : 0.75 , '\u2212' : 0.25 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"PriorClassifier"},{"location":"api/dummy/PriorClassifier/#priorclassifier","text":"Dummy classifier which uses the prior distribution. The predict_one method will output the most common class whilst predict_proba_one will return the normalized class counts.","title":"PriorClassifier"},{"location":"api/dummy/PriorClassifier/#attributes","text":"counts ( collections.Counter ) Class counts. n ( int ) Total number of seen instances.","title":"Attributes"},{"location":"api/dummy/PriorClassifier/#examples","text":"Taken from example 2.1 from this page >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . PriorClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '+' >>> model . predict_proba_one ( new_sentence ) { '+' : 0.75 , '\u2212' : 0.25 }","title":"Examples"},{"location":"api/dummy/PriorClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/dummy/StatisticRegressor/","text":"StatisticRegressor \u00b6 Dummy regressor that uses a univariate statistic to make predictions. Parameters \u00b6 statistic ( river.stats.base.Univariate ) Examples \u00b6 >>> from pprint import pprint >>> from river import dummy >>> from river import stats >>> sentences = [ ... ( 'glad happy glad' , 3 ), ... ( 'glad glad joyful' , 3 ), ... ( 'glad pleasant' , 2 ), ... ( 'miserable sad glad' , - 3 ) ... ] >>> model = dummy . StatisticRegressor ( stats . Mean ()) >>> for sentence , score in sentences : ... model = model . learn_one ( sentence , score ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) 1.25 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"StatisticRegressor"},{"location":"api/dummy/StatisticRegressor/#statisticregressor","text":"Dummy regressor that uses a univariate statistic to make predictions.","title":"StatisticRegressor"},{"location":"api/dummy/StatisticRegressor/#parameters","text":"statistic ( river.stats.base.Univariate )","title":"Parameters"},{"location":"api/dummy/StatisticRegressor/#examples","text":">>> from pprint import pprint >>> from river import dummy >>> from river import stats >>> sentences = [ ... ( 'glad happy glad' , 3 ), ... ( 'glad glad joyful' , 3 ), ... ( 'glad pleasant' , 2 ), ... ( 'miserable sad glad' , - 3 ) ... ] >>> model = dummy . StatisticRegressor ( stats . Mean ()) >>> for sentence , score in sentences : ... model = model . learn_one ( sentence , score ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) 1.25","title":"Examples"},{"location":"api/dummy/StatisticRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/ensemble/ADWINBaggingClassifier/","text":"ADWINBaggingClassifier \u00b6 ADWIN Bagging classifier. ADWIN Bagging 1 is the online bagging method of Oza and Russell 2 with the addition of the ADWIN algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier. Parameters \u00b6 model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . ADWINBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.878788 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Averages the predictions of each classifier. Parameters x References \u00b6 Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009. \u21a9 Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001. \u21a9","title":"ADWINBaggingClassifier"},{"location":"api/ensemble/ADWINBaggingClassifier/#adwinbaggingclassifier","text":"ADWIN Bagging classifier. ADWIN Bagging 1 is the online bagging method of Oza and Russell 2 with the addition of the ADWIN algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.","title":"ADWINBaggingClassifier"},{"location":"api/ensemble/ADWINBaggingClassifier/#parameters","text":"model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/ADWINBaggingClassifier/#examples","text":">>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . ADWINBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.878788","title":"Examples"},{"location":"api/ensemble/ADWINBaggingClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Averages the predictions of each classifier. Parameters x","title":"Methods"},{"location":"api/ensemble/ADWINBaggingClassifier/#references","text":"Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009. \u21a9 Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001. \u21a9","title":"References"},{"location":"api/ensemble/AdaBoostClassifier/","text":"AdaBoostClassifier \u00b6 Boosting for classification For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter lambda. The lambda parameter is updated when the weaks learners fit successively the same observation. Parameters \u00b6 model ( base.Classifier ) The classifier to boost. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 wrong_weight ( collections.defaultdict ) Number of times a model has made a mistake when making predictions. correct_weight ( collections.defaultdict ) Number of times a model has predicted the right label when making predictions. Examples \u00b6 In the following example three tree classifiers are boosted together. The performance is slightly better than when using a single tree. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . Phishing () >>> metric = metrics . LogLoss () >>> model = ensemble . AdaBoostClassifier ( ... model = ( ... tree . HoeffdingTreeClassifier ( ... split_criterion = 'gini' , ... split_confidence = 1e-5 , ... grace_period = 2000 ... ) ... ), ... n_models = 5 , ... seed = 42 ... ) >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.37111 >>> print ( model ) AdaBoostClassifier ( HoeffdingTreeClassifier ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"AdaBoostClassifier"},{"location":"api/ensemble/AdaBoostClassifier/#adaboostclassifier","text":"Boosting for classification For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter lambda. The lambda parameter is updated when the weaks learners fit successively the same observation.","title":"AdaBoostClassifier"},{"location":"api/ensemble/AdaBoostClassifier/#parameters","text":"model ( base.Classifier ) The classifier to boost. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/AdaBoostClassifier/#attributes","text":"wrong_weight ( collections.defaultdict ) Number of times a model has made a mistake when making predictions. correct_weight ( collections.defaultdict ) Number of times a model has predicted the right label when making predictions.","title":"Attributes"},{"location":"api/ensemble/AdaBoostClassifier/#examples","text":"In the following example three tree classifiers are boosted together. The performance is slightly better than when using a single tree. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . Phishing () >>> metric = metrics . LogLoss () >>> model = ensemble . AdaBoostClassifier ( ... model = ( ... tree . HoeffdingTreeClassifier ( ... split_criterion = 'gini' , ... split_confidence = 1e-5 , ... grace_period = 2000 ... ) ... ), ... n_models = 5 , ... seed = 42 ... ) >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.37111 >>> print ( model ) AdaBoostClassifier ( HoeffdingTreeClassifier )","title":"Examples"},{"location":"api/ensemble/AdaBoostClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/ensemble/AdaBoostClassifier/#references","text":"Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"References"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/","text":"AdaptiveRandomForestClassifier \u00b6 Adaptive Random Forest classifier. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts It also allows training background trees, which start training if a warning is detected and replace the active tree if the warning escalates to a drift. Parameters \u00b6 n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features ( Union[bool, str, int] ) \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.MultiClassMetric ) \u2013 defaults to Accuracy: 0.00% Metric used to track trees performance within the ensemble. disable_weighted_vote \u2013 defaults to False If True , disables the weighted vote prediction. drift_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain [ Tree parameter ] Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Hellinger Distance split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba [ Tree parameter ] Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 [ Tree parameter ] Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. attr_obs ( str ) \u2013 defaults to gaussian [ Tree parameter ] The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None [ Tree parameter ] Parameters passed to the numeric AOs. See attr_obs for more information. max_size ( int ) \u2013 defaults to 32 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. seed ( int ) \u2013 defaults to None If int , seed is used to seed the random number generator; If RandomState , seed is the random number generator; If None , the random number generator is the RandomState instance used by np.random . kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Examples \u00b6 >>> from river import synth >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> dataset = synth . ConceptDriftStream ( seed = 42 , position = 500 , ... width = 40 ) . take ( 1000 ) >>> model = ensemble . AdaptiveRandomForestClassifier ( ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 70.47 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. reset Reset the forest. Notes \u00b6 Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used. References \u00b6 Heitor Murilo Gomes, Albert Bifet, Jesse Read, Jean Paul Barddal, Fabricio Enembreck, Bernhard Pfharinger, Geoff Holmes, Talel Abdessalem. Adaptive random forests for evolving data stream classification. In Machine Learning, DOI: 10.1007/s10994-017-5642-8, Springer, 2017. \u21a9","title":"AdaptiveRandomForestClassifier"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#adaptiverandomforestclassifier","text":"Adaptive Random Forest classifier. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts It also allows training background trees, which start training if a warning is detected and replace the active tree if the warning escalates to a drift.","title":"AdaptiveRandomForestClassifier"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#parameters","text":"n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features ( Union[bool, str, int] ) \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.MultiClassMetric ) \u2013 defaults to Accuracy: 0.00% Metric used to track trees performance within the ensemble. disable_weighted_vote \u2013 defaults to False If True , disables the weighted vote prediction. drift_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain [ Tree parameter ] Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Hellinger Distance split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba [ Tree parameter ] Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 [ Tree parameter ] Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. attr_obs ( str ) \u2013 defaults to gaussian [ Tree parameter ] The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None [ Tree parameter ] Parameters passed to the numeric AOs. See attr_obs for more information. max_size ( int ) \u2013 defaults to 32 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. seed ( int ) \u2013 defaults to None If int , seed is used to seed the random number generator; If RandomState , seed is the random number generator; If None , the random number generator is the RandomState instance used by np.random . kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#examples","text":">>> from river import synth >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> dataset = synth . ConceptDriftStream ( seed = 42 , position = 500 , ... width = 40 ) . take ( 1000 ) >>> model = ensemble . AdaptiveRandomForestClassifier ( ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 70.47 %","title":"Examples"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. reset Reset the forest.","title":"Methods"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#notes","text":"Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used.","title":"Notes"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#references","text":"Heitor Murilo Gomes, Albert Bifet, Jesse Read, Jean Paul Barddal, Fabricio Enembreck, Bernhard Pfharinger, Geoff Holmes, Talel Abdessalem. Adaptive random forests for evolving data stream classification. In Machine Learning, DOI: 10.1007/s10994-017-5642-8, Springer, 2017. \u21a9","title":"References"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/","text":"AdaptiveRandomForestRegressor \u00b6 Adaptive Random Forest regressor. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts Notice that this implementation is slightly different from the original algorithm proposed in 2 . The HoeffdingTreeRegressor is used as base learner, instead of FIMT-DD . It also adds a new strategy to monitor the predictions and check for concept drifts. The deviations of the predictions to the target are monitored and normalized in the [0, 1] range to fulfill ADWIN's requirements. We assume that the data subjected to the normalization follows a normal distribution, and thus, lies within the interval of the mean \\(\\pm3\\sigma\\) . Parameters \u00b6 n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . aggregation_method ( str ) \u2013 defaults to median The method to use to aggregate predictions in the ensemble. - 'mean' - 'median' - If selected will disable the weighted vote. lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to MSE: 0. Metric used to track trees performance within the ensemble. Depending, on the configuration, this metric is also used to weight predictions from the members of the ensemble. disable_weighted_vote \u2013 defaults to True If True , disables the weighted vote prediction, i.e. does not assign weights to individual tree's predictions and uses the arithmetic mean instead. Otherwise will use the metric value to weight predictions. drift_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model [ Tree parameter ] Prediction mechanism used at leaves. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None [ Tree parameter ] The regression model used to provide responses if leaf_prediction='model' . If not provided, an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 [ Tree parameter ] The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. attr_obs ( str ) \u2013 defaults to e-bst [ Tree parameter ] The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. - 'qo' : Quantizer Observer. This AO uses radius (defaults to 0.01 ) to define a cold-start for the quantization radius. As new leaves are created, new QO instances will use the standard deviation of the input features divided by std_div (defaults to 3 ) as radius values. If std_div is None , the initially passed radius value will be replicated to all QO instances. - 'te-bst' : Truncated E-BST. This extension of E-BST first truncates the input values before passing them to the binary search tree. The number of decimal places to consider is given by digits (defaults to 3 digits). See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None [ Tree parameter ] Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 [ Tree parameter ] The minimum number of samples every branch resulting from a split candidate must have to be considered valid. max_size ( int ) \u2013 defaults to 100 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. seed ( int ) \u2013 defaults to None If int , seed is used to seed the random number generator; If RandomState , seed is the random number generator; If None , the random number generator is the RandomState instance used by np.random . kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 valid_aggregation_method Valid aggregation_method values. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import ensemble >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... ensemble . AdaptiveRandomForestRegressor ( n_models = 3 , seed = 42 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.870913 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. reset Reset the forest. Notes \u00b6 Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, only one AO is supported in river for regression trees: The Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. However, E-BST automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage.Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AO algorithms are supported in river for regression trees: Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. It has a \\(O(\\\\log n)\\) cost per insertion in average, where \\(n\\) is the number of observations. In the worst case, i.e., when input features values are passed in an ordered fashion, the insertion cost becomes \\(O(n)\\) . A naive E-BST implementation has a \\(O(n)\\) cost to evaluate split candidates since all stored points must be evaluated. However, the implementation of E-BST in river automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage. Quantizer Observer (QO) uses a dynamical hash-based algorithm to discretize the numerical input features and perform split attempts. QO has \\(O(1)\\) , \\(O(H)\\) , and \\(O(H\\\\log H)\\) costs of insertion, memory, and split candidate query, respectively, where \\(H\\) is the number of slots in QO's hash structure. Typically, \\(H \\\\ll n\\) . Truncated E-BST extends E-BST by rouding the input feature values before inserting them in the binary search tree (BST). Hence, similar inputs will be mapped to the nodes in the BST structure. This strategy might result in memory and processing time savings when compared to the vanilla E-BST. References \u00b6 Gomes, H.M., Bifet, A., Read, J., Barddal, J.P., Enembreck, F., Pfharinger, B., Holmes, G. and Abdessalem, T., 2017. Adaptive random forests for evolving data stream classification. Machine Learning, 106(9-10), pp.1469-1495. \u21a9 Gomes, H.M., Barddal, J.P., Boiko, L.E., Bifet, A., 2018. Adaptive random forests for data stream regression. ESANN 2018. \u21a9","title":"AdaptiveRandomForestRegressor"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#adaptiverandomforestregressor","text":"Adaptive Random Forest regressor. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts Notice that this implementation is slightly different from the original algorithm proposed in 2 . The HoeffdingTreeRegressor is used as base learner, instead of FIMT-DD . It also adds a new strategy to monitor the predictions and check for concept drifts. The deviations of the predictions to the target are monitored and normalized in the [0, 1] range to fulfill ADWIN's requirements. We assume that the data subjected to the normalization follows a normal distribution, and thus, lies within the interval of the mean \\(\\pm3\\sigma\\) .","title":"AdaptiveRandomForestRegressor"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#parameters","text":"n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . aggregation_method ( str ) \u2013 defaults to median The method to use to aggregate predictions in the ensemble. - 'mean' - 'median' - If selected will disable the weighted vote. lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to MSE: 0. Metric used to track trees performance within the ensemble. Depending, on the configuration, this metric is also used to weight predictions from the members of the ensemble. disable_weighted_vote \u2013 defaults to True If True , disables the weighted vote prediction, i.e. does not assign weights to individual tree's predictions and uses the arithmetic mean instead. Otherwise will use the metric value to weight predictions. drift_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model [ Tree parameter ] Prediction mechanism used at leaves. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None [ Tree parameter ] The regression model used to provide responses if leaf_prediction='model' . If not provided, an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 [ Tree parameter ] The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. attr_obs ( str ) \u2013 defaults to e-bst [ Tree parameter ] The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. - 'qo' : Quantizer Observer. This AO uses radius (defaults to 0.01 ) to define a cold-start for the quantization radius. As new leaves are created, new QO instances will use the standard deviation of the input features divided by std_div (defaults to 3 ) as radius values. If std_div is None , the initially passed radius value will be replicated to all QO instances. - 'te-bst' : Truncated E-BST. This extension of E-BST first truncates the input values before passing them to the binary search tree. The number of decimal places to consider is given by digits (defaults to 3 digits). See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None [ Tree parameter ] Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 [ Tree parameter ] The minimum number of samples every branch resulting from a split candidate must have to be considered valid. max_size ( int ) \u2013 defaults to 100 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. seed ( int ) \u2013 defaults to None If int , seed is used to seed the random number generator; If RandomState , seed is the random number generator; If None , the random number generator is the RandomState instance used by np.random . kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#attributes","text":"valid_aggregation_method Valid aggregation_method values.","title":"Attributes"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import ensemble >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... ensemble . AdaptiveRandomForestRegressor ( n_models = 3 , seed = 42 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.870913","title":"Examples"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. reset Reset the forest.","title":"Methods"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#notes","text":"Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, only one AO is supported in river for regression trees: The Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. However, E-BST automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage.Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AO algorithms are supported in river for regression trees: Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. It has a \\(O(\\\\log n)\\) cost per insertion in average, where \\(n\\) is the number of observations. In the worst case, i.e., when input features values are passed in an ordered fashion, the insertion cost becomes \\(O(n)\\) . A naive E-BST implementation has a \\(O(n)\\) cost to evaluate split candidates since all stored points must be evaluated. However, the implementation of E-BST in river automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage. Quantizer Observer (QO) uses a dynamical hash-based algorithm to discretize the numerical input features and perform split attempts. QO has \\(O(1)\\) , \\(O(H)\\) , and \\(O(H\\\\log H)\\) costs of insertion, memory, and split candidate query, respectively, where \\(H\\) is the number of slots in QO's hash structure. Typically, \\(H \\\\ll n\\) . Truncated E-BST extends E-BST by rouding the input feature values before inserting them in the binary search tree (BST). Hence, similar inputs will be mapped to the nodes in the BST structure. This strategy might result in memory and processing time savings when compared to the vanilla E-BST.","title":"Notes"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#references","text":"Gomes, H.M., Bifet, A., Read, J., Barddal, J.P., Enembreck, F., Pfharinger, B., Holmes, G. and Abdessalem, T., 2017. Adaptive random forests for evolving data stream classification. Machine Learning, 106(9-10), pp.1469-1495. \u21a9 Gomes, H.M., Barddal, J.P., Boiko, L.E., Bifet, A., 2018. Adaptive random forests for data stream regression. ESANN 2018. \u21a9","title":"References"},{"location":"api/ensemble/BaggingClassifier/","text":"BaggingClassifier \u00b6 Online bootstrap aggregation for classification. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.poisson(1).pmf(k) to obtain more detailed values. Parameters \u00b6 model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Examples \u00b6 In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . BaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.877788 >>> print ( model ) BaggingClassifier ( StandardScaler | LogisticRegression ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Averages the predictions of each classifier. Parameters x References \u00b6 Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"BaggingClassifier"},{"location":"api/ensemble/BaggingClassifier/#baggingclassifier","text":"Online bootstrap aggregation for classification. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.poisson(1).pmf(k) to obtain more detailed values.","title":"BaggingClassifier"},{"location":"api/ensemble/BaggingClassifier/#parameters","text":"model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/BaggingClassifier/#examples","text":"In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . BaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.877788 >>> print ( model ) BaggingClassifier ( StandardScaler | LogisticRegression )","title":"Examples"},{"location":"api/ensemble/BaggingClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Averages the predictions of each classifier. Parameters x","title":"Methods"},{"location":"api/ensemble/BaggingClassifier/#references","text":"Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"References"},{"location":"api/ensemble/BaggingRegressor/","text":"BaggingRegressor \u00b6 Online bootstrap aggregation for regression. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.poisson(1).pmf(k) for more detailed values. Parameters \u00b6 model ( base.Regressor ) The regressor to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Examples \u00b6 In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = preprocessing . StandardScaler () >>> model |= ensemble . BaggingRegressor ( ... model = linear_model . LinearRegression ( intercept_lr = 0.1 ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.641799 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one Averages the predictions of each regressor. Parameters x References \u00b6 Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"BaggingRegressor"},{"location":"api/ensemble/BaggingRegressor/#baggingregressor","text":"Online bootstrap aggregation for regression. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.poisson(1).pmf(k) for more detailed values.","title":"BaggingRegressor"},{"location":"api/ensemble/BaggingRegressor/#parameters","text":"model ( base.Regressor ) The regressor to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/BaggingRegressor/#examples","text":"In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = preprocessing . StandardScaler () >>> model |= ensemble . BaggingRegressor ( ... model = linear_model . LinearRegression ( intercept_lr = 0.1 ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.641799","title":"Examples"},{"location":"api/ensemble/BaggingRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one Averages the predictions of each regressor. Parameters x","title":"Methods"},{"location":"api/ensemble/BaggingRegressor/#references","text":"Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"References"},{"location":"api/ensemble/LeveragingBaggingClassifier/","text":"LeveragingBaggingClassifier \u00b6 Leveraging Bagging ensemble classifier. Leveraging Bagging [^1] is an improvement over the Oza Bagging algorithm. The bagging performance is leveraged by increasing the re-sampling. It uses a poisson distribution to simulate the re-sampling process. To increase re-sampling it uses a higher w value of the Poisson distribution (agerage number of events), 6 by default, increasing the input space diversity, by attributing a different range of weights to the data samples. To deal with concept drift, Leveraging Bagging uses the ADWIN algorithm to monitor the performance of each member of the enemble If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier. Parameters \u00b6 model ( base.Classifier ) The classifier to bag. n_models ( int ) \u2013 defaults to 10 The number of models in the ensemble. w ( float ) \u2013 defaults to 6 Indicates the average number of events. This is the lambda parameter of the Poisson distribution used to compute the re-sampling weight. adwin_delta ( float ) \u2013 defaults to 0.002 The delta parameter for the ADWIN change detector. bagging_method ( str ) \u2013 defaults to bag The bagging method to use. Can be one of the following: * 'bag' - Leveraging Bagging using ADWIN. * 'me' - Assigns \\(weight=1\\) if sample is misclassified, otherwise \\(weight=error/(1-error)\\) . * 'half' - Use resampling without replacement for half of the instances. * 'wt' - Resample without taking out all instances. * 'subag' - Resampling without replacement. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 bagging_methods Valid bagging_method options. Examples \u00b6 >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . LeveragingBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.886282 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Averages the predictions of each classifier. Parameters x","title":"LeveragingBaggingClassifier"},{"location":"api/ensemble/LeveragingBaggingClassifier/#leveragingbaggingclassifier","text":"Leveraging Bagging ensemble classifier. Leveraging Bagging [^1] is an improvement over the Oza Bagging algorithm. The bagging performance is leveraged by increasing the re-sampling. It uses a poisson distribution to simulate the re-sampling process. To increase re-sampling it uses a higher w value of the Poisson distribution (agerage number of events), 6 by default, increasing the input space diversity, by attributing a different range of weights to the data samples. To deal with concept drift, Leveraging Bagging uses the ADWIN algorithm to monitor the performance of each member of the enemble If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.","title":"LeveragingBaggingClassifier"},{"location":"api/ensemble/LeveragingBaggingClassifier/#parameters","text":"model ( base.Classifier ) The classifier to bag. n_models ( int ) \u2013 defaults to 10 The number of models in the ensemble. w ( float ) \u2013 defaults to 6 Indicates the average number of events. This is the lambda parameter of the Poisson distribution used to compute the re-sampling weight. adwin_delta ( float ) \u2013 defaults to 0.002 The delta parameter for the ADWIN change detector. bagging_method ( str ) \u2013 defaults to bag The bagging method to use. Can be one of the following: * 'bag' - Leveraging Bagging using ADWIN. * 'me' - Assigns \\(weight=1\\) if sample is misclassified, otherwise \\(weight=error/(1-error)\\) . * 'half' - Use resampling without replacement for half of the instances. * 'wt' - Resample without taking out all instances. * 'subag' - Resampling without replacement. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/LeveragingBaggingClassifier/#attributes","text":"bagging_methods Valid bagging_method options.","title":"Attributes"},{"location":"api/ensemble/LeveragingBaggingClassifier/#examples","text":">>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . LeveragingBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.886282","title":"Examples"},{"location":"api/ensemble/LeveragingBaggingClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Averages the predictions of each classifier. Parameters x","title":"Methods"},{"location":"api/ensemble/SRPClassifier/","text":"SRPClassifier \u00b6 Streaming Random Patches ensemble classifier. The Streaming Random Patches (SRP) 1 is an ensemble method that simulates bagging or random subspaces. The default algorithm uses both bagging and random subspaces, namely Random Patches. The default base estimator is a Hoeffding Tree, but other base estimators can be used (differently from random forest variations). Parameters \u00b6 model ( base.Classifier ) \u2013 defaults to None The base estimator. n_models ( int ) \u2013 defaults to 100 Number of members in the ensemble. subspace_size ( Union[int, float, str] ) \u2013 defaults to 0.6 Number of features per subset for each classifier where M is the total number of features. A negative value means M - subspace_size . Only applies when using random subspaces or random patches. * If int indicates the number of features to use. Valid range [2, M]. * If float indicates the percentage of features to use, Valid range (0., 1.]. * 'sqrt' - sqrt(M)+1 * 'rmsqrt' - Residual from M-(sqrt(M)+1) training_method ( str ) \u2013 defaults to patches The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches. lam ( float ) \u2013 defaults to 6.0 Lambda value for resampling. drift_detector ( base.DriftDetector ) \u2013 defaults to None Drift detector. warning_detector ( base.DriftDetector ) \u2013 defaults to None Warning detector. disable_detector ( str ) \u2013 defaults to off Option to disable drift detectors: * If 'off' , detectors are enabled. * If 'drift' , disables concept drift detection and the background learner. * If 'warning' , disables the background learner and ensemble members are reset if drift is detected. disable_weighted_vote ( bool ) \u2013 defaults to False If True, disables weighted voting. nominal_attributes \u2013 defaults to None List of Nominal attributes. If empty, then assumes that all attributes are numerical. Note: Only applies if the base model allows to define the nominal attributes. seed \u2013 defaults to None Random number generator seed for reproducibility. metric ( river.metrics.base.MultiClassMetric ) \u2013 defaults to None Metric to track members performance within the ensemble. Examples \u00b6 >>> from river import synth >>> from river import ensemble >>> from river import tree >>> from river import evaluate >>> from river import metrics >>> dataset = synth . ConceptDriftStream ( seed = 42 , position = 500 , ... width = 50 ) . take ( 1000 ) >>> base_model = tree . HoeffdingTreeClassifier ( ... grace_period = 50 , split_confidence = 0.01 , ... nominal_attributes = [ 'age' , 'car' , 'zipcode' ] ... ) >>> model = ensemble . SRPClassifier ( ... model = base_model , n_models = 3 , seed = 42 , ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) # doctest: +SKIP Accuracy : 70.97 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. reset References \u00b6 Heitor Murilo Gomes, Jesse Read, Albert Bifet. Streaming Random Patches for Evolving Data Stream Classification. IEEE International Conference on Data Mining (ICDM), 2019. \u21a9","title":"SRPClassifier"},{"location":"api/ensemble/SRPClassifier/#srpclassifier","text":"Streaming Random Patches ensemble classifier. The Streaming Random Patches (SRP) 1 is an ensemble method that simulates bagging or random subspaces. The default algorithm uses both bagging and random subspaces, namely Random Patches. The default base estimator is a Hoeffding Tree, but other base estimators can be used (differently from random forest variations).","title":"SRPClassifier"},{"location":"api/ensemble/SRPClassifier/#parameters","text":"model ( base.Classifier ) \u2013 defaults to None The base estimator. n_models ( int ) \u2013 defaults to 100 Number of members in the ensemble. subspace_size ( Union[int, float, str] ) \u2013 defaults to 0.6 Number of features per subset for each classifier where M is the total number of features. A negative value means M - subspace_size . Only applies when using random subspaces or random patches. * If int indicates the number of features to use. Valid range [2, M]. * If float indicates the percentage of features to use, Valid range (0., 1.]. * 'sqrt' - sqrt(M)+1 * 'rmsqrt' - Residual from M-(sqrt(M)+1) training_method ( str ) \u2013 defaults to patches The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches. lam ( float ) \u2013 defaults to 6.0 Lambda value for resampling. drift_detector ( base.DriftDetector ) \u2013 defaults to None Drift detector. warning_detector ( base.DriftDetector ) \u2013 defaults to None Warning detector. disable_detector ( str ) \u2013 defaults to off Option to disable drift detectors: * If 'off' , detectors are enabled. * If 'drift' , disables concept drift detection and the background learner. * If 'warning' , disables the background learner and ensemble members are reset if drift is detected. disable_weighted_vote ( bool ) \u2013 defaults to False If True, disables weighted voting. nominal_attributes \u2013 defaults to None List of Nominal attributes. If empty, then assumes that all attributes are numerical. Note: Only applies if the base model allows to define the nominal attributes. seed \u2013 defaults to None Random number generator seed for reproducibility. metric ( river.metrics.base.MultiClassMetric ) \u2013 defaults to None Metric to track members performance within the ensemble.","title":"Parameters"},{"location":"api/ensemble/SRPClassifier/#examples","text":">>> from river import synth >>> from river import ensemble >>> from river import tree >>> from river import evaluate >>> from river import metrics >>> dataset = synth . ConceptDriftStream ( seed = 42 , position = 500 , ... width = 50 ) . take ( 1000 ) >>> base_model = tree . HoeffdingTreeClassifier ( ... grace_period = 50 , split_confidence = 0.01 , ... nominal_attributes = [ 'age' , 'car' , 'zipcode' ] ... ) >>> model = ensemble . SRPClassifier ( ... model = base_model , n_models = 3 , seed = 42 , ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) # doctest: +SKIP Accuracy : 70.97 %","title":"Examples"},{"location":"api/ensemble/SRPClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. reset","title":"Methods"},{"location":"api/ensemble/SRPClassifier/#references","text":"Heitor Murilo Gomes, Jesse Read, Albert Bifet. Streaming Random Patches for Evolving Data Stream Classification. IEEE International Conference on Data Mining (ICDM), 2019. \u21a9","title":"References"},{"location":"api/evaluate/load-binary-clf-tracks/","text":"load_binary_clf_tracks \u00b6 Return binary classification tracks.","title":"load_binary_clf_tracks"},{"location":"api/evaluate/load-binary-clf-tracks/#load_binary_clf_tracks","text":"Return binary classification tracks.","title":"load_binary_clf_tracks"},{"location":"api/evaluate/progressive-val-score/","text":"progressive_val_score \u00b6 Evaluates the performance of a model on a streaming dataset. This method is the canonical way to evaluate a model's performance. When used correctly, it allows you to exactly assess how a model would have performed in a production scenario. dataset is converted into a stream of questions and answers. At each step the model is either asked to predict an observation, or is either updated. The target is only revealed to the model after a certain amount of time, which is determined by the delay parameter. Note that under the hood this uses the stream.simulate_qa function to go through the data in arrival order. By default, there is no delay, which means that the samples are processed one after the other. When there is no delay, this function essentially performs progressive validation. When there is a delay, then we refer to it as delayed progressive validation. It is recommended to use this method when you want to determine a model's performance on a dataset. In particular, it is advised to use the delay parameter in order to get a reliable assessment. Indeed, in a production scenario, it is often the case that ground truths are made available after a certain amount of time. By using this method, you can reproduce this scenario and therefore truthfully assess what would have been the performance of a model on a given dataset. Parameters \u00b6 dataset ( Iterator[Tuple[dict, Any]] ) The stream of observations against which the model will be evaluated. model The model to evaluate. metric ( river.metrics.base.Metric ) The metric used to evaluate the model's predictions. moment ( Union[str, Callable] ) \u2013 defaults to None The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. delay ( Union[str, int, datetime.timedelta, Callable] ) \u2013 defaults to None The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. print_every \u2013 defaults to 0 Iteration number at which to print the current metric. This only takes into account the predictions, and not the training steps. show_time \u2013 defaults to False Whether or not to display the elapsed time. show_memory \u2013 defaults to False Whether or not to display the memory usage of the model. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress. Examples \u00b6 Take the following model: >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) We can evaluate it on the Phishing dataset as so: >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 ... ) [ 200 ] ROCAUC : 0.897995 [ 400 ] ROCAUC : 0.920896 [ 600 ] ROCAUC : 0.931339 [ 800 ] ROCAUC : 0.939909 [ 1 , 000 ] ROCAUC : 0.947417 [ 1 , 200 ] ROCAUC : 0.950304 ROCAUC : 0.950363 We haven't specified a delay, therefore this is strictly equivalent to the following piece of code: >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) >>> metric = metrics . ROCAUC () >>> for x , y in datasets . Phishing (): ... y_pred = model . predict_proba_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric ROCAUC : 0.950363 When print_every is specified, the current state is printed at regular intervals. Under the hood, Python's print method is being used. You can pass extra keyword arguments to modify its behavior. For instance, you may use the file argument if you want to log the progress to a file of your choice. >>> with open ( 'progress.log' , 'w' ) as f : ... metric = evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 , ... file = f ... ) >>> with open ( 'progress.log' ) as f : ... for line in f . read () . splitlines (): ... print ( line ) [ 200 ] ROCAUC : 0.94 [ 400 ] ROCAUC : 0.946969 [ 600 ] ROCAUC : 0.9517 [ 800 ] ROCAUC : 0.954238 [ 1 , 000 ] ROCAUC : 0.958207 [ 1 , 200 ] ROCAUC : 0.96002 Note that the performance is slightly better than above because we haven't used a fresh copy of the model. Instead, we've reused the existing model which has already done a full pass on the data. >>> import os ; os . remove ( 'progress.log' ) References \u00b6 Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9 Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9","title":"progressive_val_score"},{"location":"api/evaluate/progressive-val-score/#progressive_val_score","text":"Evaluates the performance of a model on a streaming dataset. This method is the canonical way to evaluate a model's performance. When used correctly, it allows you to exactly assess how a model would have performed in a production scenario. dataset is converted into a stream of questions and answers. At each step the model is either asked to predict an observation, or is either updated. The target is only revealed to the model after a certain amount of time, which is determined by the delay parameter. Note that under the hood this uses the stream.simulate_qa function to go through the data in arrival order. By default, there is no delay, which means that the samples are processed one after the other. When there is no delay, this function essentially performs progressive validation. When there is a delay, then we refer to it as delayed progressive validation. It is recommended to use this method when you want to determine a model's performance on a dataset. In particular, it is advised to use the delay parameter in order to get a reliable assessment. Indeed, in a production scenario, it is often the case that ground truths are made available after a certain amount of time. By using this method, you can reproduce this scenario and therefore truthfully assess what would have been the performance of a model on a given dataset.","title":"progressive_val_score"},{"location":"api/evaluate/progressive-val-score/#parameters","text":"dataset ( Iterator[Tuple[dict, Any]] ) The stream of observations against which the model will be evaluated. model The model to evaluate. metric ( river.metrics.base.Metric ) The metric used to evaluate the model's predictions. moment ( Union[str, Callable] ) \u2013 defaults to None The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. delay ( Union[str, int, datetime.timedelta, Callable] ) \u2013 defaults to None The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. print_every \u2013 defaults to 0 Iteration number at which to print the current metric. This only takes into account the predictions, and not the training steps. show_time \u2013 defaults to False Whether or not to display the elapsed time. show_memory \u2013 defaults to False Whether or not to display the memory usage of the model. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress.","title":"Parameters"},{"location":"api/evaluate/progressive-val-score/#examples","text":"Take the following model: >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) We can evaluate it on the Phishing dataset as so: >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 ... ) [ 200 ] ROCAUC : 0.897995 [ 400 ] ROCAUC : 0.920896 [ 600 ] ROCAUC : 0.931339 [ 800 ] ROCAUC : 0.939909 [ 1 , 000 ] ROCAUC : 0.947417 [ 1 , 200 ] ROCAUC : 0.950304 ROCAUC : 0.950363 We haven't specified a delay, therefore this is strictly equivalent to the following piece of code: >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) >>> metric = metrics . ROCAUC () >>> for x , y in datasets . Phishing (): ... y_pred = model . predict_proba_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric ROCAUC : 0.950363 When print_every is specified, the current state is printed at regular intervals. Under the hood, Python's print method is being used. You can pass extra keyword arguments to modify its behavior. For instance, you may use the file argument if you want to log the progress to a file of your choice. >>> with open ( 'progress.log' , 'w' ) as f : ... metric = evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 , ... file = f ... ) >>> with open ( 'progress.log' ) as f : ... for line in f . read () . splitlines (): ... print ( line ) [ 200 ] ROCAUC : 0.94 [ 400 ] ROCAUC : 0.946969 [ 600 ] ROCAUC : 0.9517 [ 800 ] ROCAUC : 0.954238 [ 1 , 000 ] ROCAUC : 0.958207 [ 1 , 200 ] ROCAUC : 0.96002 Note that the performance is slightly better than above because we haven't used a fresh copy of the model. Instead, we've reused the existing model which has already done a full pass on the data. >>> import os ; os . remove ( 'progress.log' )","title":"Examples"},{"location":"api/evaluate/progressive-val-score/#references","text":"Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9 Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9","title":"References"},{"location":"api/expert/EWARegressor/","text":"EWARegressor \u00b6 Exponentially Weighted Average regressor. Parameters \u00b6 regressors ( List[ base.Regressor ] ) The regressors to hedge. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function that has to be minimized. Defaults to optim.losses.Squared . learning_rate \u2013 defaults to 0.5 The learning rate by which the model weights are multiplied at each iteration. Attributes \u00b6 regressors Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import expert >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import stream >>> optimizers = [ ... optim . SGD ( 0.01 ), ... optim . RMSProp (), ... optim . AdaGrad () ... ] >>> for optimizer in optimizers : ... ... dataset = datasets . TrumpApproval () ... metric = metrics . MAE () ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... optimizer = optimizer , ... intercept_lr =. 1 ... ) ... ) ... ... print ( optimizer , evaluate . progressive_val_score ( dataset , model , metric )) SGD MAE : 0.555971 RMSProp MAE : 0.528284 AdaGrad MAE : 0.481461 >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> hedge = ( ... preprocessing . StandardScaler () | ... expert . EWARegressor ( ... regressors = [ ... linear_model . LinearRegression ( optimizer = o , intercept_lr =. 1 ) ... for o in optimizers ... ], ... learning_rate = 0.005 ... ) ... ) >>> evaluate . progressive_val_score ( dataset , hedge , metric ) MAE : 0.494832 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self learn_predict_one predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Online Learning from Experts: Weighed Majority and Hedge \u21a9 Wikipedia page on the multiplicative weight update method \u21a9 Kivinen, J. and Warmuth, M.K., 1997. Exponentiated gradient versus gradient descent for linear predictors. information and computation, 132(1), pp.1-63. \u21a9","title":"EWARegressor"},{"location":"api/expert/EWARegressor/#ewaregressor","text":"Exponentially Weighted Average regressor.","title":"EWARegressor"},{"location":"api/expert/EWARegressor/#parameters","text":"regressors ( List[ base.Regressor ] ) The regressors to hedge. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function that has to be minimized. Defaults to optim.losses.Squared . learning_rate \u2013 defaults to 0.5 The learning rate by which the model weights are multiplied at each iteration.","title":"Parameters"},{"location":"api/expert/EWARegressor/#attributes","text":"regressors","title":"Attributes"},{"location":"api/expert/EWARegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import expert >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import stream >>> optimizers = [ ... optim . SGD ( 0.01 ), ... optim . RMSProp (), ... optim . AdaGrad () ... ] >>> for optimizer in optimizers : ... ... dataset = datasets . TrumpApproval () ... metric = metrics . MAE () ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... optimizer = optimizer , ... intercept_lr =. 1 ... ) ... ) ... ... print ( optimizer , evaluate . progressive_val_score ( dataset , model , metric )) SGD MAE : 0.555971 RMSProp MAE : 0.528284 AdaGrad MAE : 0.481461 >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> hedge = ( ... preprocessing . StandardScaler () | ... expert . EWARegressor ( ... regressors = [ ... linear_model . LinearRegression ( optimizer = o , intercept_lr =. 1 ) ... for o in optimizers ... ], ... learning_rate = 0.005 ... ) ... ) >>> evaluate . progressive_val_score ( dataset , hedge , metric ) MAE : 0.494832","title":"Examples"},{"location":"api/expert/EWARegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self learn_predict_one predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/expert/EWARegressor/#references","text":"Online Learning from Experts: Weighed Majority and Hedge \u21a9 Wikipedia page on the multiplicative weight update method \u21a9 Kivinen, J. and Warmuth, M.K., 1997. Exponentiated gradient versus gradient descent for linear predictors. information and computation, 132(1), pp.1-63. \u21a9","title":"References"},{"location":"api/expert/EpsilonGreedyRegressor/","text":"EpsilonGreedyRegressor \u00b6 Epsilon-greedy bandit algorithm for regression. This bandit selects the best arm (defined as the one with the highest average reward) with probability \\((1 - \\epsilon)\\) and draws a random arm with probability \\(\\epsilon\\) . It is also called Follow-The-Leader (FTL) algorithm. Parameters \u00b6 models ( List[ base.Estimator ] ) The models to compare. metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to None Metric used for comparing models with. epsilon ( float ) \u2013 defaults to 0.1 Exploration parameter (default : 0.1). epsilon_decay ( float ) \u2013 defaults to None Exponential decay factor applied to epsilon. explore_each_arm ( int ) \u2013 defaults to 3 The number of times each arm should explored first. start_after ( int ) \u2013 defaults to 20 The number of iteration after which the bandit mechanism should begin. seed ( int ) \u2013 defaults to None The seed for the algorithm (since not deterministic). Attributes \u00b6 best_model Returns the best model, defined as the one who maximises average reward. percentage_pulled Returns the number of times (in %) each arm has been pulled. Examples \u00b6 Let's use UCBRegressor to select the best learning rate for a linear regression model. First, we define the grid of models: >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> from river import optim >>> models = [ ... compose . Pipeline ( ... preprocessing . StandardScaler (), ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... ) ... for lr in [ 1e-4 , 1e-3 , 1e-2 , 1e-1 ] ... ] We decide to use TrumpApproval dataset: >>> from river import datasets >>> dataset = datasets . TrumpApproval () The chosen bandit is epsilon-greedy: >>> from river.expert import EpsilonGreedyRegressor >>> bandit = EpsilonGreedyRegressor ( models = models , seed = 1 ) The models in the bandit can then be trained in an online fashion. >>> for x , y in dataset : ... bandit = bandit . learn_one ( x = x , y = y ) We can inspect the number of times (in percentage) each arm has been pulled. >>> for model , pct in zip ( bandit . models , bandit . percentage_pulled ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { pct : .2% } \" ) 1.0e-04 \u2014 3.47 % 1.0e-03 \u2014 2.85 % 1.0e-02 \u2014 44.75 % 1.0e-01 \u2014 48.93 % The average reward of each model is also available: >>> for model , avg in zip ( bandit . models , bandit . average_reward ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { avg : .2f } \" ) 1.0e-04 \u2014 0.00 1.0e-03 \u2014 0.00 1.0e-02 \u2014 0.56 1.0e-01 \u2014 0.01 We can also select the best model (the one with the highest average reward). >>> best_model = bandit . best_model The learning rate chosen by the bandit is: >>> best_model [ \"LinearRegression\" ] . intercept_lr . learning_rate 0.01 Methods \u00b6 add_models clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Updates the chosen model and the arm internals (the actual implementation is in Bandit._learn_one). Parameters x y predict_one Return the prediction of the best model (defined as the one who maximises average reward). Parameters x References \u00b6 Sutton, R. S., & Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press. \u21a9 Lattimore, T., & Szepesv\u00e1ri, C. (2020). Bandit algorithms. Cambridge University Press. \u21a9","title":"EpsilonGreedyRegressor"},{"location":"api/expert/EpsilonGreedyRegressor/#epsilongreedyregressor","text":"Epsilon-greedy bandit algorithm for regression. This bandit selects the best arm (defined as the one with the highest average reward) with probability \\((1 - \\epsilon)\\) and draws a random arm with probability \\(\\epsilon\\) . It is also called Follow-The-Leader (FTL) algorithm.","title":"EpsilonGreedyRegressor"},{"location":"api/expert/EpsilonGreedyRegressor/#parameters","text":"models ( List[ base.Estimator ] ) The models to compare. metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to None Metric used for comparing models with. epsilon ( float ) \u2013 defaults to 0.1 Exploration parameter (default : 0.1). epsilon_decay ( float ) \u2013 defaults to None Exponential decay factor applied to epsilon. explore_each_arm ( int ) \u2013 defaults to 3 The number of times each arm should explored first. start_after ( int ) \u2013 defaults to 20 The number of iteration after which the bandit mechanism should begin. seed ( int ) \u2013 defaults to None The seed for the algorithm (since not deterministic).","title":"Parameters"},{"location":"api/expert/EpsilonGreedyRegressor/#attributes","text":"best_model Returns the best model, defined as the one who maximises average reward. percentage_pulled Returns the number of times (in %) each arm has been pulled.","title":"Attributes"},{"location":"api/expert/EpsilonGreedyRegressor/#examples","text":"Let's use UCBRegressor to select the best learning rate for a linear regression model. First, we define the grid of models: >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> from river import optim >>> models = [ ... compose . Pipeline ( ... preprocessing . StandardScaler (), ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... ) ... for lr in [ 1e-4 , 1e-3 , 1e-2 , 1e-1 ] ... ] We decide to use TrumpApproval dataset: >>> from river import datasets >>> dataset = datasets . TrumpApproval () The chosen bandit is epsilon-greedy: >>> from river.expert import EpsilonGreedyRegressor >>> bandit = EpsilonGreedyRegressor ( models = models , seed = 1 ) The models in the bandit can then be trained in an online fashion. >>> for x , y in dataset : ... bandit = bandit . learn_one ( x = x , y = y ) We can inspect the number of times (in percentage) each arm has been pulled. >>> for model , pct in zip ( bandit . models , bandit . percentage_pulled ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { pct : .2% } \" ) 1.0e-04 \u2014 3.47 % 1.0e-03 \u2014 2.85 % 1.0e-02 \u2014 44.75 % 1.0e-01 \u2014 48.93 % The average reward of each model is also available: >>> for model , avg in zip ( bandit . models , bandit . average_reward ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { avg : .2f } \" ) 1.0e-04 \u2014 0.00 1.0e-03 \u2014 0.00 1.0e-02 \u2014 0.56 1.0e-01 \u2014 0.01 We can also select the best model (the one with the highest average reward). >>> best_model = bandit . best_model The learning rate chosen by the bandit is: >>> best_model [ \"LinearRegression\" ] . intercept_lr . learning_rate 0.01","title":"Examples"},{"location":"api/expert/EpsilonGreedyRegressor/#methods","text":"add_models clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Updates the chosen model and the arm internals (the actual implementation is in Bandit._learn_one). Parameters x y predict_one Return the prediction of the best model (defined as the one who maximises average reward). Parameters x","title":"Methods"},{"location":"api/expert/EpsilonGreedyRegressor/#references","text":"Sutton, R. S., & Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press. \u21a9 Lattimore, T., & Szepesv\u00e1ri, C. (2020). Bandit algorithms. Cambridge University Press. \u21a9","title":"References"},{"location":"api/expert/StackingClassifier/","text":"StackingClassifier \u00b6 Stacking for binary classification. Parameters \u00b6 classifiers ( List[ base.Classifier ] ) meta_classifier ( base.Classifier ) include_features \u2013 defaults to True Indicates whether or not the original features should be provided to the meta-model along with the predictions from each model. Examples \u00b6 >>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import expert >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = compose . Pipeline ( ... ( 'scale' , pp . StandardScaler ()), ... ( 'stack' , expert . StackingClassifier ( ... classifiers = [ ... lm . LogisticRegression (), ... lm . PAClassifier ( mode = 1 , C = 0.01 ), ... lm . PAClassifier ( mode = 2 , C = 0.01 ) ... ], ... meta_classifier = lm . LogisticRegression () ... )) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.881387 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 A Kaggler's Guide to Model Stacking in Practice \u21a9","title":"StackingClassifier"},{"location":"api/expert/StackingClassifier/#stackingclassifier","text":"Stacking for binary classification.","title":"StackingClassifier"},{"location":"api/expert/StackingClassifier/#parameters","text":"classifiers ( List[ base.Classifier ] ) meta_classifier ( base.Classifier ) include_features \u2013 defaults to True Indicates whether or not the original features should be provided to the meta-model along with the predictions from each model.","title":"Parameters"},{"location":"api/expert/StackingClassifier/#examples","text":">>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import expert >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = compose . Pipeline ( ... ( 'scale' , pp . StandardScaler ()), ... ( 'stack' , expert . StackingClassifier ( ... classifiers = [ ... lm . LogisticRegression (), ... lm . PAClassifier ( mode = 1 , C = 0.01 ), ... lm . PAClassifier ( mode = 2 , C = 0.01 ) ... ], ... meta_classifier = lm . LogisticRegression () ... )) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.881387","title":"Examples"},{"location":"api/expert/StackingClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/expert/StackingClassifier/#references","text":"A Kaggler's Guide to Model Stacking in Practice \u21a9","title":"References"},{"location":"api/expert/SuccessiveHalvingClassifier/","text":"SuccessiveHalvingClassifier \u00b6 Successive halving algorithm for classification. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{(2n)}) \\times eta)\\] Parameters \u00b6 models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress. Attributes \u00b6 best_model The current best model. Examples \u00b6 As an example, let's use successive halving to tune the optimizer of a logistic regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import utils >>> from river import optim >>> models = utils . expand_param_grid ( model , { ... 'LogisticRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 , . 005 ]}), ... ( optim . Adam , { 'beta_1' : [ . 01 , . 001 ], 'lr' : [ . 1 , . 01 , . 001 ]}), ... ( optim . Adam , { 'beta_1' : [ . 1 ], 'lr' : [ . 001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingClassifier . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import expert >>> sh = expert . SuccessiveHalvingClassifier ( ... models = models , ... metric = metrics . Accuracy (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingClassifier is also a classifier with a learn_one and a predict_proba_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = sh , ... metric = metrics . ROCAUC () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best Accuracy : 80.00 % [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best Accuracy : 84.00 % [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best Accuracy : 86.14 % [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best Accuracy : 84.80 % ROCAUC : 0.952889 We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler (), LogisticRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.01 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Log ( weight_pos = 1. weight_neg = 1. ) l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"SuccessiveHalvingClassifier"},{"location":"api/expert/SuccessiveHalvingClassifier/#successivehalvingclassifier","text":"Successive halving algorithm for classification. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{(2n)}) \\times eta)\\]","title":"SuccessiveHalvingClassifier"},{"location":"api/expert/SuccessiveHalvingClassifier/#parameters","text":"models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress.","title":"Parameters"},{"location":"api/expert/SuccessiveHalvingClassifier/#attributes","text":"best_model The current best model.","title":"Attributes"},{"location":"api/expert/SuccessiveHalvingClassifier/#examples","text":"As an example, let's use successive halving to tune the optimizer of a logistic regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import utils >>> from river import optim >>> models = utils . expand_param_grid ( model , { ... 'LogisticRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 , . 005 ]}), ... ( optim . Adam , { 'beta_1' : [ . 01 , . 001 ], 'lr' : [ . 1 , . 01 , . 001 ]}), ... ( optim . Adam , { 'beta_1' : [ . 1 ], 'lr' : [ . 001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingClassifier . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import expert >>> sh = expert . SuccessiveHalvingClassifier ( ... models = models , ... metric = metrics . Accuracy (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingClassifier is also a classifier with a learn_one and a predict_proba_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = sh , ... metric = metrics . ROCAUC () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best Accuracy : 80.00 % [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best Accuracy : 84.00 % [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best Accuracy : 86.14 % [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best Accuracy : 84.80 % ROCAUC : 0.952889 We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler (), LogisticRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.01 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Log ( weight_pos = 1. weight_neg = 1. ) l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) )","title":"Examples"},{"location":"api/expert/SuccessiveHalvingClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/expert/SuccessiveHalvingClassifier/#references","text":"Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"References"},{"location":"api/expert/SuccessiveHalvingRegressor/","text":"SuccessiveHalvingRegressor \u00b6 Successive halving algorithm for regression. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{2n}) \\times eta)\\] Parameters \u00b6 models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress. Attributes \u00b6 best_model The current best model. Examples \u00b6 As an example, let's use successive halving to tune the optimizer of a linear regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr =. 1 ) ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import optim >>> from river import utils >>> models = utils . expand_param_grid ( model , { ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 , . 005 ]}), ... ( optim . Adam , { 'beta_1' : [ . 01 , . 001 ], 'lr' : [ . 1 , . 01 , . 001 ]}), ... ( optim . Adam , { 'beta_1' : [ . 1 ], 'lr' : [ . 001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingRegressor . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import expert >>> sh = expert . SuccessiveHalvingRegressor ( ... models = models , ... metric = metrics . MAE (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingRegressor is also a regressor with a learn_one and a predict_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . TrumpApproval (), ... model = sh , ... metric = metrics . MAE () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best MAE : 4.540491 [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best MAE : 2.458765 [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best MAE : 1.583751 [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best MAE : 1.147296 MAE : 0.488387 We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler (), LinearRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.1 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.1 ) clip_gradient = 1e+12 initializer = Zeros () ) ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"SuccessiveHalvingRegressor"},{"location":"api/expert/SuccessiveHalvingRegressor/#successivehalvingregressor","text":"Successive halving algorithm for regression. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{2n}) \\times eta)\\]","title":"SuccessiveHalvingRegressor"},{"location":"api/expert/SuccessiveHalvingRegressor/#parameters","text":"models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress.","title":"Parameters"},{"location":"api/expert/SuccessiveHalvingRegressor/#attributes","text":"best_model The current best model.","title":"Attributes"},{"location":"api/expert/SuccessiveHalvingRegressor/#examples","text":"As an example, let's use successive halving to tune the optimizer of a linear regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr =. 1 ) ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import optim >>> from river import utils >>> models = utils . expand_param_grid ( model , { ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 , . 005 ]}), ... ( optim . Adam , { 'beta_1' : [ . 01 , . 001 ], 'lr' : [ . 1 , . 01 , . 001 ]}), ... ( optim . Adam , { 'beta_1' : [ . 1 ], 'lr' : [ . 001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingRegressor . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import expert >>> sh = expert . SuccessiveHalvingRegressor ( ... models = models , ... metric = metrics . MAE (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingRegressor is also a regressor with a learn_one and a predict_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . TrumpApproval (), ... model = sh , ... metric = metrics . MAE () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best MAE : 4.540491 [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best MAE : 2.458765 [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best MAE : 1.583751 [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best MAE : 1.147296 MAE : 0.488387 We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler (), LinearRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.1 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.1 ) clip_gradient = 1e+12 initializer = Zeros () ) )","title":"Examples"},{"location":"api/expert/SuccessiveHalvingRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/expert/SuccessiveHalvingRegressor/#references","text":"Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"References"},{"location":"api/expert/UCBRegressor/","text":"UCBRegressor \u00b6 Upper Confidence Bound bandit for regression. The class offers 2 implementations of UCB: UCB1 from 1 , when the parameter delta has value None - UCB(delta) from 2 , when the parameter delta is in (0, 1) For this bandit, rewards are supposed to be 1-subgaussian (see Lattimore and Szepesv\u00e1ri, chapter 6, p. 91) hence the use of the StandardScaler and MaxAbsScaler as reward_scaler . Parameters \u00b6 models ( List[ base.Estimator ] ) The models to compare. metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to None Metric used for comparing models with. delta ( float ) \u2013 defaults to None For UCB(delta) implementation. Lower value means more exploration. explore_each_arm ( int ) \u2013 defaults to 1 The number of times each arm should explored first. start_after ( int ) \u2013 defaults to 20 The number of iteration after which the bandit mechanism should begin. seed ( int ) \u2013 defaults to None The seed for the algorithm (since not deterministic). Attributes \u00b6 best_model Returns the best model, defined as the one who maximises average reward. percentage_pulled Returns the number of times (in %) each arm has been pulled. Examples \u00b6 Let's use UCBRegressor to select the best learning rate for a linear regression model. First, we define the grid of models: >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> from river import optim >>> models = [ ... compose . Pipeline ( ... preprocessing . StandardScaler (), ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... ) ... for lr in [ 1e-4 , 1e-3 , 1e-2 , 1e-1 ] ... ] We decide to use TrumpApproval dataset: >>> from river import datasets >>> dataset = datasets . TrumpApproval () We use the UCB bandit: >>> from river.expert import UCBRegressor >>> bandit = UCBRegressor ( models = models , seed = 1 ) The models in the bandit can be trained in an online fashion. >>> for x , y in dataset : ... bandit = bandit . learn_one ( x = x , y = y ) We can inspect the number of times (in percentage) each arm has been pulled. >>> for model , pct in zip ( bandit . models , bandit . percentage_pulled ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { pct : .2% } \" ) 1.0e-04 \u2014 2.45 % 1.0e-03 \u2014 2.45 % 1.0e-02 \u2014 92.25 % 1.0e-01 \u2014 2.85 % The average reward of each model is also available: >>> for model , avg in zip ( bandit . models , bandit . average_reward ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { avg : .2f } \" ) 1.0e-04 \u2014 0.00 1.0e-03 \u2014 0.00 1.0e-02 \u2014 0.74 1.0e-01 \u2014 0.05 We can also select the best model (the one with the highest average reward). >>> best_model = bandit . best_model The learning rate chosen by the bandit is: >>> best_model [ \"LinearRegression\" ] . intercept_lr . learning_rate 0.01 Methods \u00b6 add_models clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Updates the chosen model and the arm internals (the actual implementation is in Bandit._learn_one). Parameters x y predict_one Return the prediction of the best model (defined as the one who maximises average reward). Parameters x References \u00b6 Auer, P., Cesa-Bianchi, N., & Fischer, P. (2002). Finite-time analysis of the multiarmed bandit problem. Machine learning, 47(2-3), 235-256. \u21a9 Lattimore, T., & Szepesv\u00e1ri, C. (2020). Bandit algorithms. Cambridge University Press. \u21a9","title":"UCBRegressor"},{"location":"api/expert/UCBRegressor/#ucbregressor","text":"Upper Confidence Bound bandit for regression. The class offers 2 implementations of UCB: UCB1 from 1 , when the parameter delta has value None - UCB(delta) from 2 , when the parameter delta is in (0, 1) For this bandit, rewards are supposed to be 1-subgaussian (see Lattimore and Szepesv\u00e1ri, chapter 6, p. 91) hence the use of the StandardScaler and MaxAbsScaler as reward_scaler .","title":"UCBRegressor"},{"location":"api/expert/UCBRegressor/#parameters","text":"models ( List[ base.Estimator ] ) The models to compare. metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to None Metric used for comparing models with. delta ( float ) \u2013 defaults to None For UCB(delta) implementation. Lower value means more exploration. explore_each_arm ( int ) \u2013 defaults to 1 The number of times each arm should explored first. start_after ( int ) \u2013 defaults to 20 The number of iteration after which the bandit mechanism should begin. seed ( int ) \u2013 defaults to None The seed for the algorithm (since not deterministic).","title":"Parameters"},{"location":"api/expert/UCBRegressor/#attributes","text":"best_model Returns the best model, defined as the one who maximises average reward. percentage_pulled Returns the number of times (in %) each arm has been pulled.","title":"Attributes"},{"location":"api/expert/UCBRegressor/#examples","text":"Let's use UCBRegressor to select the best learning rate for a linear regression model. First, we define the grid of models: >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> from river import optim >>> models = [ ... compose . Pipeline ( ... preprocessing . StandardScaler (), ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... ) ... for lr in [ 1e-4 , 1e-3 , 1e-2 , 1e-1 ] ... ] We decide to use TrumpApproval dataset: >>> from river import datasets >>> dataset = datasets . TrumpApproval () We use the UCB bandit: >>> from river.expert import UCBRegressor >>> bandit = UCBRegressor ( models = models , seed = 1 ) The models in the bandit can be trained in an online fashion. >>> for x , y in dataset : ... bandit = bandit . learn_one ( x = x , y = y ) We can inspect the number of times (in percentage) each arm has been pulled. >>> for model , pct in zip ( bandit . models , bandit . percentage_pulled ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { pct : .2% } \" ) 1.0e-04 \u2014 2.45 % 1.0e-03 \u2014 2.45 % 1.0e-02 \u2014 92.25 % 1.0e-01 \u2014 2.85 % The average reward of each model is also available: >>> for model , avg in zip ( bandit . models , bandit . average_reward ): ... lr = model [ \"LinearRegression\" ] . optimizer . learning_rate ... print ( f \" { lr : .1e } \u2014 { avg : .2f } \" ) 1.0e-04 \u2014 0.00 1.0e-03 \u2014 0.00 1.0e-02 \u2014 0.74 1.0e-01 \u2014 0.05 We can also select the best model (the one with the highest average reward). >>> best_model = bandit . best_model The learning rate chosen by the bandit is: >>> best_model [ \"LinearRegression\" ] . intercept_lr . learning_rate 0.01","title":"Examples"},{"location":"api/expert/UCBRegressor/#methods","text":"add_models clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Updates the chosen model and the arm internals (the actual implementation is in Bandit._learn_one). Parameters x y predict_one Return the prediction of the best model (defined as the one who maximises average reward). Parameters x","title":"Methods"},{"location":"api/expert/UCBRegressor/#references","text":"Auer, P., Cesa-Bianchi, N., & Fischer, P. (2002). Finite-time analysis of the multiarmed bandit problem. Machine learning, 47(2-3), 235-256. \u21a9 Lattimore, T., & Szepesv\u00e1ri, C. (2020). Bandit algorithms. Cambridge University Press. \u21a9","title":"References"},{"location":"api/facto/FFMClassifier/","text":"FFMClassifier \u00b6 Field-aware Factorization Machine for binary classification. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, False ) ... ) >>> model = facto . FFMClassifier ( ... n_factors = 10 , ... intercept =. 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50).","title":"FFMClassifier"},{"location":"api/facto/FFMClassifier/#ffmclassifier","text":"Field-aware Factorization Machine for binary classification. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FFMClassifier"},{"location":"api/facto/FFMClassifier/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FFMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FFMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, False ) ... ) >>> model = facto . FFMClassifier ( ... n_factors = 10 , ... intercept =. 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) True","title":"Examples"},{"location":"api/facto/FFMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/FFMClassifier/#references","text":"Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50).","title":"References"},{"location":"api/facto/FFMRegressor/","text":"FFMRegressor \u00b6 Field-aware Factorization Machine for regression. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, 2 ) ... ) >>> model = facto . FFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) 5.319945 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50). \u21a9","title":"FFMRegressor"},{"location":"api/facto/FFMRegressor/#ffmregressor","text":"Field-aware Factorization Machine for regression. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FFMRegressor"},{"location":"api/facto/FFMRegressor/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FFMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FFMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, 2 ) ... ) >>> model = facto . FFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) 5.319945","title":"Examples"},{"location":"api/facto/FFMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/FFMRegressor/#references","text":"Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50). \u21a9","title":"References"},{"location":"api/facto/FMClassifier/","text":"FMClassifier \u00b6 Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"FMClassifier"},{"location":"api/facto/FMClassifier/#fmclassifier","text":"Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"FMClassifier"},{"location":"api/facto/FMClassifier/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True","title":"Examples"},{"location":"api/facto/FMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/FMClassifier/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"References"},{"location":"api/facto/FMRegressor/","text":"FMRegressor \u00b6 Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236504 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"FMRegressor"},{"location":"api/facto/FMRegressor/#fmregressor","text":"Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"FMRegressor"},{"location":"api/facto/FMRegressor/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236504","title":"Examples"},{"location":"api/facto/FMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/FMRegressor/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"References"},{"location":"api/facto/FwFMClassifier/","text":"FwFMClassifier \u00b6 Field-weighted Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FwFMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"FwFMClassifier"},{"location":"api/facto/FwFMClassifier/#fwfmclassifier","text":"Field-weighted Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FwFMClassifier"},{"location":"api/facto/FwFMClassifier/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FwFMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs.","title":"Attributes"},{"location":"api/facto/FwFMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FwFMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True","title":"Examples"},{"location":"api/facto/FwFMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/FwFMClassifier/#references","text":"Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"References"},{"location":"api/facto/FwFMRegressor/","text":"FwFMRegressor \u00b6 Field-weighted Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FwFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236501 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"FwFMRegressor"},{"location":"api/facto/FwFMRegressor/#fwfmregressor","text":"Field-weighted Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FwFMRegressor"},{"location":"api/facto/FwFMRegressor/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FwFMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs.","title":"Attributes"},{"location":"api/facto/FwFMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FwFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236501","title":"Examples"},{"location":"api/facto/FwFMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/FwFMRegressor/#references","text":"Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"References"},{"location":"api/facto/HOFMClassifier/","text":"HOFMClassifier \u00b6 Higher-Order Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, False ) ... ) >>> model = facto . HOFMClassifier ( ... degree = 3 , ... n_factors = 10 , ... intercept =. 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"HOFMClassifier"},{"location":"api/facto/HOFMClassifier/#hofmclassifier","text":"Higher-Order Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"HOFMClassifier"},{"location":"api/facto/HOFMClassifier/#parameters","text":"degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/HOFMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/HOFMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, False ) ... ) >>> model = facto . HOFMClassifier ( ... degree = 3 , ... n_factors = 10 , ... intercept =. 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) True","title":"Examples"},{"location":"api/facto/HOFMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/HOFMClassifier/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"References"},{"location":"api/facto/HOFMRegressor/","text":"HOFMRegressor \u00b6 Higher-Order Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note thatthe intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, 2 ) ... ) >>> model = facto . HOFMRegressor ( ... degree = 3 , ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) 5.311745 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"HOFMRegressor"},{"location":"api/facto/HOFMRegressor/#hofmregressor","text":"Higher-Order Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"HOFMRegressor"},{"location":"api/facto/HOFMRegressor/#parameters","text":"degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note thatthe intercept is handled separately. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/HOFMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/HOFMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : . 12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : . 13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : . 14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : . 15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : . 16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : . 13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : . 12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : . 16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : . 10 }, 2 ) ... ) >>> model = facto . HOFMRegressor ( ... degree = 3 , ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : . 14 }) 5.311745","title":"Examples"},{"location":"api/facto/HOFMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/HOFMRegressor/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"References"},{"location":"api/feature-extraction/Agg/","text":"Agg \u00b6 Computes a streaming aggregate. This transformer allows to compute an aggregate statistic, very much like the groupby method from pandas , but on a streaming dataset. This makes use of the streaming statistics from the stats module. When learn_one is called, the running statistic how of group by is updated with the value of on . Meanwhile, the output of transform_one is a single-element dictionary, where the key is the name of the aggregate and the value is the current value of the statistic for the relevant group. The key is automatically inferred from the parameters. Note that you can use a compose.TransformerUnion to extract many aggregate statistics in a concise manner. Parameters \u00b6 on ( str ) The feature on which to compute the aggregate statistic. by ( Union[str, List[str]] ) The feature by which to group the data. how ( river.stats.base.Univariate ) The statistic to compute. Attributes \u00b6 groups ( collections.defaultdict ) Maps group keys to univariate statistics. feature_name ( str ) The name of the feature used in the output. Examples \u00b6 Consider the following dataset: >>> X = [ ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 50 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 10 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 80 } ... ] As an example, we can calculate the average (how) revenue (on) for each place (by): >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx . Agg ( ... on = 'revenue' , ... by = 'place' , ... how = stats . Mean () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_mean_by_place' : 42.0 } { 'revenue_mean_by_place' : 16.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 17.5 } { 'revenue_mean_by_place' : 57.5 } You can compute an aggregate over multiple keys by passing a tuple to the by argument. For instance, we can compute the maximum (how) revenue (on) per place as well as per day (by): >>> agg = fx . Agg ( ... on = 'revenue' , ... by = [ 'place' , 'country' ], ... how = stats . Max () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 } { 'revenue_max_by_place_and_country' : 16 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 58 } { 'revenue_max_by_place_and_country' : 20 } { 'revenue_max_by_place_and_country' : 50 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 80 } You can use a compose.TransformerUnion in order to calculate multiple aggregates in one go. The latter can be constructed by using the + operator: >>> agg = ( ... fx . Agg ( on = 'revenue' , by = 'place' , how = stats . Mean ()) + ... fx . Agg ( on = 'revenue' , by = [ 'place' , 'country' ], how = stats . Max ()) ... ) >>> import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint . pprint ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 , 'revenue_mean_by_place' : 42.0 } { 'revenue_max_by_place_and_country' : 16 , 'revenue_mean_by_place' : 16.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 58 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 20 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 50 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 17.5 } { 'revenue_max_by_place_and_country' : 80 , 'revenue_mean_by_place' : 57.5 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Streaming groupbys in pandas for big datasets \u21a9","title":"Agg"},{"location":"api/feature-extraction/Agg/#agg","text":"Computes a streaming aggregate. This transformer allows to compute an aggregate statistic, very much like the groupby method from pandas , but on a streaming dataset. This makes use of the streaming statistics from the stats module. When learn_one is called, the running statistic how of group by is updated with the value of on . Meanwhile, the output of transform_one is a single-element dictionary, where the key is the name of the aggregate and the value is the current value of the statistic for the relevant group. The key is automatically inferred from the parameters. Note that you can use a compose.TransformerUnion to extract many aggregate statistics in a concise manner.","title":"Agg"},{"location":"api/feature-extraction/Agg/#parameters","text":"on ( str ) The feature on which to compute the aggregate statistic. by ( Union[str, List[str]] ) The feature by which to group the data. how ( river.stats.base.Univariate ) The statistic to compute.","title":"Parameters"},{"location":"api/feature-extraction/Agg/#attributes","text":"groups ( collections.defaultdict ) Maps group keys to univariate statistics. feature_name ( str ) The name of the feature used in the output.","title":"Attributes"},{"location":"api/feature-extraction/Agg/#examples","text":"Consider the following dataset: >>> X = [ ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 50 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 10 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 80 } ... ] As an example, we can calculate the average (how) revenue (on) for each place (by): >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx . Agg ( ... on = 'revenue' , ... by = 'place' , ... how = stats . Mean () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_mean_by_place' : 42.0 } { 'revenue_mean_by_place' : 16.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 17.5 } { 'revenue_mean_by_place' : 57.5 } You can compute an aggregate over multiple keys by passing a tuple to the by argument. For instance, we can compute the maximum (how) revenue (on) per place as well as per day (by): >>> agg = fx . Agg ( ... on = 'revenue' , ... by = [ 'place' , 'country' ], ... how = stats . Max () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 } { 'revenue_max_by_place_and_country' : 16 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 58 } { 'revenue_max_by_place_and_country' : 20 } { 'revenue_max_by_place_and_country' : 50 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 80 } You can use a compose.TransformerUnion in order to calculate multiple aggregates in one go. The latter can be constructed by using the + operator: >>> agg = ( ... fx . Agg ( on = 'revenue' , by = 'place' , how = stats . Mean ()) + ... fx . Agg ( on = 'revenue' , by = [ 'place' , 'country' ], how = stats . Max ()) ... ) >>> import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint . pprint ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 , 'revenue_mean_by_place' : 42.0 } { 'revenue_max_by_place_and_country' : 16 , 'revenue_mean_by_place' : 16.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 58 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 20 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 50 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 17.5 } { 'revenue_max_by_place_and_country' : 80 , 'revenue_mean_by_place' : 57.5 }","title":"Examples"},{"location":"api/feature-extraction/Agg/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/Agg/#references","text":"Streaming groupbys in pandas for big datasets \u21a9","title":"References"},{"location":"api/feature-extraction/BagOfWords/","text":"BagOfWords \u00b6 Counts tokens in sentences. This transformer can be used to counts tokens in a given piece of text. It takes care of normalizing the text before tokenizing it. In mini-batch settings, this transformers allows to convert a series of pandas of text into sparse dataframe. Note that the parameters are identical to those of feature_extraction.TFIDF . Parameters \u00b6 on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then each learn_one and transform_one will assume that each x that is provided is a str , andnot a dict . strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams. Examples \u00b6 By default, BagOfWords will take as input a sentence, preprocess it, tokenize the preprocessed text, and then return a collections.Counter containing the number of occurrences of each token. >>> from river import feature_extraction as fx >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> bow = fx . BagOfWords () >>> for sentence in corpus : ... print ( bow . transform_one ( sentence )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Note that learn_one does not have to be called because BagOfWords is stateless. You can call it but it won't do anything. In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> bow = fx . BagOfWords ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... print ( bow . transform_one ( x )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) The ngram_range parameter can be used to extract n-grams (including unigrams): >>> ngrammer = fx . BagOfWords ( ngram_range = ( 1 , 2 )) >>> ngrams = ngrammer . transform_one ( 'I love the smell of napalm in the morning' ) >>> for ngram , count in ngrams . items (): ... print ( ngram , count ) love 1 the 2 smell 1 of 1 napalm 1 in 1 morning 1 ( 'love' , 'the' ) 1 ( 'the' , 'smell' ) 1 ( 'smell' , 'of' ) 1 ( 'of' , 'napalm' ) 1 ( 'napalm' , 'in' ) 1 ( 'in' , 'the' ) 1 ( 'the' , 'morning' ) 1 BagOfWord allows to build a term-frequency pandas sparse dataframe with the transform_many method. >>> import pandas as pd >>> X = pd . Series ([ 'Hello world' , 'Hello River' ], index = [ 'river' , 'rocks' ]) >>> bow = fx . BagOfWords () >>> bow . transform_many ( X = X ) hello world river river 1 1 0 rocks 1 0 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"BagOfWords"},{"location":"api/feature-extraction/BagOfWords/#bagofwords","text":"Counts tokens in sentences. This transformer can be used to counts tokens in a given piece of text. It takes care of normalizing the text before tokenizing it. In mini-batch settings, this transformers allows to convert a series of pandas of text into sparse dataframe. Note that the parameters are identical to those of feature_extraction.TFIDF .","title":"BagOfWords"},{"location":"api/feature-extraction/BagOfWords/#parameters","text":"on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then each learn_one and transform_one will assume that each x that is provided is a str , andnot a dict . strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams.","title":"Parameters"},{"location":"api/feature-extraction/BagOfWords/#examples","text":"By default, BagOfWords will take as input a sentence, preprocess it, tokenize the preprocessed text, and then return a collections.Counter containing the number of occurrences of each token. >>> from river import feature_extraction as fx >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> bow = fx . BagOfWords () >>> for sentence in corpus : ... print ( bow . transform_one ( sentence )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Note that learn_one does not have to be called because BagOfWords is stateless. You can call it but it won't do anything. In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> bow = fx . BagOfWords ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... print ( bow . transform_one ( x )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) The ngram_range parameter can be used to extract n-grams (including unigrams): >>> ngrammer = fx . BagOfWords ( ngram_range = ( 1 , 2 )) >>> ngrams = ngrammer . transform_one ( 'I love the smell of napalm in the morning' ) >>> for ngram , count in ngrams . items (): ... print ( ngram , count ) love 1 the 2 smell 1 of 1 napalm 1 in 1 morning 1 ( 'love' , 'the' ) 1 ( 'the' , 'smell' ) 1 ( 'smell' , 'of' ) 1 ( 'of' , 'napalm' ) 1 ( 'napalm' , 'in' ) 1 ( 'in' , 'the' ) 1 ( 'the' , 'morning' ) 1 BagOfWord allows to build a term-frequency pandas sparse dataframe with the transform_many method. >>> import pandas as pd >>> X = pd . Series ([ 'Hello world' , 'Hello River' ], index = [ 'river' , 'rocks' ]) >>> bow = fx . BagOfWords () >>> bow . transform_many ( X = X ) hello world river river 1 1 0 rocks 1 0 1","title":"Examples"},{"location":"api/feature-extraction/BagOfWords/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/PolynomialExtender/","text":"PolynomialExtender \u00b6 Polynomial feature extender. Generate features consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. Be aware that the number of outputted features scales polynomially in the number of input features and exponentially in the degree. High degrees can cause overfitting. Parameters \u00b6 degree \u2013 defaults to 2 The maximum degree of the polynomial features. interaction_only \u2013 defaults to False If True then only combinations that include an element at most once will be computed. include_bias \u2013 defaults to False Whether or not to include a dummy feature which is always equal to 1. bias_name \u2013 defaults to bias Name to give to the bias feature. Examples \u00b6 >>> from river import feature_extraction as fx >>> X = [ ... { 'x' : 0 , 'y' : 1 }, ... { 'x' : 2 , 'y' : 3 }, ... { 'x' : 4 , 'y' : 5 } ... ] >>> poly = fx . PolynomialExtender ( degree = 2 , include_bias = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'x*x' : 0 , 'x*y' : 0 , 'y*y' : 1 , 'bias' : 1 } { 'x' : 2 , 'y' : 3 , 'x*x' : 4 , 'x*y' : 6 , 'y*y' : 9 , 'bias' : 1 } { 'x' : 4 , 'y' : 5 , 'x*x' : 16 , 'x*y' : 20 , 'y*y' : 25 , 'bias' : 1 } >>> X = [ ... { 'x' : 0 , 'y' : 1 , 'z' : 2 }, ... { 'x' : 2 , 'y' : 3 , 'z' : 2 }, ... { 'x' : 4 , 'y' : 5 , 'z' : 2 } ... ] >>> poly = fx . PolynomialExtender ( degree = 3 , interaction_only = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'z' : 2 , 'x*y' : 0 , 'x*z' : 0 , 'y*z' : 2 , 'x*y*z' : 0 } { 'x' : 2 , 'y' : 3 , 'z' : 2 , 'x*y' : 6 , 'x*z' : 4 , 'y*z' : 6 , 'x*y*z' : 12 } { 'x' : 4 , 'y' : 5 , 'z' : 2 , 'x*y' : 20 , 'x*z' : 8 , 'y*z' : 10 , 'x*y*z' : 40 } Polynomial features are typically used for a linear model to capture interactions between features. This may done by setting up a pipeline, as so: >>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = ( ... fx . PolynomialExtender () | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.88 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"PolynomialExtender"},{"location":"api/feature-extraction/PolynomialExtender/#polynomialextender","text":"Polynomial feature extender. Generate features consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. Be aware that the number of outputted features scales polynomially in the number of input features and exponentially in the degree. High degrees can cause overfitting.","title":"PolynomialExtender"},{"location":"api/feature-extraction/PolynomialExtender/#parameters","text":"degree \u2013 defaults to 2 The maximum degree of the polynomial features. interaction_only \u2013 defaults to False If True then only combinations that include an element at most once will be computed. include_bias \u2013 defaults to False Whether or not to include a dummy feature which is always equal to 1. bias_name \u2013 defaults to bias Name to give to the bias feature.","title":"Parameters"},{"location":"api/feature-extraction/PolynomialExtender/#examples","text":">>> from river import feature_extraction as fx >>> X = [ ... { 'x' : 0 , 'y' : 1 }, ... { 'x' : 2 , 'y' : 3 }, ... { 'x' : 4 , 'y' : 5 } ... ] >>> poly = fx . PolynomialExtender ( degree = 2 , include_bias = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'x*x' : 0 , 'x*y' : 0 , 'y*y' : 1 , 'bias' : 1 } { 'x' : 2 , 'y' : 3 , 'x*x' : 4 , 'x*y' : 6 , 'y*y' : 9 , 'bias' : 1 } { 'x' : 4 , 'y' : 5 , 'x*x' : 16 , 'x*y' : 20 , 'y*y' : 25 , 'bias' : 1 } >>> X = [ ... { 'x' : 0 , 'y' : 1 , 'z' : 2 }, ... { 'x' : 2 , 'y' : 3 , 'z' : 2 }, ... { 'x' : 4 , 'y' : 5 , 'z' : 2 } ... ] >>> poly = fx . PolynomialExtender ( degree = 3 , interaction_only = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'z' : 2 , 'x*y' : 0 , 'x*z' : 0 , 'y*z' : 2 , 'x*y*z' : 0 } { 'x' : 2 , 'y' : 3 , 'z' : 2 , 'x*y' : 6 , 'x*z' : 4 , 'y*z' : 6 , 'x*y*z' : 12 } { 'x' : 4 , 'y' : 5 , 'z' : 2 , 'x*y' : 20 , 'x*z' : 8 , 'y*z' : 10 , 'x*y*z' : 40 } Polynomial features are typically used for a linear model to capture interactions between features. This may done by setting up a pipeline, as so: >>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = ( ... fx . PolynomialExtender () | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.88 %","title":"Examples"},{"location":"api/feature-extraction/PolynomialExtender/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/RBFSampler/","text":"RBFSampler \u00b6 Extracts random features which approximate an RBF kernel. This is a powerful way to give non-linear capacity to linear classifiers. This method is also called \"random Fourier features\" in the literature. Parameters \u00b6 gamma \u2013 defaults to 1.0 RBF kernel parameter in (-gamma * x^2) . n_components \u2013 defaults to 100 Number of samples per original feature. Equals the dimensionality of the computed feature space. seed ( int ) \u2013 defaults to None Random number seed. Examples \u00b6 >>> from river import feature_extraction as fx >>> from river import linear_model as lm >>> from river import optim >>> from river import stream >>> # XOR function >>> X = [[ 0 , 0 ], [ 1 , 1 ], [ 1 , 0 ], [ 0 , 1 ]] >>> Y = [ 0 , 0 , 1 , 1 ] >>> model = lm . LogisticRegression ( optimizer = optim . SGD ( . 1 )) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 0 1 1 >>> model = ( ... fx . RBFSampler ( seed = 3 ) | ... lm . LogisticRegression ( optimizer = optim . SGD ( . 1 )) ... ) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 1 1 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values. References \u00b6 Rahimi, A. and Recht, B., 2008. Random features for large-scale kernel machines. In Advances in neural information processing systems (pp. 1177-1184 \u21a9","title":"RBFSampler"},{"location":"api/feature-extraction/RBFSampler/#rbfsampler","text":"Extracts random features which approximate an RBF kernel. This is a powerful way to give non-linear capacity to linear classifiers. This method is also called \"random Fourier features\" in the literature.","title":"RBFSampler"},{"location":"api/feature-extraction/RBFSampler/#parameters","text":"gamma \u2013 defaults to 1.0 RBF kernel parameter in (-gamma * x^2) . n_components \u2013 defaults to 100 Number of samples per original feature. Equals the dimensionality of the computed feature space. seed ( int ) \u2013 defaults to None Random number seed.","title":"Parameters"},{"location":"api/feature-extraction/RBFSampler/#examples","text":">>> from river import feature_extraction as fx >>> from river import linear_model as lm >>> from river import optim >>> from river import stream >>> # XOR function >>> X = [[ 0 , 0 ], [ 1 , 1 ], [ 1 , 0 ], [ 0 , 1 ]] >>> Y = [ 0 , 0 , 1 , 1 ] >>> model = lm . LogisticRegression ( optimizer = optim . SGD ( . 1 )) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 0 1 1 >>> model = ( ... fx . RBFSampler ( seed = 3 ) | ... lm . LogisticRegression ( optimizer = optim . SGD ( . 1 )) ... ) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 1 1 1","title":"Examples"},{"location":"api/feature-extraction/RBFSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/RBFSampler/#references","text":"Rahimi, A. and Recht, B., 2008. Random features for large-scale kernel machines. In Advances in neural information processing systems (pp. 1177-1184 \u21a9","title":"References"},{"location":"api/feature-extraction/TFIDF/","text":"TFIDF \u00b6 Computes TF-IDF values from sentences. The TF-IDF formula is the same one as scikit-learn. The only difference is the fact that the document frequencies are determined online, whereas in a batch setting they can be determined by performing an initial pass through the data. Note that the parameters are identical to those of feature_extraction.BagOfWords . Parameters \u00b6 normalize \u2013 defaults to True Whether or not the TF-IDF values by their L2 norm. on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then the input is treated as a document instead of a set of features. strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams. Only works if tokenizer is not set to False . Attributes \u00b6 dfs ( collections.defaultdict) ) Document counts. n ( int ) Number of scanned documents. Examples \u00b6 >>> from river import feature_extraction >>> tfidf = feature_extraction . TFIDF () >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> for sentence in corpus : ... tfidf = tfidf . learn_one ( sentence ) ... print ( tfidf . transform_one ( sentence )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 } In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> tfidf = feature_extraction . TFIDF ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... tfidf = tfidf . learn_one ( x ) ... print ( tfidf . transform_one ( x )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"TFIDF"},{"location":"api/feature-extraction/TFIDF/#tfidf","text":"Computes TF-IDF values from sentences. The TF-IDF formula is the same one as scikit-learn. The only difference is the fact that the document frequencies are determined online, whereas in a batch setting they can be determined by performing an initial pass through the data. Note that the parameters are identical to those of feature_extraction.BagOfWords .","title":"TFIDF"},{"location":"api/feature-extraction/TFIDF/#parameters","text":"normalize \u2013 defaults to True Whether or not the TF-IDF values by their L2 norm. on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then the input is treated as a document instead of a set of features. strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams. Only works if tokenizer is not set to False .","title":"Parameters"},{"location":"api/feature-extraction/TFIDF/#attributes","text":"dfs ( collections.defaultdict) ) Document counts. n ( int ) Number of scanned documents.","title":"Attributes"},{"location":"api/feature-extraction/TFIDF/#examples","text":">>> from river import feature_extraction >>> tfidf = feature_extraction . TFIDF () >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> for sentence in corpus : ... tfidf = tfidf . learn_one ( sentence ) ... print ( tfidf . transform_one ( sentence )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 } In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> tfidf = feature_extraction . TFIDF ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... tfidf = tfidf . learn_one ( x ) ... print ( tfidf . transform_one ( x )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 }","title":"Examples"},{"location":"api/feature-extraction/TFIDF/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/TargetAgg/","text":"TargetAgg \u00b6 Computes a streaming aggregate of the target values. This transformer is identical to feature_extraction.Agg , the only difference is that it operates on the target rather than on a feature. At each step, the running statistic how of target values in group by is updated with the target. It is therefore a supervised transformer. Parameters \u00b6 by ( Union[str, List[str]] ) The feature by which to group the target values. how ( river.stats.base.Univariate ) The statistic to compute. target_name \u2013 defaults to target The target name which is used in the result. Attributes \u00b6 groups Maps group keys to univariate statistics. feature_name The name of the feature in the output. Examples \u00b6 Consider the following dataset, where the second value of each value is the target: >>> dataset = [ ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 42 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 16 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 24 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 58 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 20 ), ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 50 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 10 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 80 ) ... ] As an example, let's perform a target encoding of the place feature. Instead of simply updating a running average, we use a stats.BayesianMean which allows us to incorporate some prior knowledge. This makes subsequent models less prone to overfitting. Indeed, it dampens the fact that too few samples might have been seen within a group. >>> from river import feature_extraction >>> from river import stats >>> agg = feature_extraction . TargetAgg ( ... by = 'place' , ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'target_bayes_mean_by_place' : 3.0 } { 'target_bayes_mean_by_place' : 3.0 } { 'target_bayes_mean_by_place' : 9.5 } { 'target_bayes_mean_by_place' : 22.5 } { 'target_bayes_mean_by_place' : 14.333 } { 'target_bayes_mean_by_place' : 34.333 } { 'target_bayes_mean_by_place' : 15.75 } { 'target_bayes_mean_by_place' : 38.25 } Just like with feature_extraction.Agg , we can specify multiple features on which to group the data: >>> agg = feature_extraction . TargetAgg ( ... by = [ 'place' , 'country' ], ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 9.5 } { 'target_bayes_mean_by_place_and_country' : 22.5 } { 'target_bayes_mean_by_place_and_country' : 13.5 } { 'target_bayes_mean_by_place_and_country' : 30.5 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Streaming groupbys in pandas for big datasets","title":"TargetAgg"},{"location":"api/feature-extraction/TargetAgg/#targetagg","text":"Computes a streaming aggregate of the target values. This transformer is identical to feature_extraction.Agg , the only difference is that it operates on the target rather than on a feature. At each step, the running statistic how of target values in group by is updated with the target. It is therefore a supervised transformer.","title":"TargetAgg"},{"location":"api/feature-extraction/TargetAgg/#parameters","text":"by ( Union[str, List[str]] ) The feature by which to group the target values. how ( river.stats.base.Univariate ) The statistic to compute. target_name \u2013 defaults to target The target name which is used in the result.","title":"Parameters"},{"location":"api/feature-extraction/TargetAgg/#attributes","text":"groups Maps group keys to univariate statistics. feature_name The name of the feature in the output.","title":"Attributes"},{"location":"api/feature-extraction/TargetAgg/#examples","text":"Consider the following dataset, where the second value of each value is the target: >>> dataset = [ ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 42 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 16 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 24 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 58 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 20 ), ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 50 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 10 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 80 ) ... ] As an example, let's perform a target encoding of the place feature. Instead of simply updating a running average, we use a stats.BayesianMean which allows us to incorporate some prior knowledge. This makes subsequent models less prone to overfitting. Indeed, it dampens the fact that too few samples might have been seen within a group. >>> from river import feature_extraction >>> from river import stats >>> agg = feature_extraction . TargetAgg ( ... by = 'place' , ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'target_bayes_mean_by_place' : 3.0 } { 'target_bayes_mean_by_place' : 3.0 } { 'target_bayes_mean_by_place' : 9.5 } { 'target_bayes_mean_by_place' : 22.5 } { 'target_bayes_mean_by_place' : 14.333 } { 'target_bayes_mean_by_place' : 34.333 } { 'target_bayes_mean_by_place' : 15.75 } { 'target_bayes_mean_by_place' : 38.25 } Just like with feature_extraction.Agg , we can specify multiple features on which to group the data: >>> agg = feature_extraction . TargetAgg ( ... by = [ 'place' , 'country' ], ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 3.0 } { 'target_bayes_mean_by_place_and_country' : 9.5 } { 'target_bayes_mean_by_place_and_country' : 22.5 } { 'target_bayes_mean_by_place_and_country' : 13.5 } { 'target_bayes_mean_by_place_and_country' : 30.5 }","title":"Examples"},{"location":"api/feature-extraction/TargetAgg/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/TargetAgg/#references","text":"Streaming groupbys in pandas for big datasets","title":"References"},{"location":"api/feature-selection/PoissonInclusion/","text":"PoissonInclusion \u00b6 Randomly selects features with an inclusion trial. When a new feature is encountered, it is selected with probability p . The number of times a feature needs to beseen before it is added to the model follows a geometric distribution with expected value 1 / p . This feature selection method is meant to be used when you have a very large amount of sparse features. Parameters \u00b6 p ( float ) Probability of including a feature the first time it is encountered. seed ( int ) \u2013 defaults to None Random seed value used for reproducibility. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9","title":"PoissonInclusion"},{"location":"api/feature-selection/PoissonInclusion/#poissoninclusion","text":"Randomly selects features with an inclusion trial. When a new feature is encountered, it is selected with probability p . The number of times a feature needs to beseen before it is added to the model follows a geometric distribution with expected value 1 / p . This feature selection method is meant to be used when you have a very large amount of sparse features.","title":"PoissonInclusion"},{"location":"api/feature-selection/PoissonInclusion/#parameters","text":"p ( float ) Probability of including a feature the first time it is encountered. seed ( int ) \u2013 defaults to None Random seed value used for reproducibility.","title":"Parameters"},{"location":"api/feature-selection/PoissonInclusion/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-selection/PoissonInclusion/#references","text":"McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9","title":"References"},{"location":"api/feature-selection/SelectKBest/","text":"SelectKBest \u00b6 Removes all but the \\(k\\) highest scoring features. Parameters \u00b6 similarity ( river.stats.base.Bivariate ) k \u2013 defaults to 10 The number of features to keep. Attributes \u00b6 similarities ( dict ) The similarity instances used for each feature. leaderboard ( dict ) The actual similarity measures. Examples \u00b6 >>> from pprint import pprint >>> from river import feature_selection >>> from river import stats >>> from river import stream >>> from sklearn import datasets >>> X , y = datasets . make_regression ( ... n_samples = 100 , ... n_features = 10 , ... n_informative = 2 , ... random_state = 42 ... ) >>> selector = feature_selection . SelectKBest ( ... similarity = stats . PearsonCorr (), ... k = 2 ... ) >>> for xi , yi , in stream . iter_array ( X , y ): ... selector = selector . learn_one ( xi , yi ) >>> pprint ( selector . leaderboard ) Counter ({ 9 : 0.7898 , 7 : 0.5444 , 8 : 0.1062 , 2 : 0.0638 , 4 : 0.0538 , 5 : 0.0271 , 1 : - 0.0312 , 6 : - 0.0657 , 3 : - 0.1501 , 0 : - 0.1895 }) >>> selector . transform_one ( xi ) { 7 : - 1.2795 , 9 : - 1.8408 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"SelectKBest"},{"location":"api/feature-selection/SelectKBest/#selectkbest","text":"Removes all but the \\(k\\) highest scoring features.","title":"SelectKBest"},{"location":"api/feature-selection/SelectKBest/#parameters","text":"similarity ( river.stats.base.Bivariate ) k \u2013 defaults to 10 The number of features to keep.","title":"Parameters"},{"location":"api/feature-selection/SelectKBest/#attributes","text":"similarities ( dict ) The similarity instances used for each feature. leaderboard ( dict ) The actual similarity measures.","title":"Attributes"},{"location":"api/feature-selection/SelectKBest/#examples","text":">>> from pprint import pprint >>> from river import feature_selection >>> from river import stats >>> from river import stream >>> from sklearn import datasets >>> X , y = datasets . make_regression ( ... n_samples = 100 , ... n_features = 10 , ... n_informative = 2 , ... random_state = 42 ... ) >>> selector = feature_selection . SelectKBest ( ... similarity = stats . PearsonCorr (), ... k = 2 ... ) >>> for xi , yi , in stream . iter_array ( X , y ): ... selector = selector . learn_one ( xi , yi ) >>> pprint ( selector . leaderboard ) Counter ({ 9 : 0.7898 , 7 : 0.5444 , 8 : 0.1062 , 2 : 0.0638 , 4 : 0.0538 , 5 : 0.0271 , 1 : - 0.0312 , 6 : - 0.0657 , 3 : - 0.1501 , 0 : - 0.1895 }) >>> selector . transform_one ( xi ) { 7 : - 1.2795 , 9 : - 1.8408 }","title":"Examples"},{"location":"api/feature-selection/SelectKBest/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-selection/VarianceThreshold/","text":"VarianceThreshold \u00b6 Removes low-variance features. Parameters \u00b6 threshold \u2013 defaults to 0 Only features with a variance above the threshold will be kept. min_samples \u2013 defaults to 2 The minimum number of samples required to perform selection. Attributes \u00b6 variances ( dict ) The variance of each feature. Examples \u00b6 >>> from river import feature_selection >>> from river import stream >>> X = [ ... [ 0 , 2 , 0 , 3 ], ... [ 0 , 1 , 4 , 3 ], ... [ 0 , 1 , 1 , 3 ] ... ] >>> selector = feature_selection . VarianceThreshold () >>> for x , _ in stream . iter_array ( X ): ... print ( selector . learn_one ( x ) . transform_one ( x )) { 0 : 0 , 1 : 2 , 2 : 0 , 3 : 3 } { 1 : 1 , 2 : 4 } { 1 : 1 , 2 : 1 } Methods \u00b6 check_feature clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"VarianceThreshold"},{"location":"api/feature-selection/VarianceThreshold/#variancethreshold","text":"Removes low-variance features.","title":"VarianceThreshold"},{"location":"api/feature-selection/VarianceThreshold/#parameters","text":"threshold \u2013 defaults to 0 Only features with a variance above the threshold will be kept. min_samples \u2013 defaults to 2 The minimum number of samples required to perform selection.","title":"Parameters"},{"location":"api/feature-selection/VarianceThreshold/#attributes","text":"variances ( dict ) The variance of each feature.","title":"Attributes"},{"location":"api/feature-selection/VarianceThreshold/#examples","text":">>> from river import feature_selection >>> from river import stream >>> X = [ ... [ 0 , 2 , 0 , 3 ], ... [ 0 , 1 , 4 , 3 ], ... [ 0 , 1 , 1 , 3 ] ... ] >>> selector = feature_selection . VarianceThreshold () >>> for x , _ in stream . iter_array ( X ): ... print ( selector . learn_one ( x ) . transform_one ( x )) { 0 : 0 , 1 : 2 , 2 : 0 , 3 : 3 } { 1 : 1 , 2 : 4 } { 1 : 1 , 2 : 1 }","title":"Examples"},{"location":"api/feature-selection/VarianceThreshold/#methods","text":"check_feature clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/imblearn/HardSamplingClassifier/","text":"HardSamplingClassifier \u00b6 Hard sampling classifier. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place. Parameters \u00b6 classifier ( base.Classifier ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( Union[ optim.losses.BinaryLoss , optim.losses.MultiClassLoss ] ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingClassifier ( ... classifier = linear_model . LogisticRegression (), ... p = 0.1 , ... size = 40 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = model , ... metric = metrics . ROCAUC (), ... print_every = 500 , ... ) [ 500 ] ROCAUC : 0.927112 [ 1 , 000 ] ROCAUC : 0.947515 ROCAUC : 0.950541 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"HardSamplingClassifier"},{"location":"api/imblearn/HardSamplingClassifier/#hardsamplingclassifier","text":"Hard sampling classifier. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place.","title":"HardSamplingClassifier"},{"location":"api/imblearn/HardSamplingClassifier/#parameters","text":"classifier ( base.Classifier ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( Union[ optim.losses.BinaryLoss , optim.losses.MultiClassLoss ] ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed.","title":"Parameters"},{"location":"api/imblearn/HardSamplingClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingClassifier ( ... classifier = linear_model . LogisticRegression (), ... p = 0.1 , ... size = 40 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = model , ... metric = metrics . ROCAUC (), ... print_every = 500 , ... ) [ 500 ] ROCAUC : 0.927112 [ 1 , 000 ] ROCAUC : 0.947515 ROCAUC : 0.950541","title":"Examples"},{"location":"api/imblearn/HardSamplingClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/HardSamplingRegressor/","text":"HardSamplingRegressor \u00b6 Hard sampling regressor. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place. Parameters \u00b6 regressor ( base.Regressor ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingRegressor ( ... regressor = linear_model . LinearRegression (), ... p =. 2 , ... size = 30 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 2.292501 [ 1 , 000 ] MAE : 1.395797 MAE : 1.394693 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one","title":"HardSamplingRegressor"},{"location":"api/imblearn/HardSamplingRegressor/#hardsamplingregressor","text":"Hard sampling regressor. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place.","title":"HardSamplingRegressor"},{"location":"api/imblearn/HardSamplingRegressor/#parameters","text":"regressor ( base.Regressor ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed.","title":"Parameters"},{"location":"api/imblearn/HardSamplingRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingRegressor ( ... regressor = linear_model . LinearRegression (), ... p =. 2 , ... size = 30 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 2.292501 [ 1 , 000 ] MAE : 1.395797 MAE : 1.394693","title":"Examples"},{"location":"api/imblearn/HardSamplingRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one","title":"Methods"},{"location":"api/imblearn/RandomOverSampler/","text":"RandomOverSampler \u00b6 Random over-sampling. This is a wrapper for classifiers. It will train the provided classifier by over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of reverse rejection sampling. Parameters \u00b6 classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"RandomOverSampler"},{"location":"api/imblearn/RandomOverSampler/#randomoversampler","text":"Random over-sampling. This is a wrapper for classifiers. It will train the provided classifier by over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of reverse rejection sampling.","title":"RandomOverSampler"},{"location":"api/imblearn/RandomOverSampler/#parameters","text":"classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/imblearn/RandomOverSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/RandomSampler/","text":"RandomSampler \u00b6 Random sampling by mixing under-sampling and over-sampling. This is a wrapper for classifiers. It will train the provided classifier by both under-sampling and over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. Parameters \u00b6 classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. If set to None , then the observations will be sampled uniformly at random, which is stricly equivalent to using ensemble.BaggingClassifier . sampling_rate \u2013 defaults to 1.0 The desired ratio of data to sample. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"RandomSampler"},{"location":"api/imblearn/RandomSampler/#randomsampler","text":"Random sampling by mixing under-sampling and over-sampling. This is a wrapper for classifiers. It will train the provided classifier by both under-sampling and over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution.","title":"RandomSampler"},{"location":"api/imblearn/RandomSampler/#parameters","text":"classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. If set to None , then the observations will be sampled uniformly at random, which is stricly equivalent to using ensemble.BaggingClassifier . sampling_rate \u2013 defaults to 1.0 The desired ratio of data to sample. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/imblearn/RandomSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/RandomUnderSampler/","text":"RandomUnderSampler \u00b6 Random under-sampling. This is a wrapper for classifiers. It will train the provided classifier by under-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of rejection sampling. Parameters \u00b6 classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Under-sampling a dataset with desired ratios \u21a9 Wikipedia article on rejection sampling \u21a9","title":"RandomUnderSampler"},{"location":"api/imblearn/RandomUnderSampler/#randomundersampler","text":"Random under-sampling. This is a wrapper for classifiers. It will train the provided classifier by under-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of rejection sampling.","title":"RandomUnderSampler"},{"location":"api/imblearn/RandomUnderSampler/#parameters","text":"classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/imblearn/RandomUnderSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/RandomUnderSampler/#references","text":"Under-sampling a dataset with desired ratios \u21a9 Wikipedia article on rejection sampling \u21a9","title":"References"},{"location":"api/linear-model/ALMAClassifier/","text":"ALMAClassifier \u00b6 Approximate Large Margin Algorithm (ALMA). Parameters \u00b6 p \u2013 defaults to 2 alpha \u2013 defaults to 0.9 B \u2013 defaults to 1.1111111111111112 C \u2013 defaults to 1.4142135623730951 Attributes \u00b6 w ( collections.defaultdict ) The current weights. k ( int ) The number of instances seen during training. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . ALMAClassifier () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 82.64 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. References \u00b6 Gentile, Claudio. \"A new approximate maximal margin classification algorithm.\" Journal of Machine Learning Research 2.Dec (2001): 213-242 \u21a9","title":"ALMAClassifier"},{"location":"api/linear-model/ALMAClassifier/#almaclassifier","text":"Approximate Large Margin Algorithm (ALMA).","title":"ALMAClassifier"},{"location":"api/linear-model/ALMAClassifier/#parameters","text":"p \u2013 defaults to 2 alpha \u2013 defaults to 0.9 B \u2013 defaults to 1.1111111111111112 C \u2013 defaults to 1.4142135623730951","title":"Parameters"},{"location":"api/linear-model/ALMAClassifier/#attributes","text":"w ( collections.defaultdict ) The current weights. k ( int ) The number of instances seen during training.","title":"Attributes"},{"location":"api/linear-model/ALMAClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . ALMAClassifier () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 82.64 %","title":"Examples"},{"location":"api/linear-model/ALMAClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/ALMAClassifier/#references","text":"Gentile, Claudio. \"A new approximate maximal margin classification algorithm.\" Journal of Machine Learning Research 2.Dec (2001): 213-242 \u21a9","title":"References"},{"location":"api/linear-model/LinearRegression/","text":"LinearRegression \u00b6 Linear regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler . Parameters \u00b6 optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Attributes \u00b6 weights ( dict ) The current weights. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr =. 1 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.555971 >>> model [ 'LinearRegression' ] . intercept 35.617670 You can call the debug_one method to break down a prediction. This works even if the linear regression is part of a pipeline. >>> x , y = next ( iter ( dataset )) >>> report = model . debug_one ( x ) >>> print ( report ) 0. Input -------- gallup : 43.84321 ( float ) ipsos : 46.19925 ( float ) morning_consult : 48.31875 ( float ) ordinal_date : 736389 ( int ) rasmussen : 44.10469 ( float ) you_gov : 43.63691 ( float ) < BLANKLINE > 1. StandardScaler ----------------- gallup : 1.18810 ( float ) ipsos : 2.10348 ( float ) morning_consult : 2.73545 ( float ) ordinal_date : - 1.73032 ( float ) rasmussen : 1.26872 ( float ) you_gov : 1.48391 ( float ) < BLANKLINE > 2. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 35.61767 35.61767 ipsos 2.10348 0.62689 1.31866 morning_consult 2.73545 0.24180 0.66144 gallup 1.18810 0.43568 0.51764 rasmussen 1.26872 0.28118 0.35674 you_gov 1.48391 0.03123 0.04634 ordinal_date - 1.73032 3.45162 - 5.97242 < BLANKLINE > Prediction : 32.54607 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the linear regression. Parameters x ( dict ) decimals \u2013 defaults to 5 Returns str : A table which explains the output. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w \u2013 defaults to 1.0 Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X Returns The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"LinearRegression"},{"location":"api/linear-model/LinearRegression/#linearregression","text":"Linear regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler .","title":"LinearRegression"},{"location":"api/linear-model/LinearRegression/#parameters","text":"optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.schedulers.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme.","title":"Parameters"},{"location":"api/linear-model/LinearRegression/#attributes","text":"weights ( dict ) The current weights.","title":"Attributes"},{"location":"api/linear-model/LinearRegression/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr =. 1 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.555971 >>> model [ 'LinearRegression' ] . intercept 35.617670 You can call the debug_one method to break down a prediction. This works even if the linear regression is part of a pipeline. >>> x , y = next ( iter ( dataset )) >>> report = model . debug_one ( x ) >>> print ( report ) 0. Input -------- gallup : 43.84321 ( float ) ipsos : 46.19925 ( float ) morning_consult : 48.31875 ( float ) ordinal_date : 736389 ( int ) rasmussen : 44.10469 ( float ) you_gov : 43.63691 ( float ) < BLANKLINE > 1. StandardScaler ----------------- gallup : 1.18810 ( float ) ipsos : 2.10348 ( float ) morning_consult : 2.73545 ( float ) ordinal_date : - 1.73032 ( float ) rasmussen : 1.26872 ( float ) you_gov : 1.48391 ( float ) < BLANKLINE > 2. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 35.61767 35.61767 ipsos 2.10348 0.62689 1.31866 morning_consult 2.73545 0.24180 0.66144 gallup 1.18810 0.43568 0.51764 rasmussen 1.26872 0.28118 0.35674 you_gov 1.48391 0.03123 0.04634 ordinal_date - 1.73032 3.45162 - 5.97242 < BLANKLINE > Prediction : 32.54607","title":"Examples"},{"location":"api/linear-model/LinearRegression/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the linear regression. Parameters x ( dict ) decimals \u2013 defaults to 5 Returns str : A table which explains the output. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w \u2013 defaults to 1.0 Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X Returns The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/linear-model/LogisticRegression/","text":"LogisticRegression \u00b6 Logistic regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler . Parameters \u00b6 optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept is handled separately. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. Defaults to optim.losses.Log . l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[float, optim.schedulers.Scheduler ] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Attributes \u00b6 weights The current weights. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer = optim . SGD ( . 1 )) ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.96 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"LogisticRegression"},{"location":"api/linear-model/LogisticRegression/#logisticregression","text":"Logistic regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler .","title":"LogisticRegression"},{"location":"api/linear-model/LogisticRegression/#parameters","text":"optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept is handled separately. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. Defaults to optim.losses.Log . l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[float, optim.schedulers.Scheduler ] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme.","title":"Parameters"},{"location":"api/linear-model/LogisticRegression/#attributes","text":"weights The current weights.","title":"Attributes"},{"location":"api/linear-model/LogisticRegression/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer = optim . SGD ( . 1 )) ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.96 %","title":"Examples"},{"location":"api/linear-model/LogisticRegression/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/PAClassifier/","text":"PAClassifier \u00b6 Passive-aggressive learning for classification. Parameters \u00b6 C \u2013 defaults to 1.0 mode \u2013 defaults to 1 learn_intercept \u2013 defaults to True Examples \u00b6 The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> from sklearn import model_selection >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_classification ( ... n_samples = 5000 , ... n_features = 4 , ... n_informative = 2 , ... n_redundant = 0 , ... n_repeated = 0 , ... n_classes = 2 , ... n_clusters_per_class = 2 ... ) >>> X_train , X_test , y_train , y_test = model_selection . train_test_split ( ... X , ... y , ... test_size = 0.35 , ... random_state = 1000 ... ) >>> model = linear_model . PAClassifier ( ... C = 0.01 , ... mode = 1 ... ) >>> for xi , yi in stream . iter_array ( X_train , y_train ): ... y_pred = model . learn_one ( xi , yi ) >>> metric = metrics . Accuracy () + metrics . LogLoss () >>> for xi , yi in stream . iter_array ( X_test , y_test ): ... metric = metric . update ( yi , model . predict_proba_one ( xi )) >>> print ( metric ) Accuracy : 88.46 % , LogLoss : 0.325727 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585 \u21a9","title":"PAClassifier"},{"location":"api/linear-model/PAClassifier/#paclassifier","text":"Passive-aggressive learning for classification.","title":"PAClassifier"},{"location":"api/linear-model/PAClassifier/#parameters","text":"C \u2013 defaults to 1.0 mode \u2013 defaults to 1 learn_intercept \u2013 defaults to True","title":"Parameters"},{"location":"api/linear-model/PAClassifier/#examples","text":"The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> from sklearn import model_selection >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_classification ( ... n_samples = 5000 , ... n_features = 4 , ... n_informative = 2 , ... n_redundant = 0 , ... n_repeated = 0 , ... n_classes = 2 , ... n_clusters_per_class = 2 ... ) >>> X_train , X_test , y_train , y_test = model_selection . train_test_split ( ... X , ... y , ... test_size = 0.35 , ... random_state = 1000 ... ) >>> model = linear_model . PAClassifier ( ... C = 0.01 , ... mode = 1 ... ) >>> for xi , yi in stream . iter_array ( X_train , y_train ): ... y_pred = model . learn_one ( xi , yi ) >>> metric = metrics . Accuracy () + metrics . LogLoss () >>> for xi , yi in stream . iter_array ( X_test , y_test ): ... metric = metric . update ( yi , model . predict_proba_one ( xi )) >>> print ( metric ) Accuracy : 88.46 % , LogLoss : 0.325727","title":"Examples"},{"location":"api/linear-model/PAClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/PAClassifier/#references","text":"Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585 \u21a9","title":"References"},{"location":"api/linear-model/PARegressor/","text":"PARegressor \u00b6 Passive-aggressive learning for regression. Parameters \u00b6 C \u2013 defaults to 1.0 mode \u2013 defaults to 1 eps \u2013 defaults to 0.1 learn_intercept \u2013 defaults to True Examples \u00b6 The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_regression ( n_samples = 500 , n_features = 4 ) >>> model = linear_model . PARegressor ( ... C = 0.01 , ... mode = 2 , ... eps = 0.1 , ... learn_intercept = False ... ) >>> metric = metrics . MAE () + metrics . MSE () >>> for xi , yi in stream . iter_array ( X , y ): ... y_pred = model . predict_one ( xi ) ... model = model . learn_one ( xi , yi ) ... metric = metric . update ( yi , y_pred ) >>> print ( metric ) MAE : 9.809402 , MSE : 472.393532 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585. \u21a9","title":"PARegressor"},{"location":"api/linear-model/PARegressor/#paregressor","text":"Passive-aggressive learning for regression.","title":"PARegressor"},{"location":"api/linear-model/PARegressor/#parameters","text":"C \u2013 defaults to 1.0 mode \u2013 defaults to 1 eps \u2013 defaults to 0.1 learn_intercept \u2013 defaults to True","title":"Parameters"},{"location":"api/linear-model/PARegressor/#examples","text":"The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_regression ( n_samples = 500 , n_features = 4 ) >>> model = linear_model . PARegressor ( ... C = 0.01 , ... mode = 2 , ... eps = 0.1 , ... learn_intercept = False ... ) >>> metric = metrics . MAE () + metrics . MSE () >>> for xi , yi in stream . iter_array ( X , y ): ... y_pred = model . predict_one ( xi ) ... model = model . learn_one ( xi , yi ) ... metric = metric . update ( yi , y_pred ) >>> print ( metric ) MAE : 9.809402 , MSE : 472.393532","title":"Examples"},{"location":"api/linear-model/PARegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/linear-model/PARegressor/#references","text":"Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585. \u21a9","title":"References"},{"location":"api/linear-model/Perceptron/","text":"Perceptron \u00b6 Perceptron classifier. In this implementation, the Perceptron is viewed as a special case of the logistic regression. The loss function that is used is the Hinge loss with a threshold set to 0, whilst the learning rate of the stochastic gradient descent procedure is set to 1 for both the weights and the intercept. Parameters \u00b6 l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. Attributes \u00b6 weights The current weights. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = pp . StandardScaler () | lm . Perceptron () >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 85.84 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Perceptron"},{"location":"api/linear-model/Perceptron/#perceptron","text":"Perceptron classifier. In this implementation, the Perceptron is viewed as a special case of the logistic regression. The loss function that is used is the Hinge loss with a threshold set to 0, whilst the learning rate of the stochastic gradient descent procedure is set to 1 for both the weights and the intercept.","title":"Perceptron"},{"location":"api/linear-model/Perceptron/#parameters","text":"l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme.","title":"Parameters"},{"location":"api/linear-model/Perceptron/#attributes","text":"weights The current weights.","title":"Attributes"},{"location":"api/linear-model/Perceptron/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = pp . StandardScaler () | lm . Perceptron () >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 85.84 %","title":"Examples"},{"location":"api/linear-model/Perceptron/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters --------- X A dataframe of features. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/SoftmaxRegression/","text":"SoftmaxRegression \u00b6 Softmax regression is a generalization of logistic regression to multiple classes. Softmax regression is also known as \"multinomial logistic regression\". There are a set weights for each class, hence the weights attribute is a nested collections.defaultdict . The main advantage of using this instead of a one-vs-all logistic regression is that the probabilities will be calibrated. Moreover softmax regression is more robust to outliers. Parameters \u00b6 optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used to tune the weights. loss ( optim.losses.MultiClassLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0 Amount of L2 regularization used to push weights towards 0. Attributes \u00b6 weights ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> model = preprocessing . StandardScaler () >>> model |= linear_model . SoftmaxRegression () >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.818765 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. References \u00b6 Course on classification stochastic gradient descent \u21a9 Binary vs. Multi-Class Logistic Regression \u21a9","title":"SoftmaxRegression"},{"location":"api/linear-model/SoftmaxRegression/#softmaxregression","text":"Softmax regression is a generalization of logistic regression to multiple classes. Softmax regression is also known as \"multinomial logistic regression\". There are a set weights for each class, hence the weights attribute is a nested collections.defaultdict . The main advantage of using this instead of a one-vs-all logistic regression is that the probabilities will be calibrated. Moreover softmax regression is more robust to outliers.","title":"SoftmaxRegression"},{"location":"api/linear-model/SoftmaxRegression/#parameters","text":"optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used to tune the weights. loss ( optim.losses.MultiClassLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0 Amount of L2 regularization used to push weights towards 0.","title":"Parameters"},{"location":"api/linear-model/SoftmaxRegression/#attributes","text":"weights ( collections.defaultdict )","title":"Attributes"},{"location":"api/linear-model/SoftmaxRegression/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> model = preprocessing . StandardScaler () >>> model |= linear_model . SoftmaxRegression () >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.818765","title":"Examples"},{"location":"api/linear-model/SoftmaxRegression/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/SoftmaxRegression/#references","text":"Course on classification stochastic gradient descent \u21a9 Binary vs. Multi-Class Logistic Regression \u21a9","title":"References"},{"location":"api/meta/BoxCoxRegressor/","text":"BoxCoxRegressor \u00b6 Applies the Box-Cox transform to the target before training. Box-Cox transform is useful when the target variable is heteroscedastic (i.e. there are sub-populations that have different variabilities from others) allowing to transform it towards normality. The power parameter is denoted \u03bb in the literature. If power is equal to 0 than the Box-Cox transform will be equivalent to a log transform. Parameters \u00b6 regressor ( base.Regressor ) Regression model to wrap. power \u2013 defaults to 1.0 power value to do the transformation. Examples \u00b6 >>> import math >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import meta >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... meta . BoxCoxRegressor ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.2 ), ... power = 0.05 ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 5.898196 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"BoxCoxRegressor"},{"location":"api/meta/BoxCoxRegressor/#boxcoxregressor","text":"Applies the Box-Cox transform to the target before training. Box-Cox transform is useful when the target variable is heteroscedastic (i.e. there are sub-populations that have different variabilities from others) allowing to transform it towards normality. The power parameter is denoted \u03bb in the literature. If power is equal to 0 than the Box-Cox transform will be equivalent to a log transform.","title":"BoxCoxRegressor"},{"location":"api/meta/BoxCoxRegressor/#parameters","text":"regressor ( base.Regressor ) Regression model to wrap. power \u2013 defaults to 1.0 power value to do the transformation.","title":"Parameters"},{"location":"api/meta/BoxCoxRegressor/#examples","text":">>> import math >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import meta >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... meta . BoxCoxRegressor ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.2 ), ... power = 0.05 ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 5.898196","title":"Examples"},{"location":"api/meta/BoxCoxRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/meta/PredClipper/","text":"PredClipper \u00b6 Clips the target after predicting. Parameters \u00b6 regressor ( base.Regressor ) Regressor model for which to clip the predictions. y_min ( float ) minimum value. y_max ( float ) maximum value. Examples \u00b6 >>> from river import linear_model >>> from river import meta >>> dataset = ( ... ({ 'a' : 2 , 'b' : 4 }, 80 ), ... ({ 'a' : 3 , 'b' : 5 }, 100 ), ... ({ 'a' : 4 , 'b' : 6 }, 120 ) ... ) >>> model = meta . PredClipper ( ... regressor = linear_model . LinearRegression (), ... y_min = 0 , ... y_max = 200 ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'a' : - 100 , 'b' : - 200 }) 0 >>> model . predict_one ({ 'a' : 50 , 'b' : 60 }) 200 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"PredClipper"},{"location":"api/meta/PredClipper/#predclipper","text":"Clips the target after predicting.","title":"PredClipper"},{"location":"api/meta/PredClipper/#parameters","text":"regressor ( base.Regressor ) Regressor model for which to clip the predictions. y_min ( float ) minimum value. y_max ( float ) maximum value.","title":"Parameters"},{"location":"api/meta/PredClipper/#examples","text":">>> from river import linear_model >>> from river import meta >>> dataset = ( ... ({ 'a' : 2 , 'b' : 4 }, 80 ), ... ({ 'a' : 3 , 'b' : 5 }, 100 ), ... ({ 'a' : 4 , 'b' : 6 }, 120 ) ... ) >>> model = meta . PredClipper ( ... regressor = linear_model . LinearRegression (), ... y_min = 0 , ... y_max = 200 ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'a' : - 100 , 'b' : - 200 }) 0 >>> model . predict_one ({ 'a' : 50 , 'b' : 60 }) 200","title":"Examples"},{"location":"api/meta/PredClipper/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/meta/TransformedTargetRegressor/","text":"TransformedTargetRegressor \u00b6 Modifies the target before training. The user is expected to check that func and inverse_func are coherent with each other. Parameters \u00b6 regressor ( base.Regressor ) Regression model to wrap. func ( ) A function modifying the target before training. inverse_func ( ) A function to return to the target's original space. Examples \u00b6 >>> import math >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import meta >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... meta . TransformedTargetRegressor ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.15 ), ... func = math . log , ... inverse_func = math . exp ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 8.759624 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"TransformedTargetRegressor"},{"location":"api/meta/TransformedTargetRegressor/#transformedtargetregressor","text":"Modifies the target before training. The user is expected to check that func and inverse_func are coherent with each other.","title":"TransformedTargetRegressor"},{"location":"api/meta/TransformedTargetRegressor/#parameters","text":"regressor ( base.Regressor ) Regression model to wrap. func ( ) A function modifying the target before training. inverse_func ( ) A function to return to the target's original space.","title":"Parameters"},{"location":"api/meta/TransformedTargetRegressor/#examples","text":">>> import math >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import meta >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... meta . TransformedTargetRegressor ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.15 ), ... func = math . log , ... inverse_func = math . exp ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 8.759624","title":"Examples"},{"location":"api/meta/TransformedTargetRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/metrics/Accuracy/","text":"Accuracy \u00b6 Accuracy score, which is the percentage of exact matches. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Accuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Accuracy : 60.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Accuracy"},{"location":"api/metrics/Accuracy/#accuracy","text":"Accuracy score, which is the percentage of exact matches.","title":"Accuracy"},{"location":"api/metrics/Accuracy/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/Accuracy/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/Accuracy/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Accuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Accuracy : 60.00 %","title":"Examples"},{"location":"api/metrics/Accuracy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/BalancedAccuracy/","text":"BalancedAccuracy \u00b6 Balanced accuracy. Balanced accuracy is the average of recall obtained on each class. It is used to deal with imbalanced datasets in binary and multi-class classification problems. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , False , True ] >>> y_pred = [ True , False , True , True , True , False ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 % >>> y_true = [ 0 , 1 , 0 , 0 , 1 , 0 ] >>> y_pred = [ 0 , 1 , 0 , 0 , 0 , 1 ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"BalancedAccuracy"},{"location":"api/metrics/BalancedAccuracy/#balancedaccuracy","text":"Balanced accuracy. Balanced accuracy is the average of recall obtained on each class. It is used to deal with imbalanced datasets in binary and multi-class classification problems.","title":"BalancedAccuracy"},{"location":"api/metrics/BalancedAccuracy/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/BalancedAccuracy/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/BalancedAccuracy/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , False , True ] >>> y_pred = [ True , False , True , True , True , False ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 % >>> y_true = [ 0 , 1 , 0 , 0 , 1 , 0 ] >>> y_pred = [ 0 , 1 , 0 , 0 , 0 , 1 ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 %","title":"Examples"},{"location":"api/metrics/BalancedAccuracy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/BinaryMetric/","text":"BinaryMetric \u00b6 Mother class for all binary classification metrics. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"BinaryMetric"},{"location":"api/metrics/BinaryMetric/#binarymetric","text":"Mother class for all binary classification metrics.","title":"BinaryMetric"},{"location":"api/metrics/BinaryMetric/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/BinaryMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/BinaryMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/ClassificationMetric/","text":"ClassificationMetric \u00b6 Mother class for all classification metrics. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ClassificationMetric"},{"location":"api/metrics/ClassificationMetric/#classificationmetric","text":"Mother class for all classification metrics.","title":"ClassificationMetric"},{"location":"api/metrics/ClassificationMetric/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ClassificationMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/ClassificationMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/ClassificationReport/","text":"ClassificationReport \u00b6 A report for monitoring a classifier. This class maintains a set of metrics and updates each of them every time update is called. You can print this class at any time during a model's lifetime to get a tabular visualization of various metrics. You can wrap a metrics.ClassificationReport with metrics.Rolling in order to obtain a classification report over a window of observations. You can also wrap it with metrics.TimeRolling to obtain a report over a period of time. Parameters \u00b6 decimals \u2013 defaults to 3 The number of decimals to display in each cell. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 'pear' , 'apple' , 'banana' , 'banana' , 'banana' ] >>> y_pred = [ 'apple' , 'pear' , 'banana' , 'banana' , 'apple' ] >>> report = metrics . ClassificationReport () >>> for yt , yp in zip ( y_true , y_pred ): ... report = report . update ( yt , yp ) >>> print ( report ) Precision Recall F1 Support < BLANKLINE > apple 0.000 0.000 0.000 1 banana 1.000 0.667 0.800 3 pear 0.000 0.000 0.000 1 < BLANKLINE > Macro 0.333 0.222 0.267 Micro 0.400 0.400 0.400 Weighted 0.600 0.400 0.480 < BLANKLINE > 40.0 % accuracy Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ClassificationReport"},{"location":"api/metrics/ClassificationReport/#classificationreport","text":"A report for monitoring a classifier. This class maintains a set of metrics and updates each of them every time update is called. You can print this class at any time during a model's lifetime to get a tabular visualization of various metrics. You can wrap a metrics.ClassificationReport with metrics.Rolling in order to obtain a classification report over a window of observations. You can also wrap it with metrics.TimeRolling to obtain a report over a period of time.","title":"ClassificationReport"},{"location":"api/metrics/ClassificationReport/#parameters","text":"decimals \u2013 defaults to 3 The number of decimals to display in each cell. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ClassificationReport/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/ClassificationReport/#examples","text":">>> from river import metrics >>> y_true = [ 'pear' , 'apple' , 'banana' , 'banana' , 'banana' ] >>> y_pred = [ 'apple' , 'pear' , 'banana' , 'banana' , 'apple' ] >>> report = metrics . ClassificationReport () >>> for yt , yp in zip ( y_true , y_pred ): ... report = report . update ( yt , yp ) >>> print ( report ) Precision Recall F1 Support < BLANKLINE > apple 0.000 0.000 0.000 1 banana 1.000 0.667 0.800 3 pear 0.000 0.000 0.000 1 < BLANKLINE > Macro 0.333 0.222 0.267 Micro 0.400 0.400 0.400 Weighted 0.600 0.400 0.480 < BLANKLINE > 40.0 % accuracy","title":"Examples"},{"location":"api/metrics/ClassificationReport/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/CohenKappa/","text":"CohenKappa \u00b6 Cohen's Kappa score. Cohen's Kappa expresses the level of agreement between two annotators on a classification problem. It is defined as \\[ \\kappa = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the expected agreement when both annotators assign labels randomly. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> metric = metrics . CohenKappa () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric CohenKappa : 0.428571 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 J. Cohen (1960). \"A coefficient of agreement for nominal scales\". Educational and Psychological Measurement 20(1):37-46. doi:10.1177/001316446002000104. \u21a9","title":"CohenKappa"},{"location":"api/metrics/CohenKappa/#cohenkappa","text":"Cohen's Kappa score. Cohen's Kappa expresses the level of agreement between two annotators on a classification problem. It is defined as \\[ \\kappa = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the expected agreement when both annotators assign labels randomly.","title":"CohenKappa"},{"location":"api/metrics/CohenKappa/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/CohenKappa/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/CohenKappa/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> metric = metrics . CohenKappa () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric CohenKappa : 0.428571","title":"Examples"},{"location":"api/metrics/CohenKappa/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/CohenKappa/#references","text":"J. Cohen (1960). \"A coefficient of agreement for nominal scales\". Educational and Psychological Measurement 20(1):37-46. doi:10.1177/001316446002000104. \u21a9","title":"References"},{"location":"api/metrics/ConfusionMatrix/","text":"ConfusionMatrix \u00b6 ConfusionMatrix(classes=None) Confusion Matrix for binary-class and multi-class classification. Attributes \u00b6 classes data last_y_pred last_y_true majority_class n_classes n_samples sample_correction shape sum_col sum_diag sum_row total_weight weight_majority_classifier weight_no_change_classifier Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> cm = metrics . ConfusionMatrix () >>> for yt , yp in zip ( y_true , y_pred ): ... cm = cm . update ( yt , yp ) >>> cm ant bird cat ant 2 0 0 bird 0 0 1 cat 1 0 2 >>> cm [ 'bird' ][ 'cat' ] 1.0 Methods \u00b6 false_negatives Parameters label false_positives Parameters label reset revert Parameters y_true y_pred sample_weight correction true_negatives Parameters label true_positives Parameters label update Parameters y_true y_pred sample_weight Notes \u00b6 This confusion matrix is a 2D matrix of shape `(n_classes, n_classes)`, corresponding to a single-target (binary and multi-class) classification task. Each row represents `true` (actual) class-labels, while each column corresponds to the `predicted` class-labels. For example, an entry in position `[1, 2]` means that the true class-label is 1, and the predicted class-label is 2 (incorrect prediction). This structure is used to keep updated statistics about a single-output classifier's performance and to compute multiple evaluation metrics.","title":"ConfusionMatrix"},{"location":"api/metrics/ConfusionMatrix/#confusionmatrix","text":"ConfusionMatrix(classes=None) Confusion Matrix for binary-class and multi-class classification.","title":"ConfusionMatrix"},{"location":"api/metrics/ConfusionMatrix/#attributes","text":"classes data last_y_pred last_y_true majority_class n_classes n_samples sample_correction shape sum_col sum_diag sum_row total_weight weight_majority_classifier weight_no_change_classifier","title":"Attributes"},{"location":"api/metrics/ConfusionMatrix/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> cm = metrics . ConfusionMatrix () >>> for yt , yp in zip ( y_true , y_pred ): ... cm = cm . update ( yt , yp ) >>> cm ant bird cat ant 2 0 0 bird 0 0 1 cat 1 0 2 >>> cm [ 'bird' ][ 'cat' ] 1.0","title":"Examples"},{"location":"api/metrics/ConfusionMatrix/#methods","text":"false_negatives Parameters label false_positives Parameters label reset revert Parameters y_true y_pred sample_weight correction true_negatives Parameters label true_positives Parameters label update Parameters y_true y_pred sample_weight","title":"Methods"},{"location":"api/metrics/ConfusionMatrix/#notes","text":"This confusion matrix is a 2D matrix of shape `(n_classes, n_classes)`, corresponding to a single-target (binary and multi-class) classification task. Each row represents `true` (actual) class-labels, while each column corresponds to the `predicted` class-labels. For example, an entry in position `[1, 2]` means that the true class-label is 1, and the predicted class-label is 2 (incorrect prediction). This structure is used to keep updated statistics about a single-output classifier's performance and to compute multiple evaluation metrics.","title":"Notes"},{"location":"api/metrics/CrossEntropy/","text":"CrossEntropy \u00b6 Multiclass generalization of the logarithmic loss. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> metric = metrics . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 1.222454 1.169691 1.258864 1.321597 >>> metric CrossEntropy : 1.321598 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"CrossEntropy"},{"location":"api/metrics/CrossEntropy/#crossentropy","text":"Multiclass generalization of the logarithmic loss.","title":"CrossEntropy"},{"location":"api/metrics/CrossEntropy/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/CrossEntropy/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> metric = metrics . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 1.222454 1.169691 1.258864 1.321597 >>> metric CrossEntropy : 1.321598","title":"Examples"},{"location":"api/metrics/CrossEntropy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/ExactMatch/","text":"ExactMatch \u00b6 Exact match score. This is the most strict multi-label metric, defined as the number of samples that have all their labels correctly classified, divided by the total number of samples. Parameters \u00b6 cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExactMatch () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExactMatch : 0.333333 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ExactMatch"},{"location":"api/metrics/ExactMatch/#exactmatch","text":"Exact match score. This is the most strict multi-label metric, defined as the number of samples that have all their labels correctly classified, divided by the total number of samples.","title":"ExactMatch"},{"location":"api/metrics/ExactMatch/#parameters","text":"cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ExactMatch/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction","title":"Attributes"},{"location":"api/metrics/ExactMatch/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExactMatch () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExactMatch : 0.333333","title":"Examples"},{"location":"api/metrics/ExactMatch/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/ExampleF1/","text":"ExampleF1 \u00b6 Example-based F1 score for multilabel classification. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExampleF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExampleF1 : 0.860215 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ExampleF1"},{"location":"api/metrics/ExampleF1/#examplef1","text":"Example-based F1 score for multilabel classification.","title":"ExampleF1"},{"location":"api/metrics/ExampleF1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ExampleF1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction","title":"Attributes"},{"location":"api/metrics/ExampleF1/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExampleF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExampleF1 : 0.860215","title":"Examples"},{"location":"api/metrics/ExampleF1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/ExampleFBeta/","text":"ExampleFBeta \u00b6 Example-based F-Beta score. Parameters \u00b6 beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 precision ( metrics.ExamplePrecision ) recall ( metrics.ExampleRecall ) Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExampleFBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExampleFBeta : 0.843882 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ExampleFBeta"},{"location":"api/metrics/ExampleFBeta/#examplefbeta","text":"Example-based F-Beta score.","title":"ExampleFBeta"},{"location":"api/metrics/ExampleFBeta/#parameters","text":"beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ExampleFBeta/#attributes","text":"precision ( metrics.ExamplePrecision ) recall ( metrics.ExampleRecall )","title":"Attributes"},{"location":"api/metrics/ExampleFBeta/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExampleFBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExampleFBeta : 0.843882","title":"Examples"},{"location":"api/metrics/ExampleFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/ExamplePrecision/","text":"ExamplePrecision \u00b6 Example-based precision score for multilabel classification. Parameters \u00b6 cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExamplePrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExamplePrecision : 0.888889 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ExamplePrecision"},{"location":"api/metrics/ExamplePrecision/#exampleprecision","text":"Example-based precision score for multilabel classification.","title":"ExamplePrecision"},{"location":"api/metrics/ExamplePrecision/#parameters","text":"cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ExamplePrecision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction","title":"Attributes"},{"location":"api/metrics/ExamplePrecision/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExamplePrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExamplePrecision : 0.888889","title":"Examples"},{"location":"api/metrics/ExamplePrecision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/ExampleRecall/","text":"ExampleRecall \u00b6 Example-based recall score for multilabel classification. Parameters \u00b6 cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExampleRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExampleRecall : 0.833333 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ExampleRecall"},{"location":"api/metrics/ExampleRecall/#examplerecall","text":"Example-based recall score for multilabel classification.","title":"ExampleRecall"},{"location":"api/metrics/ExampleRecall/#parameters","text":"cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ExampleRecall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction","title":"Attributes"},{"location":"api/metrics/ExampleRecall/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . ExampleRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExampleRecall : 0.833333","title":"Examples"},{"location":"api/metrics/ExampleRecall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/F1/","text":"F1 \u00b6 Binary F1 score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . F1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric F1 : 0.4 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"F1"},{"location":"api/metrics/F1/#f1","text":"Binary F1 score.","title":"F1"},{"location":"api/metrics/F1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/F1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/F1/#examples","text":">>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . F1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric F1 : 0.4","title":"Examples"},{"location":"api/metrics/F1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/FBeta/","text":"FBeta \u00b6 Binary F-Beta score. The FBeta score is a weighted harmonic mean between precision and recall. The higher the beta value, the higher the recall will be taken into account. When beta equals 1, precision and recall and equivalently weighted, which results in the F1 score (see metrics.F1 ). Parameters \u00b6 beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 precision ( metrics.Precision ) recall ( metrics.Recall ) Examples \u00b6 >>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . FBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric FBeta : 0.357143 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"FBeta"},{"location":"api/metrics/FBeta/#fbeta","text":"Binary F-Beta score. The FBeta score is a weighted harmonic mean between precision and recall. The higher the beta value, the higher the recall will be taken into account. When beta equals 1, precision and recall and equivalently weighted, which results in the F1 score (see metrics.F1 ).","title":"FBeta"},{"location":"api/metrics/FBeta/#parameters","text":"beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/FBeta/#attributes","text":"precision ( metrics.Precision ) recall ( metrics.Recall )","title":"Attributes"},{"location":"api/metrics/FBeta/#examples","text":">>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . FBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric FBeta : 0.357143","title":"Examples"},{"location":"api/metrics/FBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/GeometricMean/","text":"GeometricMean \u00b6 Geometric mean score. The geometric mean is a good indicator of a classifier's performance in the presence of class imbalance because it is independent of the distribution of examples between classes. This implementation computes the geometric mean of class-wise sensitivity (recall). \\[ gm = \\sqrt[n]{s_1\\cdot s_2\\cdot s_3\\cdot \\ldots\\cdot s_n} \\] where \\(s_i\\) is the sensitivity (recall) of class \\(i\\) and \\(n\\) is the number of classes. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' , 'bird' ] >>> metric = metrics . GeometricMean () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric GeometricMean : 0.693361 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Barandela, R. et al. \u201cStrategies for learning in class imbalance problems\u201d, Pattern Recognition, 36(3), (2003), pp 849-851. \u21a9","title":"GeometricMean"},{"location":"api/metrics/GeometricMean/#geometricmean","text":"Geometric mean score. The geometric mean is a good indicator of a classifier's performance in the presence of class imbalance because it is independent of the distribution of examples between classes. This implementation computes the geometric mean of class-wise sensitivity (recall). \\[ gm = \\sqrt[n]{s_1\\cdot s_2\\cdot s_3\\cdot \\ldots\\cdot s_n} \\] where \\(s_i\\) is the sensitivity (recall) of class \\(i\\) and \\(n\\) is the number of classes.","title":"GeometricMean"},{"location":"api/metrics/GeometricMean/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/GeometricMean/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/GeometricMean/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' , 'bird' ] >>> metric = metrics . GeometricMean () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric GeometricMean : 0.693361","title":"Examples"},{"location":"api/metrics/GeometricMean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/GeometricMean/#references","text":"Barandela, R. et al. \u201cStrategies for learning in class imbalance problems\u201d, Pattern Recognition, 36(3), (2003), pp 849-851. \u21a9","title":"References"},{"location":"api/metrics/Hamming/","text":"Hamming \u00b6 Hamming score. The Hamming score is the fraction of labels that are correctly predicted. Parameters \u00b6 cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . Hamming () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Hamming : 0.555556 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Hamming"},{"location":"api/metrics/Hamming/#hamming","text":"Hamming score. The Hamming score is the fraction of labels that are correctly predicted.","title":"Hamming"},{"location":"api/metrics/Hamming/#parameters","text":"cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/Hamming/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction","title":"Attributes"},{"location":"api/metrics/Hamming/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . Hamming () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Hamming : 0.555556","title":"Examples"},{"location":"api/metrics/Hamming/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/HammingLoss/","text":"HammingLoss \u00b6 Hamming loss score. The Hamming loss is the complement of the Hamming score. Parameters \u00b6 cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . HammingLoss () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric HammingLoss : 0.444444 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"HammingLoss"},{"location":"api/metrics/HammingLoss/#hammingloss","text":"Hamming loss score. The Hamming loss is the complement of the Hamming score.","title":"HammingLoss"},{"location":"api/metrics/HammingLoss/#parameters","text":"cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/HammingLoss/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction","title":"Attributes"},{"location":"api/metrics/HammingLoss/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . HammingLoss () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric HammingLoss : 0.444444","title":"Examples"},{"location":"api/metrics/HammingLoss/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Jaccard/","text":"Jaccard \u00b6 Jaccard index for binary multi-outputs. The Jaccard index, or Jaccard similarity coefficient, defined as the size of the intersection divided by the size of the union of two label sets, is used to compare the set of predicted labels for a sample with the corresponding set of labels in y_true . The Jaccard index may be a poor metric if there are no positives for some samples or labels. The Jaccard index is undefined if there are no true or predicted labels, this implementation will return a score of 0.0 if this is the case. Parameters \u00b6 cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... ] >>> jac = metrics . Jaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... jac = jac . update ( yt , yp ) >>> jac Jaccard : 0.583333 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia section on similarity of asymmetric binary attributes \u21a9","title":"Jaccard"},{"location":"api/metrics/Jaccard/#jaccard","text":"Jaccard index for binary multi-outputs. The Jaccard index, or Jaccard similarity coefficient, defined as the size of the intersection divided by the size of the union of two label sets, is used to compare the set of predicted labels for a sample with the corresponding set of labels in y_true . The Jaccard index may be a poor metric if there are no positives for some samples or labels. The Jaccard index is undefined if there are no true or predicted labels, this implementation will return a score of 0.0 if this is the case.","title":"Jaccard"},{"location":"api/metrics/Jaccard/#parameters","text":"cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/Jaccard/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels sample_correction","title":"Attributes"},{"location":"api/metrics/Jaccard/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... ] >>> jac = metrics . Jaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... jac = jac . update ( yt , yp ) >>> jac Jaccard : 0.583333","title":"Examples"},{"location":"api/metrics/Jaccard/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Jaccard/#references","text":"Wikipedia section on similarity of asymmetric binary attributes \u21a9","title":"References"},{"location":"api/metrics/KappaM/","text":"KappaM \u00b6 Kappa-M score. The Kappa-M statistic compares performance with the majority class classifier. It is defined as \\[ \\kappa_{m} = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the prequential accuracy of the majority classifier . Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' , 'cat' , 'ant' , 'cat' , 'cat' , 'ant' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' , 'ant' , 'ant' , 'cat' , 'cat' , 'ant' ] >>> metric = metrics . KappaM () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric KappaM : 0.25 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 [1^]: A. Bifet et al. \"Efficient online evaluation of big data stream classifiers.\" In Proceedings of the 21th ACM SIGKDD international conference on knowledge discovery and data mining, pp. 59-68. ACM, 2015.","title":"KappaM"},{"location":"api/metrics/KappaM/#kappam","text":"Kappa-M score. The Kappa-M statistic compares performance with the majority class classifier. It is defined as \\[ \\kappa_{m} = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the prequential accuracy of the majority classifier .","title":"KappaM"},{"location":"api/metrics/KappaM/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/KappaM/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/KappaM/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' , 'cat' , 'ant' , 'cat' , 'cat' , 'ant' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' , 'ant' , 'ant' , 'cat' , 'cat' , 'ant' ] >>> metric = metrics . KappaM () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric KappaM : 0.25","title":"Examples"},{"location":"api/metrics/KappaM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/KappaM/#references","text":"[1^]: A. Bifet et al. \"Efficient online evaluation of big data stream classifiers.\" In Proceedings of the 21th ACM SIGKDD international conference on knowledge discovery and data mining, pp. 59-68. ACM, 2015.","title":"References"},{"location":"api/metrics/KappaT/","text":"KappaT \u00b6 Kappa-T score. The Kappa-T measures the temporal correlation between samples. It is defined as \\[ \\kappa_{t} = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the prequential accuracy of the no-change classifier that predicts only using the last class seen by the classifier. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> metric = metrics . KappaT () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric KappaT : 0.6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 A. Bifet et al. (2013). \"Pitfalls in benchmarking data stream classification and how to avoid them.\" Proc. of the European Conference on Machine Learning and Principles and Practice of Knowledge Discovery in Databases (ECMLPKDD'13), Springer LNAI 8188, p. 465-479. \u21a9","title":"KappaT"},{"location":"api/metrics/KappaT/#kappat","text":"Kappa-T score. The Kappa-T measures the temporal correlation between samples. It is defined as \\[ \\kappa_{t} = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the prequential accuracy of the no-change classifier that predicts only using the last class seen by the classifier.","title":"KappaT"},{"location":"api/metrics/KappaT/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/KappaT/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/KappaT/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> metric = metrics . KappaT () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric KappaT : 0.6","title":"Examples"},{"location":"api/metrics/KappaT/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/KappaT/#references","text":"A. Bifet et al. (2013). \"Pitfalls in benchmarking data stream classification and how to avoid them.\" Proc. of the European Conference on Machine Learning and Principles and Practice of Knowledge Discovery in Databases (ECMLPKDD'13), Springer LNAI 8188, p. 465-479. \u21a9","title":"References"},{"location":"api/metrics/LogLoss/","text":"LogLoss \u00b6 Binary logarithmic loss. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , False , True ] >>> y_pred = [ 0.9 , 0.1 , 0.2 , 0.65 ] >>> metric = metrics . LogLoss () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 0.105360 0.105360 0.144621 0.216161 >>> metric LogLoss : 0.216162 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"LogLoss"},{"location":"api/metrics/LogLoss/#logloss","text":"Binary logarithmic loss.","title":"LogLoss"},{"location":"api/metrics/LogLoss/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/LogLoss/#examples","text":">>> from river import metrics >>> y_true = [ True , False , False , True ] >>> y_pred = [ 0.9 , 0.1 , 0.2 , 0.65 ] >>> metric = metrics . LogLoss () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 0.105360 0.105360 0.144621 0.216161 >>> metric LogLoss : 0.216162","title":"Examples"},{"location":"api/metrics/LogLoss/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/MAE/","text":"MAE \u00b6 Mean absolute error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MAE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.333 0.5 >>> metric MAE : 0.5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"MAE"},{"location":"api/metrics/MAE/#mae","text":"Mean absolute error.","title":"MAE"},{"location":"api/metrics/MAE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/MAE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MAE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.333 0.5 >>> metric MAE : 0.5","title":"Examples"},{"location":"api/metrics/MAE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/MCC/","text":"MCC \u00b6 Matthews correlation coefficient. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ True , True , True , False ] >>> y_pred = [ True , False , True , True ] >>> mcc = metrics . MCC () >>> for yt , yp in zip ( y_true , y_pred ): ... mcc = mcc . update ( yt , yp ) >>> mcc MCC : - 0.333333 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia article \u21a9","title":"MCC"},{"location":"api/metrics/MCC/#mcc","text":"Matthews correlation coefficient.","title":"MCC"},{"location":"api/metrics/MCC/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/MCC/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MCC/#examples","text":">>> from river import metrics >>> y_true = [ True , True , True , False ] >>> y_pred = [ True , False , True , True ] >>> mcc = metrics . MCC () >>> for yt , yp in zip ( y_true , y_pred ): ... mcc = mcc . update ( yt , yp ) >>> mcc MCC : - 0.333333","title":"Examples"},{"location":"api/metrics/MCC/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MCC/#references","text":"Wikipedia article \u21a9","title":"References"},{"location":"api/metrics/MSE/","text":"MSE \u00b6 Mean squared error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.25 0.25 0.1666 0.375 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"MSE"},{"location":"api/metrics/MSE/#mse","text":"Mean squared error.","title":"MSE"},{"location":"api/metrics/MSE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/MSE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.25 0.25 0.1666 0.375","title":"Examples"},{"location":"api/metrics/MSE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/MacroF1/","text":"MacroF1 \u00b6 Macro-average F1 score. This works by computing the F1 score per class, and then performs a global average. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroF1 : 1. MacroF1 : 0.333333 MacroF1 : 0.555556 MacroF1 : 0.555556 MacroF1 : 0.488889 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroF1"},{"location":"api/metrics/MacroF1/#macrof1","text":"Macro-average F1 score. This works by computing the F1 score per class, and then performs a global average.","title":"MacroF1"},{"location":"api/metrics/MacroF1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroF1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MacroF1/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroF1 : 1. MacroF1 : 0.333333 MacroF1 : 0.555556 MacroF1 : 0.555556 MacroF1 : 0.488889","title":"Examples"},{"location":"api/metrics/MacroF1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MacroFBeta/","text":"MacroFBeta \u00b6 Macro-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global average. Parameters \u00b6 beta Weight of precision in harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroFBeta ( beta =. 8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroFBeta : 1. MacroFBeta : 0.310606 MacroFBeta : 0.540404 MacroFBeta : 0.540404 MacroFBeta : 0.485982 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroFBeta"},{"location":"api/metrics/MacroFBeta/#macrofbeta","text":"Macro-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global average.","title":"MacroFBeta"},{"location":"api/metrics/MacroFBeta/#parameters","text":"beta Weight of precision in harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MacroFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroFBeta ( beta =. 8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroFBeta : 1. MacroFBeta : 0.310606 MacroFBeta : 0.540404 MacroFBeta : 0.540404 MacroFBeta : 0.485982","title":"Examples"},{"location":"api/metrics/MacroFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MacroPrecision/","text":"MacroPrecision \u00b6 Macro-average precision score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroPrecision : 1. MacroPrecision : 0.25 MacroPrecision : 0.5 MacroPrecision : 0.5 MacroPrecision : 0.5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroPrecision"},{"location":"api/metrics/MacroPrecision/#macroprecision","text":"Macro-average precision score.","title":"MacroPrecision"},{"location":"api/metrics/MacroPrecision/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroPrecision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MacroPrecision/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroPrecision : 1. MacroPrecision : 0.25 MacroPrecision : 0.5 MacroPrecision : 0.5 MacroPrecision : 0.5","title":"Examples"},{"location":"api/metrics/MacroPrecision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MacroRecall/","text":"MacroRecall \u00b6 Macro-average recall score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroRecall : 1. MacroRecall : 0.5 MacroRecall : 0.666667 MacroRecall : 0.666667 MacroRecall : 0.555556 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroRecall"},{"location":"api/metrics/MacroRecall/#macrorecall","text":"Macro-average recall score.","title":"MacroRecall"},{"location":"api/metrics/MacroRecall/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroRecall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MacroRecall/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroRecall : 1. MacroRecall : 0.5 MacroRecall : 0.666667 MacroRecall : 0.666667 MacroRecall : 0.555556","title":"Examples"},{"location":"api/metrics/MacroRecall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Metric/","text":"Metric \u00b6 Mother class for all metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Metric"},{"location":"api/metrics/Metric/#metric","text":"Mother class for all metrics.","title":"Metric"},{"location":"api/metrics/Metric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/Metric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Metrics/","text":"Metrics \u00b6 A container class for handling multiple metrics at once. Parameters \u00b6 metrics str_sep \u2013 defaults to , Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get Return the current value of the metric. index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 sort update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Metrics"},{"location":"api/metrics/Metrics/#metrics","text":"A container class for handling multiple metrics at once.","title":"Metrics"},{"location":"api/metrics/Metrics/#parameters","text":"metrics str_sep \u2013 defaults to ,","title":"Parameters"},{"location":"api/metrics/Metrics/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels","title":"Attributes"},{"location":"api/metrics/Metrics/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get Return the current value of the metric. index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 sort update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroF1/","text":"MicroF1 \u00b6 Micro-average F1 score. This computes the F1 score by merging all the predictions and true labels, and then computes a global F1 score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroF1 : 0.6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"MicroF1"},{"location":"api/metrics/MicroF1/#microf1","text":"Micro-average F1 score. This computes the F1 score by merging all the predictions and true labels, and then computes a global F1 score.","title":"MicroF1"},{"location":"api/metrics/MicroF1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroF1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MicroF1/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroF1 : 0.6","title":"Examples"},{"location":"api/metrics/MicroF1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroF1/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"References"},{"location":"api/metrics/MicroFBeta/","text":"MicroFBeta \u00b6 Micro-average F-Beta score. This computes the F-Beta score by merging all the predictions and true labels, and then computes a global F-Beta score. Parameters \u00b6 beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroFBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroFBeta : 0.6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem?","title":"MicroFBeta"},{"location":"api/metrics/MicroFBeta/#microfbeta","text":"Micro-average F-Beta score. This computes the F-Beta score by merging all the predictions and true labels, and then computes a global F-Beta score.","title":"MicroFBeta"},{"location":"api/metrics/MicroFBeta/#parameters","text":"beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MicroFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroFBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroFBeta : 0.6","title":"Examples"},{"location":"api/metrics/MicroFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroFBeta/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem?","title":"References"},{"location":"api/metrics/MicroPrecision/","text":"MicroPrecision \u00b6 Micro-average precision score. The micro-average precision score is exactly equivalent to the micro-average recall as well as the micro-average F1 score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroPrecision : 1. MicroPrecision : 0.5 MicroPrecision : 0.666667 MicroPrecision : 0.75 MicroPrecision : 0.6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"MicroPrecision"},{"location":"api/metrics/MicroPrecision/#microprecision","text":"Micro-average precision score. The micro-average precision score is exactly equivalent to the micro-average recall as well as the micro-average F1 score.","title":"MicroPrecision"},{"location":"api/metrics/MicroPrecision/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroPrecision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MicroPrecision/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroPrecision : 1. MicroPrecision : 0.5 MicroPrecision : 0.666667 MicroPrecision : 0.75 MicroPrecision : 0.6","title":"Examples"},{"location":"api/metrics/MicroPrecision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroPrecision/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"References"},{"location":"api/metrics/MicroRecall/","text":"MicroRecall \u00b6 Micro-average recall score. The micro-average recall is exactly equivalent to the micro-average precision as well as the micro-average F1 score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroRecall : 1. MicroRecall : 0.5 MicroRecall : 0.666667 MicroRecall : 0.75 MicroRecall : 0.6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"MicroRecall"},{"location":"api/metrics/MicroRecall/#microrecall","text":"Micro-average recall score. The micro-average recall is exactly equivalent to the micro-average precision as well as the micro-average F1 score.","title":"MicroRecall"},{"location":"api/metrics/MicroRecall/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroRecall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MicroRecall/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroRecall : 1. MicroRecall : 0.5 MicroRecall : 0.666667 MicroRecall : 0.75 MicroRecall : 0.6","title":"Examples"},{"location":"api/metrics/MicroRecall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroRecall/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"References"},{"location":"api/metrics/MultiClassMetric/","text":"MultiClassMetric \u00b6 Mother class for all multi-class classification metrics. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiClassMetric"},{"location":"api/metrics/MultiClassMetric/#multiclassmetric","text":"Mother class for all multi-class classification metrics.","title":"MultiClassMetric"},{"location":"api/metrics/MultiClassMetric/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MultiClassMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MultiClassMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MultiFBeta/","text":"MultiFBeta \u00b6 Multi-class F-Beta score with different betas per class. The multiclass F-Beta score is the arithmetic average of the binary F-Beta scores of each class. The mean can be weighted by providing class weights. Parameters \u00b6 betas Weight of precision in the harmonic mean of each class. weights Class weights. If not provided then uniform weights will be used. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MultiFBeta ( ... betas = { 0 : 0.25 , 1 : 1 , 2 : 4 }, ... weights = { 0 : 1 , 1 : 1 , 2 : 2 } ... ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MultiFBeta : 1. MultiFBeta : 0.257576 MultiFBeta : 0.628788 MultiFBeta : 0.628788 MultiFBeta : 0.468788 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiFBeta"},{"location":"api/metrics/MultiFBeta/#multifbeta","text":"Multi-class F-Beta score with different betas per class. The multiclass F-Beta score is the arithmetic average of the binary F-Beta scores of each class. The mean can be weighted by providing class weights.","title":"MultiFBeta"},{"location":"api/metrics/MultiFBeta/#parameters","text":"betas Weight of precision in the harmonic mean of each class. weights Class weights. If not provided then uniform weights will be used. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MultiFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/MultiFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MultiFBeta ( ... betas = { 0 : 0.25 , 1 : 1 , 2 : 4 }, ... weights = { 0 : 1 , 1 : 1 , 2 : 2 } ... ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MultiFBeta : 1. MultiFBeta : 0.257576 MultiFBeta : 0.628788 MultiFBeta : 0.628788 MultiFBeta : 0.468788","title":"Examples"},{"location":"api/metrics/MultiFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MultiLabelConfusionMatrix/","text":"MultiLabelConfusionMatrix \u00b6 MultiLabelConfusionMatrix(labels=None) Multi-label Confusion Matrix. Attributes \u00b6 data exact_match_cnt jaccard_sum labels last_y_pred last_y_true n_labels n_samples precision_sum recall_sum sample_correction shape Methods \u00b6 reset revert Parameters y_true y_pred sample_weight correction update Parameters y_true y_pred sample_weight Notes \u00b6 This confusion matrix corresponds to a 3D matrix of shape `(n_labels, 2, 2)` meaning that each `label` has a corresponding binary `(2x2)` confusion matrix. The first dimension corresponds to the `label`, the second and third dimensions are binary indicators for the `true` (actual) vs `predicted` values. For example, an entry in position `[2, 0, 1]` represents a miss-classification of label 2. This structure is used to keep updated statistics about a multi-output classifier's performance and to compute multiple evaluation metrics.","title":"MultiLabelConfusionMatrix"},{"location":"api/metrics/MultiLabelConfusionMatrix/#multilabelconfusionmatrix","text":"MultiLabelConfusionMatrix(labels=None) Multi-label Confusion Matrix.","title":"MultiLabelConfusionMatrix"},{"location":"api/metrics/MultiLabelConfusionMatrix/#attributes","text":"data exact_match_cnt jaccard_sum labels last_y_pred last_y_true n_labels n_samples precision_sum recall_sum sample_correction shape","title":"Attributes"},{"location":"api/metrics/MultiLabelConfusionMatrix/#methods","text":"reset revert Parameters y_true y_pred sample_weight correction update Parameters y_true y_pred sample_weight","title":"Methods"},{"location":"api/metrics/MultiLabelConfusionMatrix/#notes","text":"This confusion matrix corresponds to a 3D matrix of shape `(n_labels, 2, 2)` meaning that each `label` has a corresponding binary `(2x2)` confusion matrix. The first dimension corresponds to the `label`, the second and third dimensions are binary indicators for the `true` (actual) vs `predicted` values. For example, an entry in position `[2, 0, 1]` represents a miss-classification of label 2. This structure is used to keep updated statistics about a multi-output classifier's performance and to compute multiple evaluation metrics.","title":"Notes"},{"location":"api/metrics/MultiOutputClassificationMetric/","text":"MultiOutputClassificationMetric \u00b6 Mother class for all multi-output classification metrics. Parameters \u00b6 cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. sample_correction Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiOutputClassificationMetric"},{"location":"api/metrics/MultiOutputClassificationMetric/#multioutputclassificationmetric","text":"Mother class for all multi-output classification metrics.","title":"MultiOutputClassificationMetric"},{"location":"api/metrics/MultiOutputClassificationMetric/#parameters","text":"cm ( river.metrics.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MultiOutputClassificationMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. sample_correction","title":"Attributes"},{"location":"api/metrics/MultiOutputClassificationMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MultiOutputRegressionMetric/","text":"MultiOutputRegressionMetric \u00b6 Mother class for all multi-output regression metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiOutputRegressionMetric"},{"location":"api/metrics/MultiOutputRegressionMetric/#multioutputregressionmetric","text":"Mother class for all multi-output regression metrics.","title":"MultiOutputRegressionMetric"},{"location":"api/metrics/MultiOutputRegressionMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/MultiOutputRegressionMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Precision/","text":"Precision \u00b6 Binary precision score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Precision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Precision : 1. Precision : 0.5 Precision : 0.5 Precision : 0.666667 Precision : 0.75 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Precision"},{"location":"api/metrics/Precision/#precision","text":"Binary precision score.","title":"Precision"},{"location":"api/metrics/Precision/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/Precision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/Precision/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Precision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Precision : 1. Precision : 0.5 Precision : 0.5 Precision : 0.666667 Precision : 0.75","title":"Examples"},{"location":"api/metrics/Precision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/R2/","text":"R2 \u00b6 Coefficient of determination ( \\(R^2\\) ) score The coefficient of determination, denoted \\(R^2\\) or \\(r^2\\) , is the proportion of the variance in the dependent variable that is predictable from the independent variable(s). 1 Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of \\(y\\) , disregarding the input features, would get a \\(R^2\\) score of 0.0. \\(R^2\\) is not defined when less than 2 samples have been observed. This implementation returns 0.0 in this case. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . R2 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.0 0.9183 0.9230 0.9486 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) correction \u2013 defaults to None update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Coefficient of determination (Wikipedia) \u21a9","title":"R2"},{"location":"api/metrics/R2/#r2","text":"Coefficient of determination ( \\(R^2\\) ) score The coefficient of determination, denoted \\(R^2\\) or \\(r^2\\) , is the proportion of the variance in the dependent variable that is predictable from the independent variable(s). 1 Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of \\(y\\) , disregarding the input features, would get a \\(R^2\\) score of 0.0. \\(R^2\\) is not defined when less than 2 samples have been observed. This implementation returns 0.0 in this case.","title":"R2"},{"location":"api/metrics/R2/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/R2/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . R2 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.0 0.9183 0.9230 0.9486","title":"Examples"},{"location":"api/metrics/R2/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) correction \u2013 defaults to None update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/R2/#references","text":"Coefficient of determination (Wikipedia) \u21a9","title":"References"},{"location":"api/metrics/RMSE/","text":"RMSE \u00b6 Root mean squared error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.408248 0.612372 >>> metric RMSE : 0.612372 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"RMSE"},{"location":"api/metrics/RMSE/#rmse","text":"Root mean squared error.","title":"RMSE"},{"location":"api/metrics/RMSE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/RMSE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.408248 0.612372 >>> metric RMSE : 0.612372","title":"Examples"},{"location":"api/metrics/RMSE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/RMSLE/","text":"RMSLE \u00b6 Root mean squared logarithmic error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSLE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric RMSLE : 0.357826 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"RMSLE"},{"location":"api/metrics/RMSLE/#rmsle","text":"Root mean squared logarithmic error.","title":"RMSLE"},{"location":"api/metrics/RMSLE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/RMSLE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSLE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric RMSLE : 0.357826","title":"Examples"},{"location":"api/metrics/RMSLE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/ROCAUC/","text":"ROCAUC \u00b6 Receiving Operating Characteristic Area Under the Curve. This metric is an approximation of the true ROC AUC. Computing the true ROC AUC would require storing all the predictions and ground truths, which isn't desirable. The approximation error is not significant as long as the predicted probabilities are well calibrated. In any case, this metric can still be used to reliably compare models between each other. Parameters \u00b6 n_thresholds \u2013 defaults to 10 The number of thresholds used for discretizing the ROC curve. A higher value will lead to more accurate results, but will also cost more time and memory. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 0 , 1 , 1 ] >>> y_pred = [ . 1 , . 4 , . 35 , . 8 ] >>> metric = metrics . ROCAUC () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 0.875 The true ROC AUC is in fact 0.75. We can improve the accuracy by increasing the amount of thresholds. This comes at the cost more computation time and more memory usage. >>> metric = metrics . ROCAUC ( n_thresholds = 20 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 0.75 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ROCAUC"},{"location":"api/metrics/ROCAUC/#rocauc","text":"Receiving Operating Characteristic Area Under the Curve. This metric is an approximation of the true ROC AUC. Computing the true ROC AUC would require storing all the predictions and ground truths, which isn't desirable. The approximation error is not significant as long as the predicted probabilities are well calibrated. In any case, this metric can still be used to reliably compare models between each other.","title":"ROCAUC"},{"location":"api/metrics/ROCAUC/#parameters","text":"n_thresholds \u2013 defaults to 10 The number of thresholds used for discretizing the ROC curve. A higher value will lead to more accurate results, but will also cost more time and memory. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/ROCAUC/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/ROCAUC/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 0 , 1 , 1 ] >>> y_pred = [ . 1 , . 4 , . 35 , . 8 ] >>> metric = metrics . ROCAUC () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 0.875 The true ROC AUC is in fact 0.75. We can improve the accuracy by increasing the amount of thresholds. This comes at the cost more computation time and more memory usage. >>> metric = metrics . ROCAUC ( n_thresholds = 20 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 0.75","title":"Examples"},{"location":"api/metrics/ROCAUC/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Recall/","text":"Recall \u00b6 Binary recall score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Recall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Recall : 1. Recall : 1. Recall : 0.5 Recall : 0.666667 Recall : 0.75 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Recall"},{"location":"api/metrics/Recall/#recall","text":"Binary recall score.","title":"Recall"},{"location":"api/metrics/Recall/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/Recall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/Recall/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Recall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Recall : 1. Recall : 1. Recall : 0.5 Recall : 0.666667 Recall : 0.75","title":"Examples"},{"location":"api/metrics/Recall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/RegressionMetric/","text":"RegressionMetric \u00b6 Mother class for all regression metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"RegressionMetric"},{"location":"api/metrics/RegressionMetric/#regressionmetric","text":"Mother class for all regression metrics.","title":"RegressionMetric"},{"location":"api/metrics/RegressionMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/RegressionMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/RegressionMultiOutput/","text":"RegressionMultiOutput \u00b6 Wrapper for multi-output regression. This wraps a regression metric to make it compatible with multi-output regression tasks. The value of each output will be fed sequentially to the get method of the provided metric. Parameters \u00b6 metric ( 'base.RegressionMetric' ) The regression metric to evaluate with each output. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"RegressionMultiOutput"},{"location":"api/metrics/RegressionMultiOutput/#regressionmultioutput","text":"Wrapper for multi-output regression. This wraps a regression metric to make it compatible with multi-output regression tasks. The value of each output will be fed sequentially to the get method of the provided metric.","title":"RegressionMultiOutput"},{"location":"api/metrics/RegressionMultiOutput/#parameters","text":"metric ( 'base.RegressionMetric' ) The regression metric to evaluate with each output.","title":"Parameters"},{"location":"api/metrics/RegressionMultiOutput/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels","title":"Attributes"},{"location":"api/metrics/RegressionMultiOutput/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Rolling/","text":"Rolling \u00b6 Wrapper for computing metrics over a window. This wrapper metric allows you to apply a metric over a window of observations. Under the hood, a buffer with the window_size most recent pairs of (y_true, y_pred) is memorised. When the buffer is full, the oldest pair is removed and the revert method of the metric is called with said pair. You should use metrics.Rolling to evaluate a metric over a window of fixed sized. You can use metrics.TimeRolling to instead evaluate a metric over a period of time. Parameters \u00b6 metric ( river.metrics.base.Metric ) A metric. window_size ( int ) The number of most recent (y_true, y_pred) pairs on which to evaluate the metric. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels size Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . Rolling ( metrics . MSE (), window_size = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Rolling of size 2 MSE : 0.25 Rolling of size 2 MSE : 0.25 Rolling of size 2 MSE : 0.125 Rolling of size 2 MSE : 0.5 Methods \u00b6 append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get Return the current value of the metric. popleft revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Rolling"},{"location":"api/metrics/Rolling/#rolling","text":"Wrapper for computing metrics over a window. This wrapper metric allows you to apply a metric over a window of observations. Under the hood, a buffer with the window_size most recent pairs of (y_true, y_pred) is memorised. When the buffer is full, the oldest pair is removed and the revert method of the metric is called with said pair. You should use metrics.Rolling to evaluate a metric over a window of fixed sized. You can use metrics.TimeRolling to instead evaluate a metric over a period of time.","title":"Rolling"},{"location":"api/metrics/Rolling/#parameters","text":"metric ( river.metrics.base.Metric ) A metric. window_size ( int ) The number of most recent (y_true, y_pred) pairs on which to evaluate the metric.","title":"Parameters"},{"location":"api/metrics/Rolling/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels size","title":"Attributes"},{"location":"api/metrics/Rolling/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . Rolling ( metrics . MSE (), window_size = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Rolling of size 2 MSE : 0.25 Rolling of size 2 MSE : 0.25 Rolling of size 2 MSE : 0.125 Rolling of size 2 MSE : 0.5","title":"Examples"},{"location":"api/metrics/Rolling/#methods","text":"append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get Return the current value of the metric. popleft revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/SMAPE/","text":"SMAPE \u00b6 Symmetric mean absolute percentage error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.0672 , 0.0672 ] >>> y_pred = [ 0 , 0.102 , 0.107 , 0.047 , 0.1 , 0.032 , 0.047 , 0.108 , 0.089 ] >>> metric = metrics . SMAPE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric SMAPE : 37.869392 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"SMAPE"},{"location":"api/metrics/SMAPE/#smape","text":"Symmetric mean absolute percentage error.","title":"SMAPE"},{"location":"api/metrics/SMAPE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/SMAPE/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.0672 , 0.0672 ] >>> y_pred = [ 0 , 0.102 , 0.107 , 0.047 , 0.1 , 0.032 , 0.047 , 0.108 , 0.089 ] >>> metric = metrics . SMAPE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric SMAPE : 37.869392","title":"Examples"},{"location":"api/metrics/SMAPE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/TimeRolling/","text":"TimeRolling \u00b6 Wrapper for computing metrics over a period of time. Parameters \u00b6 metric ( river.metrics.base.Metric ) A metric. period ( datetime.timedelta ) A period of time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels Examples \u00b6 >>> import datetime as dt >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 9 ] >>> days = [ 1 , 2 , 3 , 4 ] >>> metric = metrics . TimeRolling ( metrics . MAE (), period = dt . timedelta ( days = 2 )) >>> for yt , yp , day in zip ( y_true , y_pred , days ): ... t = dt . datetime ( 2019 , 1 , day ) ... print ( metric . update ( yt , yp , t )) MAE : 0.5 MAE : 0.5 MAE : 0.25 MAE : 1. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred update Update the metric. Parameters y_true y_pred t works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"TimeRolling"},{"location":"api/metrics/TimeRolling/#timerolling","text":"Wrapper for computing metrics over a period of time.","title":"TimeRolling"},{"location":"api/metrics/TimeRolling/#parameters","text":"metric ( river.metrics.base.Metric ) A metric. period ( datetime.timedelta ) A period of time.","title":"Parameters"},{"location":"api/metrics/TimeRolling/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels","title":"Attributes"},{"location":"api/metrics/TimeRolling/#examples","text":">>> import datetime as dt >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 9 ] >>> days = [ 1 , 2 , 3 , 4 ] >>> metric = metrics . TimeRolling ( metrics . MAE (), period = dt . timedelta ( days = 2 )) >>> for yt , yp , day in zip ( y_true , y_pred , days ): ... t = dt . datetime ( 2019 , 1 , day ) ... print ( metric . update ( yt , yp , t )) MAE : 0.5 MAE : 0.5 MAE : 0.25 MAE : 1.","title":"Examples"},{"location":"api/metrics/TimeRolling/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred update Update the metric. Parameters y_true y_pred t works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedF1/","text":"WeightedF1 \u00b6 Weighted-average F1 score. This works by computing the F1 score per class, and then performs a global weighted average by using the support of each class. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedF1 : 1. WeightedF1 : 0.333333 WeightedF1 : 0.555556 WeightedF1 : 0.666667 WeightedF1 : 0.613333 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedF1"},{"location":"api/metrics/WeightedF1/#weightedf1","text":"Weighted-average F1 score. This works by computing the F1 score per class, and then performs a global weighted average by using the support of each class.","title":"WeightedF1"},{"location":"api/metrics/WeightedF1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedF1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/WeightedF1/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedF1 : 1. WeightedF1 : 0.333333 WeightedF1 : 0.555556 WeightedF1 : 0.666667 WeightedF1 : 0.613333","title":"Examples"},{"location":"api/metrics/WeightedF1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedFBeta/","text":"WeightedFBeta \u00b6 Weighted-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global weighted average according to the support of each class. Parameters \u00b6 beta Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedFBeta ( beta = 0.8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedFBeta : 1. WeightedFBeta : 0.310606 WeightedFBeta : 0.540404 WeightedFBeta : 0.655303 WeightedFBeta : 0.626283 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedFBeta"},{"location":"api/metrics/WeightedFBeta/#weightedfbeta","text":"Weighted-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global weighted average according to the support of each class.","title":"WeightedFBeta"},{"location":"api/metrics/WeightedFBeta/#parameters","text":"beta Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/WeightedFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedFBeta ( beta = 0.8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedFBeta : 1. WeightedFBeta : 0.310606 WeightedFBeta : 0.540404 WeightedFBeta : 0.655303 WeightedFBeta : 0.626283","title":"Examples"},{"location":"api/metrics/WeightedFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedPrecision/","text":"WeightedPrecision \u00b6 Weighted-average precision score. This uses the support of each label to compute an average score, whereas metrics.MacroPrecision ignores the support. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedPrecision : 1. WeightedPrecision : 0.25 WeightedPrecision : 0.5 WeightedPrecision : 0.625 WeightedPrecision : 0.7 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedPrecision"},{"location":"api/metrics/WeightedPrecision/#weightedprecision","text":"Weighted-average precision score. This uses the support of each label to compute an average score, whereas metrics.MacroPrecision ignores the support.","title":"WeightedPrecision"},{"location":"api/metrics/WeightedPrecision/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedPrecision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/WeightedPrecision/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedPrecision : 1. WeightedPrecision : 0.25 WeightedPrecision : 0.5 WeightedPrecision : 0.625 WeightedPrecision : 0.7","title":"Examples"},{"location":"api/metrics/WeightedPrecision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedRecall/","text":"WeightedRecall \u00b6 Weighted-average recall score. This uses the support of each label to compute an average score, whereas MacroRecall ignores the support. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedRecall : 1. WeightedRecall : 0.5 WeightedRecall : 0.666667 WeightedRecall : 0.75 WeightedRecall : 0.6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedRecall"},{"location":"api/metrics/WeightedRecall/#weightedrecall","text":"Weighted-average recall score. This uses the support of each label to compute an average score, whereas MacroRecall ignores the support.","title":"WeightedRecall"},{"location":"api/metrics/WeightedRecall/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedRecall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. sample_correction","title":"Attributes"},{"location":"api/metrics/WeightedRecall/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedRecall : 1. WeightedRecall : 0.5 WeightedRecall : 0.666667 WeightedRecall : 0.75 WeightedRecall : 0.6","title":"Examples"},{"location":"api/metrics/WeightedRecall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WrapperMetric/","text":"WrapperMetric \u00b6 Mother class for all metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WrapperMetric"},{"location":"api/metrics/WrapperMetric/#wrappermetric","text":"Mother class for all metrics.","title":"WrapperMetric"},{"location":"api/metrics/WrapperMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels","title":"Attributes"},{"location":"api/metrics/WrapperMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/multiclass/OneVsOneClassifier/","text":"OneVsOneClassifier \u00b6 One-vs-One (OvO) multiclass strategy. This strategy consists in fitting one binary classifier for each pair of classes. Because we are in a streaming context, the number of classes isn't known from the start, hence new classifiers are instantiated on the fly. The number of classifiers is k * (k - 1) / 2 , where k is the number of classes. However, each call to learn_one only requires training k - 1 models. Indeed, only the models that pertain to the given label have to be trained. Meanwhile, making a prediction requires going through each and every model. Parameters \u00b6 classifier A binary classifier, although a multi-class classifier will work too. Attributes \u00b6 classifiers ( dict ) A mapping between pairs of classes and classifiers. The keys are tuples which contain a pair of classes. Each pair is sorted in lexicographical order. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovo = multiclass . OneVsOneClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovo >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.807573 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"OneVsOneClassifier"},{"location":"api/multiclass/OneVsOneClassifier/#onevsoneclassifier","text":"One-vs-One (OvO) multiclass strategy. This strategy consists in fitting one binary classifier for each pair of classes. Because we are in a streaming context, the number of classes isn't known from the start, hence new classifiers are instantiated on the fly. The number of classifiers is k * (k - 1) / 2 , where k is the number of classes. However, each call to learn_one only requires training k - 1 models. Indeed, only the models that pertain to the given label have to be trained. Meanwhile, making a prediction requires going through each and every model.","title":"OneVsOneClassifier"},{"location":"api/multiclass/OneVsOneClassifier/#parameters","text":"classifier A binary classifier, although a multi-class classifier will work too.","title":"Parameters"},{"location":"api/multiclass/OneVsOneClassifier/#attributes","text":"classifiers ( dict ) A mapping between pairs of classes and classifiers. The keys are tuples which contain a pair of classes. Each pair is sorted in lexicographical order.","title":"Attributes"},{"location":"api/multiclass/OneVsOneClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovo = multiclass . OneVsOneClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovo >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.807573","title":"Examples"},{"location":"api/multiclass/OneVsOneClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/multiclass/OneVsRestClassifier/","text":"OneVsRestClassifier \u00b6 One-vs-the-rest (OvR) multiclass strategy. This strategy consists in fitting one binary classifier per class. Because we are in a streaming context, the number of classes isn't known from the start. Hence, new classifiers are instantiated on the fly. Likewise, the predicted probabilities will only include the classes seen up to a given point in time. Note that this classifier supports mini-batches as well as single instances. The computational complexity for both learning and predicting grows linearly with the number of classes. If you have a very large number of classes, then you might want to consider using an multiclass.OutputCodeClassifier instead. Parameters \u00b6 classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too. Attributes \u00b6 classifiers ( dict ) A mapping between classes and classifiers. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovr = multiclass . OneVsRestClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovr >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.774573 This estimator also also supports mini-batching. >>> for X in pd . read_csv ( dataset . path , chunksize = 64 ): ... y = X . pop ( 'category' ) ... y_pred = model . predict_many ( X ) ... model = model . learn_many ( X , y ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X Returns Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X Returns DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"OneVsRestClassifier"},{"location":"api/multiclass/OneVsRestClassifier/#onevsrestclassifier","text":"One-vs-the-rest (OvR) multiclass strategy. This strategy consists in fitting one binary classifier per class. Because we are in a streaming context, the number of classes isn't known from the start. Hence, new classifiers are instantiated on the fly. Likewise, the predicted probabilities will only include the classes seen up to a given point in time. Note that this classifier supports mini-batches as well as single instances. The computational complexity for both learning and predicting grows linearly with the number of classes. If you have a very large number of classes, then you might want to consider using an multiclass.OutputCodeClassifier instead.","title":"OneVsRestClassifier"},{"location":"api/multiclass/OneVsRestClassifier/#parameters","text":"classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too.","title":"Parameters"},{"location":"api/multiclass/OneVsRestClassifier/#attributes","text":"classifiers ( dict ) A mapping between classes and classifiers.","title":"Attributes"},{"location":"api/multiclass/OneVsRestClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovr = multiclass . OneVsRestClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovr >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.774573 This estimator also also supports mini-batching. >>> for X in pd . read_csv ( dataset . path , chunksize = 64 ): ... y = X . pop ( 'category' ) ... y_pred = model . predict_many ( X ) ... model = model . learn_many ( X , y )","title":"Examples"},{"location":"api/multiclass/OneVsRestClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X Returns Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X Returns DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/multiclass/OutputCodeClassifier/","text":"OutputCodeClassifier \u00b6 Output-code multiclass strategy. This also referred to as \"error-correcting output codes\". This class allows to learn a multi-class classification problem with a binary classifier. Each class is converted to a code of 0s and 1s. The length of the code is called the code size. A copy of the classifier made for code. The codes associated with the classes are stored in a code book. When a new sample arrives, the label's code is retrieved from the code book. Then, each classifier is trained on the relevant part of code, which is either a 0 or a 1. For predicting, each classifier outputs a probability. These are then compared to each code in the code book, and the label which is the \"closest\" is chosen as the most likely class. Closeness is determined in terms of Manhattan distance. One specificity of online learning is that we don't how many classes there are initially. Therefore, a random procedure generates random codes on the fly whenever a previously unseed label appears. Parameters \u00b6 classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too. code_size ( int ) The code size, which dictates how many copies of the provided classifiers to train. Must be strictly positive. seed ( int ) \u2013 defaults to None A random seed number that can be set for reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ooc = OutputCodeClassifier ( ... classifier = linear_model . LogisticRegression (), ... code_size = 10 , ... seed = 24 ... ) >>> model = scaler | ooc >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.797119 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. References \u00b6 Dietterich, T.G. and Bakiri, G., 1994. Solving multiclass learning problems via error-correcting output codes. Journal of artificial intelligence research, 2, pp.263-286. \u21a9 Allwein, E.L., Schapire, R.E. and Singer, Y., 2000. Reducing multiclass to binary: A unifying approach for margin classifiers. Journal of machine learning research, 1(Dec), pp.113-141. \u21a9","title":"OutputCodeClassifier"},{"location":"api/multiclass/OutputCodeClassifier/#outputcodeclassifier","text":"Output-code multiclass strategy. This also referred to as \"error-correcting output codes\". This class allows to learn a multi-class classification problem with a binary classifier. Each class is converted to a code of 0s and 1s. The length of the code is called the code size. A copy of the classifier made for code. The codes associated with the classes are stored in a code book. When a new sample arrives, the label's code is retrieved from the code book. Then, each classifier is trained on the relevant part of code, which is either a 0 or a 1. For predicting, each classifier outputs a probability. These are then compared to each code in the code book, and the label which is the \"closest\" is chosen as the most likely class. Closeness is determined in terms of Manhattan distance. One specificity of online learning is that we don't how many classes there are initially. Therefore, a random procedure generates random codes on the fly whenever a previously unseed label appears.","title":"OutputCodeClassifier"},{"location":"api/multiclass/OutputCodeClassifier/#parameters","text":"classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too. code_size ( int ) The code size, which dictates how many copies of the provided classifiers to train. Must be strictly positive. seed ( int ) \u2013 defaults to None A random seed number that can be set for reproducibility.","title":"Parameters"},{"location":"api/multiclass/OutputCodeClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ooc = OutputCodeClassifier ( ... classifier = linear_model . LogisticRegression (), ... code_size = 10 , ... seed = 24 ... ) >>> model = scaler | ooc >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 0.797119","title":"Examples"},{"location":"api/multiclass/OutputCodeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/multiclass/OutputCodeClassifier/#references","text":"Dietterich, T.G. and Bakiri, G., 1994. Solving multiclass learning problems via error-correcting output codes. Journal of artificial intelligence research, 2, pp.263-286. \u21a9 Allwein, E.L., Schapire, R.E. and Singer, Y., 2000. Reducing multiclass to binary: A unifying approach for margin classifiers. Journal of machine learning research, 1(Dec), pp.113-141. \u21a9","title":"References"},{"location":"api/multioutput/ClassifierChain/","text":"ClassifierChain \u00b6 A multi-output model that arranges classifiers into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second model. The prediction for the second output will be used as a feature for the third model, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs. Parameters \u00b6 model ( base.Classifier ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target. Examples \u00b6 >>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . fetch_openml ( 'yeast' , version = 4 , as_frame = False ), ... shuffle = True , ... seed = 42 ... ) >>> model = feature_selection . VarianceThreshold ( threshold = 0.01 ) >>> model |= preprocessing . StandardScaler () >>> model |= multioutput . ClassifierChain ( ... model = linear_model . LogisticRegression (), ... order = list ( range ( 14 )) ... ) >>> metric = metrics . Jaccard () >>> for x , y in dataset : ... # Convert y values to booleans ... y = { i : yi == 'TRUE' for i , yi in y . items ()} ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric Jaccard : 0.451524 Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values References \u00b6 Multi-Output Chain Models and their Application in Data Streams \u21a9","title":"ClassifierChain"},{"location":"api/multioutput/ClassifierChain/#classifierchain","text":"A multi-output model that arranges classifiers into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second model. The prediction for the second output will be used as a feature for the third model, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.","title":"ClassifierChain"},{"location":"api/multioutput/ClassifierChain/#parameters","text":"model ( base.Classifier ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target.","title":"Parameters"},{"location":"api/multioutput/ClassifierChain/#examples","text":">>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . fetch_openml ( 'yeast' , version = 4 , as_frame = False ), ... shuffle = True , ... seed = 42 ... ) >>> model = feature_selection . VarianceThreshold ( threshold = 0.01 ) >>> model |= preprocessing . StandardScaler () >>> model |= multioutput . ClassifierChain ( ... model = linear_model . LogisticRegression (), ... order = list ( range ( 14 )) ... ) >>> metric = metrics . Jaccard () >>> for x , y in dataset : ... # Convert y values to booleans ... y = { i : yi == 'TRUE' for i , yi in y . items ()} ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric Jaccard : 0.451524","title":"Examples"},{"location":"api/multioutput/ClassifierChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/multioutput/ClassifierChain/#references","text":"Multi-Output Chain Models and their Application in Data Streams \u21a9","title":"References"},{"location":"api/multioutput/MonteCarloClassifierChain/","text":"MonteCarloClassifierChain \u00b6 Monte Carlo Sampling Classifier Chains. Probabilistic Classifier Chains using Monte Carlo sampling, as described in 1 . m samples are taken from the posterior distribution. Therefore we need a probabilistic interpretation of the output, and thus, this is a particular variety of ProbabilisticClassifierChain. Parameters \u00b6 model ( base.Classifier ) m ( int ) \u2013 defaults to 10 Number of samples to take from the posterior distribution. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Examples \u00b6 >>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . MonteCarloClassifierChain ( ... model = linear_model . LogisticRegression (), ... m = 10 , ... seed = 42 ... ) >>> metric = metrics . Jaccard () >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric Jaccard : 0.568087 Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values References \u00b6 Read, J., Martino, L., & Luengo, D. (2014). Efficient monte carlo methods for multi-dimensional learning with classifier chains. Pattern Recognition, 47(3), 1535-1546. \u21a9","title":"MonteCarloClassifierChain"},{"location":"api/multioutput/MonteCarloClassifierChain/#montecarloclassifierchain","text":"Monte Carlo Sampling Classifier Chains. Probabilistic Classifier Chains using Monte Carlo sampling, as described in 1 . m samples are taken from the posterior distribution. Therefore we need a probabilistic interpretation of the output, and thus, this is a particular variety of ProbabilisticClassifierChain.","title":"MonteCarloClassifierChain"},{"location":"api/multioutput/MonteCarloClassifierChain/#parameters","text":"model ( base.Classifier ) m ( int ) \u2013 defaults to 10 Number of samples to take from the posterior distribution. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/multioutput/MonteCarloClassifierChain/#examples","text":">>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . MonteCarloClassifierChain ( ... model = linear_model . LogisticRegression (), ... m = 10 , ... seed = 42 ... ) >>> metric = metrics . Jaccard () >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric Jaccard : 0.568087","title":"Examples"},{"location":"api/multioutput/MonteCarloClassifierChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/multioutput/MonteCarloClassifierChain/#references","text":"Read, J., Martino, L., & Luengo, D. (2014). Efficient monte carlo methods for multi-dimensional learning with classifier chains. Pattern Recognition, 47(3), 1535-1546. \u21a9","title":"References"},{"location":"api/multioutput/ProbabilisticClassifierChain/","text":"ProbabilisticClassifierChain \u00b6 Probabilistic Classifier Chains. The Probabilistic Classifier Chains (PCC) 1 is a Bayes-optimal method based on the Classifier Chains (CC). Consider the concept of chaining classifiers as searching a path in a binary tree whose leaf nodes are associated with a label \\(y \\in Y\\) . While CC searches only a single path in the aforementioned binary tree, PCC looks at each of the \\(2^l\\) paths, where \\(l\\) is the number of labels. This limits the applicability of the method to data sets with a small to moderate number of labels. The authors recommend no more than about 15 labels for real-world applications. Parameters \u00b6 model ( base.Classifier ) Examples \u00b6 >>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . ProbabilisticClassifierChain ( ... model = linear_model . LogisticRegression () ... ) >>> metric = metrics . Jaccard () >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric Jaccard : 0.571429 Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values References \u00b6 Cheng, W., H\u00fcllermeier, E., & Dembczynski, K. J. (2010). Bayes optimal multilabel classification via probabilistic classifier chains. In Proceedings of the 27th international conference on machine learning (ICML-10) (pp. 279-286). \u21a9","title":"ProbabilisticClassifierChain"},{"location":"api/multioutput/ProbabilisticClassifierChain/#probabilisticclassifierchain","text":"Probabilistic Classifier Chains. The Probabilistic Classifier Chains (PCC) 1 is a Bayes-optimal method based on the Classifier Chains (CC). Consider the concept of chaining classifiers as searching a path in a binary tree whose leaf nodes are associated with a label \\(y \\in Y\\) . While CC searches only a single path in the aforementioned binary tree, PCC looks at each of the \\(2^l\\) paths, where \\(l\\) is the number of labels. This limits the applicability of the method to data sets with a small to moderate number of labels. The authors recommend no more than about 15 labels for real-world applications.","title":"ProbabilisticClassifierChain"},{"location":"api/multioutput/ProbabilisticClassifierChain/#parameters","text":"model ( base.Classifier )","title":"Parameters"},{"location":"api/multioutput/ProbabilisticClassifierChain/#examples","text":">>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . ProbabilisticClassifierChain ( ... model = linear_model . LogisticRegression () ... ) >>> metric = metrics . Jaccard () >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric Jaccard : 0.571429","title":"Examples"},{"location":"api/multioutput/ProbabilisticClassifierChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/multioutput/ProbabilisticClassifierChain/#references","text":"Cheng, W., H\u00fcllermeier, E., & Dembczynski, K. J. (2010). Bayes optimal multilabel classification via probabilistic classifier chains. In Proceedings of the 27th international conference on machine learning (ICML-10) (pp. 279-286). \u21a9","title":"References"},{"location":"api/multioutput/RegressorChain/","text":"RegressorChain \u00b6 A multi-output model that arranges regressor into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second output. The prediction for the second output will be used as a feature for the third, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs. Parameters \u00b6 model ( base.Regressor ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target. Examples \u00b6 >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_linnerud (), ... shuffle = True , ... seed = 42 ... ) >>> model = multioutput . RegressorChain ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = 0.3 ) ... ), ... order = [ 0 , 1 , 2 ] ... ) >>> metric = metrics . RegressionMultiOutput ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 12.649592 Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"RegressorChain"},{"location":"api/multioutput/RegressorChain/#regressorchain","text":"A multi-output model that arranges regressor into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second output. The prediction for the second output will be used as a feature for the third, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.","title":"RegressorChain"},{"location":"api/multioutput/RegressorChain/#parameters","text":"model ( base.Regressor ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target.","title":"Parameters"},{"location":"api/multioutput/RegressorChain/#examples","text":">>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_linnerud (), ... shuffle = True , ... seed = 42 ... ) >>> model = multioutput . RegressorChain ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = 0.3 ) ... ), ... order = [ 0 , 1 , 2 ] ... ) >>> metric = metrics . RegressionMultiOutput ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 12.649592","title":"Examples"},{"location":"api/multioutput/RegressorChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f05d5aa1150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/naive-bayes/BernoulliNB/","text":"BernoulliNB \u00b6 Bernoulli Naive Bayes. Bernoulli Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values. Parameters \u00b6 alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). true_threshold \u2013 defaults to 0.0 Threshold for binarizing (mapping to booleans) features. Attributes \u00b6 class_counts ( collections.Counter ) Number of times each class has been seen. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. Examples \u00b6 >>> import math >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 3 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Beijing' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Macao' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Shanghai' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Beijing' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Macao' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Shanghai' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> new_text = 'Chinese Chinese Chinese Tokyo Japan' >>> tokens = model [ 'tokenize' ] . transform_one ( new_text ) >>> jlh = model [ 'nb' ] . joint_log_likelihood ( tokens ) >>> math . exp ( jlh [ 'yes' ]) 0.005184 >>> math . exp ( jlh [ 'no' ]) 0.021947 >>> model . predict_one ( new_text ) 'no' >>> model . predict_proba_one ( 'test' )[ 'yes' ] 0.8831539823829913 You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> import pandas as pd >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> docs = pd . DataFrame ( docs , columns = [ 'docs' , 'y' ]) >>> X , y = docs [ 'docs' ], docs [ 'y' ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 3 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Beijing' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Macao' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Shanghai' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Beijing' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Macao' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Shanghai' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> unseen_data = pd . Series ( ... [ 'Taiwanese Taipei' , 'Chinese Shanghai' ], ... name = 'docs' , ... index = [ 'river' , 'rocks' ] ... ) >>> model . predict_proba_many ( unseen_data ) no yes river 0.116846 0.883154 rocks 0.047269 0.952731 >>> model . predict_many ( unseen_data ) river yes rocks yes dtype : object >>> unseen_data = pd . Series ( ... [ 'test' ], name = 'docs' ) >>> model . predict_proba_many ( unseen_data ) no yes 0 0.116846 0.883154 >>> model . predict_proba_one ( 'test' ) { 'no' : 0.116846017617009 , 'yes' : 0.8831539823829913 } >>> bag = feature_extraction . BagOfWords ( lowercase = False ) >>> model = naive_bayes . BernoulliNB ( alpha = 1 ) >>> X , y = docs [ 'docs' ], docs [ 'y' ] >>> X = bag . transform_many ( X ) >>> X = pd . DataFrame ( X . values , columns = X . columns , dtype = int ) >>> model = model . learn_many ( X , y ) >>> unseen_data = bag . transform_many ( unseen_data ) >>> unseen_data = pd . DataFrame ( unseen_data . values , columns = unseen_data . columns , index = [ 'river' ]) >>> model . predict_proba_many ( unseen_data ) no yes river 0.116846 0.883154 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Updates the model with a term-frequency or TF-IDF pandas dataframe. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict ) References \u00b6 The Bernoulli model \u21a9","title":"BernoulliNB"},{"location":"api/naive-bayes/BernoulliNB/#bernoullinb","text":"Bernoulli Naive Bayes. Bernoulli Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.","title":"BernoulliNB"},{"location":"api/naive-bayes/BernoulliNB/#parameters","text":"alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). true_threshold \u2013 defaults to 0.0 Threshold for binarizing (mapping to booleans) features.","title":"Parameters"},{"location":"api/naive-bayes/BernoulliNB/#attributes","text":"class_counts ( collections.Counter ) Number of times each class has been seen. feature_counts ( collections.defaultdict ) Total frequencies per feature and class.","title":"Attributes"},{"location":"api/naive-bayes/BernoulliNB/#examples","text":">>> import math >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 3 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Beijing' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Macao' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Shanghai' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Beijing' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Macao' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Shanghai' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> new_text = 'Chinese Chinese Chinese Tokyo Japan' >>> tokens = model [ 'tokenize' ] . transform_one ( new_text ) >>> jlh = model [ 'nb' ] . joint_log_likelihood ( tokens ) >>> math . exp ( jlh [ 'yes' ]) 0.005184 >>> math . exp ( jlh [ 'no' ]) 0.021947 >>> model . predict_one ( new_text ) 'no' >>> model . predict_proba_one ( 'test' )[ 'yes' ] 0.8831539823829913 You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> import pandas as pd >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> docs = pd . DataFrame ( docs , columns = [ 'docs' , 'y' ]) >>> X , y = docs [ 'docs' ], docs [ 'y' ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 3 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Beijing' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Macao' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Shanghai' , 'yes' ) == ( 1 + 1 ) / ( 3 + 2 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Beijing' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Macao' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> cp ( 'Shanghai' , 'no' ) == ( 0 + 1 ) / ( 1 + 2 ) True >>> unseen_data = pd . Series ( ... [ 'Taiwanese Taipei' , 'Chinese Shanghai' ], ... name = 'docs' , ... index = [ 'river' , 'rocks' ] ... ) >>> model . predict_proba_many ( unseen_data ) no yes river 0.116846 0.883154 rocks 0.047269 0.952731 >>> model . predict_many ( unseen_data ) river yes rocks yes dtype : object >>> unseen_data = pd . Series ( ... [ 'test' ], name = 'docs' ) >>> model . predict_proba_many ( unseen_data ) no yes 0 0.116846 0.883154 >>> model . predict_proba_one ( 'test' ) { 'no' : 0.116846017617009 , 'yes' : 0.8831539823829913 } >>> bag = feature_extraction . BagOfWords ( lowercase = False ) >>> model = naive_bayes . BernoulliNB ( alpha = 1 ) >>> X , y = docs [ 'docs' ], docs [ 'y' ] >>> X = bag . transform_many ( X ) >>> X = pd . DataFrame ( X . values , columns = X . columns , dtype = int ) >>> model = model . learn_many ( X , y ) >>> unseen_data = bag . transform_many ( unseen_data ) >>> unseen_data = pd . DataFrame ( unseen_data . values , columns = unseen_data . columns , index = [ 'river' ]) >>> model . predict_proba_many ( unseen_data ) no yes river 0.116846 0.883154","title":"Examples"},{"location":"api/naive-bayes/BernoulliNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Updates the model with a term-frequency or TF-IDF pandas dataframe. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/BernoulliNB/#references","text":"The Bernoulli model \u21a9","title":"References"},{"location":"api/naive-bayes/ComplementNB/","text":"ComplementNB \u00b6 Naive Bayes classifier for multinomial models. Complement Naive Bayes model learns from occurrences between features such as word counts and discrete classes. ComplementNB is suitable for imbalance dataset. The input vector must contain positive values, such as counts or TF-IDF values. Parameters \u00b6 alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). Attributes \u00b6 class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class. Examples \u00b6 >>> from river import feature_extraction >>> from river import naive_bayes >>> sentences = [ ... ( 'food food meat brain' , 'health' ), ... ( 'food meat ' + 'kitchen ' * 9 + 'job' * 5 , 'butcher' ), ... ( 'food food meat job' , 'health' ) ... ] >>> model = feature_extraction . BagOfWords () | ( 'nb' , naive_bayes . ComplementNB ) >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> model [ 'nb' ] . p_class ( 'health' ) == 2 / 3 True >>> model [ 'nb' ] . p_class ( 'butcher' ) == 1 / 3 True >>> model . predict_proba_one ( 'food job meat' ) { 'health' : 0.9409689355477155 , 'butcher' : 0.05903106445228467 } You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> import pandas as pd >>> docs = [ ... ( 'food food meat brain' , 'health' ), ... ( 'food meat ' + 'kitchen ' * 9 + 'job' * 5 , 'butcher' ), ... ( 'food food meat job' , 'health' ) ... ] >>> docs = pd . DataFrame ( docs , columns = [ 'X' , 'y' ]) >>> X , y = docs [ 'X' ], docs [ 'y' ] >>> model = feature_extraction . BagOfWords () | ( 'nb' , naive_bayes . ComplementNB ) >>> model = model . learn_many ( X , y ) >>> model [ 'nb' ] . p_class ( 'health' ) == 2 / 3 True >>> model [ 'nb' ] . p_class ( 'butcher' ) == 1 / 3 True >>> model [ 'nb' ] . p_class_many () butcher health 0 0.333333 0.666667 >>> model . predict_proba_one ( 'food job meat' ) { 'butcher' : 0.05903106445228467 , 'health' : 0.9409689355477155 } >>> model . predict_proba_one ( 'Taiwanese Taipei' ) { 'butcher' : 0.3769230769230768 , 'health' : 0.6230769230769229 } >>> unseen_data = pd . Series ( ... [ 'food job meat' , 'Taiwanese Taipei' ], name = 'X' , index = [ 'river' , 'rocks' ]) >>> model . predict_proba_many ( unseen_data ) butcher health river 0.059031 0.940969 rocks 0.376923 0.623077 >>> model . predict_many ( unseen_data ) river health rocks health dtype : object Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Updates the model with a term-frequency or TF-IDF pandas dataframe. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict ) References \u00b6 Rennie, J.D., Shih, L., Teevan, J. and Karger, D.R., 2003. Tackling the poor assumptions of naive bayes text classifiers. In Proceedings of the 20th international conference on machine learning (ICML-03) (pp. 616-623) \u21a9 StackExchange discussion \u21a9","title":"ComplementNB"},{"location":"api/naive-bayes/ComplementNB/#complementnb","text":"Naive Bayes classifier for multinomial models. Complement Naive Bayes model learns from occurrences between features such as word counts and discrete classes. ComplementNB is suitable for imbalance dataset. The input vector must contain positive values, such as counts or TF-IDF values.","title":"ComplementNB"},{"location":"api/naive-bayes/ComplementNB/#parameters","text":"alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).","title":"Parameters"},{"location":"api/naive-bayes/ComplementNB/#attributes","text":"class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class.","title":"Attributes"},{"location":"api/naive-bayes/ComplementNB/#examples","text":">>> from river import feature_extraction >>> from river import naive_bayes >>> sentences = [ ... ( 'food food meat brain' , 'health' ), ... ( 'food meat ' + 'kitchen ' * 9 + 'job' * 5 , 'butcher' ), ... ( 'food food meat job' , 'health' ) ... ] >>> model = feature_extraction . BagOfWords () | ( 'nb' , naive_bayes . ComplementNB ) >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> model [ 'nb' ] . p_class ( 'health' ) == 2 / 3 True >>> model [ 'nb' ] . p_class ( 'butcher' ) == 1 / 3 True >>> model . predict_proba_one ( 'food job meat' ) { 'health' : 0.9409689355477155 , 'butcher' : 0.05903106445228467 } You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> import pandas as pd >>> docs = [ ... ( 'food food meat brain' , 'health' ), ... ( 'food meat ' + 'kitchen ' * 9 + 'job' * 5 , 'butcher' ), ... ( 'food food meat job' , 'health' ) ... ] >>> docs = pd . DataFrame ( docs , columns = [ 'X' , 'y' ]) >>> X , y = docs [ 'X' ], docs [ 'y' ] >>> model = feature_extraction . BagOfWords () | ( 'nb' , naive_bayes . ComplementNB ) >>> model = model . learn_many ( X , y ) >>> model [ 'nb' ] . p_class ( 'health' ) == 2 / 3 True >>> model [ 'nb' ] . p_class ( 'butcher' ) == 1 / 3 True >>> model [ 'nb' ] . p_class_many () butcher health 0 0.333333 0.666667 >>> model . predict_proba_one ( 'food job meat' ) { 'butcher' : 0.05903106445228467 , 'health' : 0.9409689355477155 } >>> model . predict_proba_one ( 'Taiwanese Taipei' ) { 'butcher' : 0.3769230769230768 , 'health' : 0.6230769230769229 } >>> unseen_data = pd . Series ( ... [ 'food job meat' , 'Taiwanese Taipei' ], name = 'X' , index = [ 'river' , 'rocks' ]) >>> model . predict_proba_many ( unseen_data ) butcher health river 0.059031 0.940969 rocks 0.376923 0.623077 >>> model . predict_many ( unseen_data ) river health rocks health dtype : object","title":"Examples"},{"location":"api/naive-bayes/ComplementNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Updates the model with a term-frequency or TF-IDF pandas dataframe. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/ComplementNB/#references","text":"Rennie, J.D., Shih, L., Teevan, J. and Karger, D.R., 2003. Tackling the poor assumptions of naive bayes text classifiers. In Proceedings of the 20th international conference on machine learning (ICML-03) (pp. 616-623) \u21a9 StackExchange discussion \u21a9","title":"References"},{"location":"api/naive-bayes/GaussianNB/","text":"GaussianNB \u00b6 Gaussian Naive Bayes. A Gaussian distribution \\(G_{cf}\\) is maintained for each class \\(c\\) and each feature \\(f\\) . Each Gaussian is updated using the amount associated with each feature; the details can be be found in proba.Gaussian . The joint log-likelihood is then obtained by summing the log probabilities of each feature associated with each class. Examples \u00b6 >>> from river import naive_bayes >>> from river import stream >>> import numpy as np >>> X = np . array ([[ - 1 , - 1 ], [ - 2 , - 1 ], [ - 3 , - 2 ], [ 1 , 1 ], [ 2 , 1 ], [ 3 , 2 ]]) >>> Y = np . array ([ 1 , 1 , 1 , 2 , 2 , 2 ]) >>> model = naive_bayes . GaussianNB () >>> for x , y in stream . iter_array ( X , Y ): ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 0 : - 0.8 , 1 : - 1 }) 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Compute the unnormalized posterior log-likelihood of x. The log-likelihood is log P(c) + log P(x|c) . Parameters x ( dict ) joint_log_likelihood_many Compute the unnormalized posterior log-likelihood of x in mini-batches. The log-likelihood is log P(c) + log P(x|c) . Parameters X ( pandas.core.frame.DataFrame ) learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"GaussianNB"},{"location":"api/naive-bayes/GaussianNB/#gaussiannb","text":"Gaussian Naive Bayes. A Gaussian distribution \\(G_{cf}\\) is maintained for each class \\(c\\) and each feature \\(f\\) . Each Gaussian is updated using the amount associated with each feature; the details can be be found in proba.Gaussian . The joint log-likelihood is then obtained by summing the log probabilities of each feature associated with each class.","title":"GaussianNB"},{"location":"api/naive-bayes/GaussianNB/#examples","text":">>> from river import naive_bayes >>> from river import stream >>> import numpy as np >>> X = np . array ([[ - 1 , - 1 ], [ - 2 , - 1 ], [ - 3 , - 2 ], [ 1 , 1 ], [ 2 , 1 ], [ 3 , 2 ]]) >>> Y = np . array ([ 1 , 1 , 1 , 2 , 2 , 2 ]) >>> model = naive_bayes . GaussianNB () >>> for x , y in stream . iter_array ( X , Y ): ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 0 : - 0.8 , 1 : - 1 }) 1","title":"Examples"},{"location":"api/naive-bayes/GaussianNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Compute the unnormalized posterior log-likelihood of x. The log-likelihood is log P(c) + log P(x|c) . Parameters x ( dict ) joint_log_likelihood_many Compute the unnormalized posterior log-likelihood of x in mini-batches. The log-likelihood is log P(c) + log P(x|c) . Parameters X ( pandas.core.frame.DataFrame ) learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/MultinomialNB/","text":"MultinomialNB \u00b6 Naive Bayes classifier for multinomial models. Multinomial Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values. Parameters \u00b6 alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). Attributes \u00b6 class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class. Examples \u00b6 >>> import math >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 5 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> new_text = 'Chinese Chinese Chinese Tokyo Japan' >>> tokens = model [ 'tokenize' ] . transform_one ( new_text ) >>> jlh = model [ 'nb' ] . joint_log_likelihood ( tokens ) >>> math . exp ( jlh [ 'yes' ]) 0.000301 >>> math . exp ( jlh [ 'no' ]) 0.000135 >>> model . predict_one ( new_text ) 'yes' >>> new_unseen_text = 'Taiwanese Taipei' >>> tokens = model [ 'tokenize' ] . transform_one ( new_unseen_text ) >>> # P(Taiwanese|yes) >>> # = (N_Taiwanese_yes + 1) / (N_yes + N_terms) >>> cp ( 'Taiwanese' , 'yes' ) == cp ( 'Taipei' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Taiwanese' , 'no' ) == cp ( 'Taipei' , 'no' ) == ( 0 + 1 ) / ( 3 + 6 ) True >>> # P(yes|Taiwanese Taipei) >>> # \u221d P(Taiwanese|yes) * P(Taipei|yes) * P(yes) >>> posterior_yes_given_new_text = ( 0 + 1 ) / ( 8 + 6 ) * ( 0 + 1 ) / ( 8 + 6 ) * 0.75 >>> jlh = model [ 'nb' ] . joint_log_likelihood ( tokens ) >>> jlh [ 'yes' ] == math . log ( posterior_yes_given_new_text ) True >>> model . predict_one ( new_unseen_text ) 'yes' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> import pandas as pd >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> docs = pd . DataFrame ( docs , columns = [ 'docs' , 'y' ]) >>> X , y = docs [ 'docs' ], docs [ 'y' ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 5 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> unseen_data = pd . Series ( ... [ 'Taiwanese Taipei' , 'Chinese Shanghai' ], name = 'docs' , index = [ 'river' , 'rocks' ]) >>> model . predict_proba_many ( unseen_data ) no yes river 0.446469 0.553531 rocks 0.118501 0.881499 >>> model . predict_many ( unseen_data ) river yes rocks yes dtype : object Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Updates the model with a term-frequency or TF-IDF pandas dataframe. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict ) References \u00b6 Naive Bayes text classification \u21a9","title":"MultinomialNB"},{"location":"api/naive-bayes/MultinomialNB/#multinomialnb","text":"Naive Bayes classifier for multinomial models. Multinomial Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.","title":"MultinomialNB"},{"location":"api/naive-bayes/MultinomialNB/#parameters","text":"alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).","title":"Parameters"},{"location":"api/naive-bayes/MultinomialNB/#attributes","text":"class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class.","title":"Attributes"},{"location":"api/naive-bayes/MultinomialNB/#examples","text":">>> import math >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 5 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> new_text = 'Chinese Chinese Chinese Tokyo Japan' >>> tokens = model [ 'tokenize' ] . transform_one ( new_text ) >>> jlh = model [ 'nb' ] . joint_log_likelihood ( tokens ) >>> math . exp ( jlh [ 'yes' ]) 0.000301 >>> math . exp ( jlh [ 'no' ]) 0.000135 >>> model . predict_one ( new_text ) 'yes' >>> new_unseen_text = 'Taiwanese Taipei' >>> tokens = model [ 'tokenize' ] . transform_one ( new_unseen_text ) >>> # P(Taiwanese|yes) >>> # = (N_Taiwanese_yes + 1) / (N_yes + N_terms) >>> cp ( 'Taiwanese' , 'yes' ) == cp ( 'Taipei' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Taiwanese' , 'no' ) == cp ( 'Taipei' , 'no' ) == ( 0 + 1 ) / ( 3 + 6 ) True >>> # P(yes|Taiwanese Taipei) >>> # \u221d P(Taiwanese|yes) * P(Taipei|yes) * P(yes) >>> posterior_yes_given_new_text = ( 0 + 1 ) / ( 8 + 6 ) * ( 0 + 1 ) / ( 8 + 6 ) * 0.75 >>> jlh = model [ 'nb' ] . joint_log_likelihood ( tokens ) >>> jlh [ 'yes' ] == math . log ( posterior_yes_given_new_text ) True >>> model . predict_one ( new_unseen_text ) 'yes' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> import pandas as pd >>> docs = [ ... ( 'Chinese Beijing Chinese' , 'yes' ), ... ( 'Chinese Chinese Shanghai' , 'yes' ), ... ( 'Chinese Macao' , 'yes' ), ... ( 'Tokyo Japan Chinese' , 'no' ) ... ] >>> docs = pd . DataFrame ( docs , columns = [ 'docs' , 'y' ]) >>> X , y = docs [ 'docs' ], docs [ 'y' ] >>> model = compose . Pipeline ( ... ( 'tokenize' , feature_extraction . BagOfWords ( lowercase = False )), ... ( 'nb' , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> model [ 'nb' ] . p_class ( 'yes' ) 0.75 >>> model [ 'nb' ] . p_class ( 'no' ) 0.25 >>> cp = model [ 'nb' ] . p_feature_given_class >>> cp ( 'Chinese' , 'yes' ) == ( 5 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Tokyo' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Japan' , 'yes' ) == ( 0 + 1 ) / ( 8 + 6 ) True >>> cp ( 'Chinese' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Tokyo' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> cp ( 'Japan' , 'no' ) == ( 1 + 1 ) / ( 3 + 6 ) True >>> unseen_data = pd . Series ( ... [ 'Taiwanese Taipei' , 'Chinese Shanghai' ], name = 'docs' , index = [ 'river' , 'rocks' ]) >>> model . predict_proba_many ( unseen_data ) no yes river 0.446469 0.553531 rocks 0.118501 0.881499 >>> model . predict_many ( unseen_data ) river yes rocks yes dtype : object","title":"Examples"},{"location":"api/naive-bayes/MultinomialNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Updates the model with a term-frequency or TF-IDF pandas dataframe. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/MultinomialNB/#references","text":"Naive Bayes text classification \u21a9","title":"References"},{"location":"api/neighbors/KNNADWINClassifier/","text":"KNNADWINClassifier \u00b6 K-Nearest Neighbors classifier with ADWIN change detector. This classifier is an improvement from the regular kNN method, as it is resistant to concept drift. It uses the ADWIN change detector to decide which samples to keep and which ones to forget, and by doing so it regulates the sample window size. Parameters \u00b6 n_neighbors \u2013 defaults to 5 The number of nearest neighbors to search for. window_size \u2013 defaults to 1000 The maximum size of the window storing the last viewed samples. leaf_size \u2013 defaults to 30 The maximum number of samples that can be stored in one leaf node, which determines from which point the algorithm will switch for a brute-force approach. The bigger this number the faster the tree construction time, but the slower the query time will be. p \u2013 defaults to 2 p-norm value for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. Valid values are in the interval \\([1, +\\infty)\\) Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> dataset = synth . ConceptDriftStream ( position = 500 , width = 20 , seed = 1 ) . take ( 1000 ) >>> model = neighbors . KNNADWINClassifier ( window_size = 100 ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 56.66 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns proba reset Reset estimator. Notes \u00b6 This estimator is not optimal for a mixture of categorical and numerical features. This implementation treats all features from a given stream as numerical. This implementation is extended from the KNNClassifier, with the main difference that it keeps a dynamic window whose size changes in agreement with the amount of change detected by the ADWIN drift detector.","title":"KNNADWINClassifier"},{"location":"api/neighbors/KNNADWINClassifier/#knnadwinclassifier","text":"K-Nearest Neighbors classifier with ADWIN change detector. This classifier is an improvement from the regular kNN method, as it is resistant to concept drift. It uses the ADWIN change detector to decide which samples to keep and which ones to forget, and by doing so it regulates the sample window size.","title":"KNNADWINClassifier"},{"location":"api/neighbors/KNNADWINClassifier/#parameters","text":"n_neighbors \u2013 defaults to 5 The number of nearest neighbors to search for. window_size \u2013 defaults to 1000 The maximum size of the window storing the last viewed samples. leaf_size \u2013 defaults to 30 The maximum number of samples that can be stored in one leaf node, which determines from which point the algorithm will switch for a brute-force approach. The bigger this number the faster the tree construction time, but the slower the query time will be. p \u2013 defaults to 2 p-norm value for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. Valid values are in the interval \\([1, +\\infty)\\)","title":"Parameters"},{"location":"api/neighbors/KNNADWINClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> dataset = synth . ConceptDriftStream ( position = 500 , width = 20 , seed = 1 ) . take ( 1000 ) >>> model = neighbors . KNNADWINClassifier ( window_size = 100 ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 56.66 %","title":"Examples"},{"location":"api/neighbors/KNNADWINClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns proba reset Reset estimator.","title":"Methods"},{"location":"api/neighbors/KNNADWINClassifier/#notes","text":"This estimator is not optimal for a mixture of categorical and numerical features. This implementation treats all features from a given stream as numerical. This implementation is extended from the KNNClassifier, with the main difference that it keeps a dynamic window whose size changes in agreement with the amount of change detected by the ADWIN drift detector.","title":"Notes"},{"location":"api/neighbors/KNNClassifier/","text":"KNNClassifier \u00b6 k-Nearest Neighbors classifier. This non-parametric classification method keeps track of the last window_size training samples. The predicted class-label for a given query sample is obtained in two steps: Find the closest n_neighbors to the query sample in the data window. 2. Aggregate the class-labels of the n_neighbors to define the predicted class for the query sample. Parameters \u00b6 n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. leaf_size ( int ) \u2013 defaults to 30 scipy.spatial.cKDTree parameter. The maximum number of samples that can be stored in one leaf node, which determines from which point the algorithm will switch for a brute-force approach. The bigger this number the faster the tree construction time, but the slower the query time will be. p ( float ) \u2013 defaults to 2 p-norm value for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. Valid values are in the interval \\([1, +\\infty)\\) weighted ( bool ) \u2013 defaults to True Whether to weight the contribution of each neighbor by it's inverse distance or not. kwargs Other parameters passed to scipy.spatial.cKDTree . Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... neighbors . KNNClassifier () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.07 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns proba reset Reset estimator. Notes \u00b6 This estimator is not optimal for a mixture of categorical and numerical features. This implementation treats all features from a given stream as numerical.","title":"KNNClassifier"},{"location":"api/neighbors/KNNClassifier/#knnclassifier","text":"k-Nearest Neighbors classifier. This non-parametric classification method keeps track of the last window_size training samples. The predicted class-label for a given query sample is obtained in two steps: Find the closest n_neighbors to the query sample in the data window. 2. Aggregate the class-labels of the n_neighbors to define the predicted class for the query sample.","title":"KNNClassifier"},{"location":"api/neighbors/KNNClassifier/#parameters","text":"n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. leaf_size ( int ) \u2013 defaults to 30 scipy.spatial.cKDTree parameter. The maximum number of samples that can be stored in one leaf node, which determines from which point the algorithm will switch for a brute-force approach. The bigger this number the faster the tree construction time, but the slower the query time will be. p ( float ) \u2013 defaults to 2 p-norm value for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. Valid values are in the interval \\([1, +\\infty)\\) weighted ( bool ) \u2013 defaults to True Whether to weight the contribution of each neighbor by it's inverse distance or not. kwargs Other parameters passed to scipy.spatial.cKDTree .","title":"Parameters"},{"location":"api/neighbors/KNNClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... neighbors . KNNClassifier () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.07 %","title":"Examples"},{"location":"api/neighbors/KNNClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns proba reset Reset estimator.","title":"Methods"},{"location":"api/neighbors/KNNClassifier/#notes","text":"This estimator is not optimal for a mixture of categorical and numerical features. This implementation treats all features from a given stream as numerical.","title":"Notes"},{"location":"api/neighbors/KNNRegressor/","text":"KNNRegressor \u00b6 k-Nearest Neighbors regressor. This non-parametric regression method keeps track of the last window_size training samples. Predictions are obtained by aggregating the values of the closest n_neighbors stored-samples with respect to a query sample. Parameters \u00b6 n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. leaf_size ( int ) \u2013 defaults to 30 scipy.spatial.cKDTree parameter. The maximum number of samples that can be stored in one leaf node, which determines from which point the algorithm will switch for a brute-force approach. The bigger this number the faster the tree construction time, but the slower the query time will be. p ( float ) \u2013 defaults to 2 p-norm value for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. Valid values are in the interval \\([1, +\\infty)\\) aggregation_method ( str ) \u2013 defaults to mean The method to aggregate the target values of neighbors. | 'mean' | 'median' | 'weighted_mean' kwargs Other parameters passed to scipy.spatial.cKDTree. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... neighbors . KNNRegressor ( window_size = 50 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.441308 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a real target value y . Parameters x y Returns self predict_one Predict the target value of a set of features x . Search the KDTree for the n_neighbors nearest neighbors. Parameters x Returns The prediction. reset Reset estimator. Notes \u00b6 This estimator is not optimal for a mixture of categorical and numerical features. This implementation treats all features from a given stream as numerical.","title":"KNNRegressor"},{"location":"api/neighbors/KNNRegressor/#knnregressor","text":"k-Nearest Neighbors regressor. This non-parametric regression method keeps track of the last window_size training samples. Predictions are obtained by aggregating the values of the closest n_neighbors stored-samples with respect to a query sample.","title":"KNNRegressor"},{"location":"api/neighbors/KNNRegressor/#parameters","text":"n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. leaf_size ( int ) \u2013 defaults to 30 scipy.spatial.cKDTree parameter. The maximum number of samples that can be stored in one leaf node, which determines from which point the algorithm will switch for a brute-force approach. The bigger this number the faster the tree construction time, but the slower the query time will be. p ( float ) \u2013 defaults to 2 p-norm value for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. Valid values are in the interval \\([1, +\\infty)\\) aggregation_method ( str ) \u2013 defaults to mean The method to aggregate the target values of neighbors. | 'mean' | 'median' | 'weighted_mean' kwargs Other parameters passed to scipy.spatial.cKDTree.","title":"Parameters"},{"location":"api/neighbors/KNNRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... neighbors . KNNRegressor ( window_size = 50 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.441308","title":"Examples"},{"location":"api/neighbors/KNNRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a real target value y . Parameters x y Returns self predict_one Predict the target value of a set of features x . Search the KDTree for the n_neighbors nearest neighbors. Parameters x Returns The prediction. reset Reset estimator.","title":"Methods"},{"location":"api/neighbors/KNNRegressor/#notes","text":"This estimator is not optimal for a mixture of categorical and numerical features. This implementation treats all features from a given stream as numerical.","title":"Notes"},{"location":"api/neighbors/SAMKNNClassifier/","text":"SAMKNNClassifier \u00b6 Self Adjusting Memory coupled with the kNN classifier. The Self Adjusting Memory (SAM) 1 model builds an ensemble with models targeting current or former concepts. SAM is built using two memories: STM for the current concept, and the LTM to retain information about past concepts. A cleaning process is in charge of controlling the size of the STM while keeping the information in the LTM consistent with the STM. Parameters \u00b6 n_neighbors ( int ) \u2013 defaults to 5 number of evaluated nearest neighbors. distance_weighting \u2013 defaults to True Type of weighting of the nearest neighbors. It True will use 'distance'. Otherwise, will use 'uniform' (majority voting). window_size ( int ) \u2013 defaults to 5000 Maximum number of overall stored data points. ltm_size ( float ) \u2013 defaults to 0.4 Proportion of the overall instances that may be used for the LTM. This is only relevant when the maximum number(maxSize) of stored instances is reached. min_stm_size ( int ) \u2013 defaults to 50 Minimum STM size which is evaluated during the STM size adaption. stm_aprox_adaption \u2013 defaults to True Type of STM size adaption. - If True approximates the interleaved test-train error and is significantly faster than the exact version. - If False calculates the interleaved test-train error exactly for each of the evaluated window sizes, which often has to be recalculated from the scratch. - If None , the STM is not adapted at all. If additionally use_ltm=False , then this algorithm is simply a kNN with fixed sliding window size. use_ltm \u2013 defaults to True Specifies whether the LTM should be used at all. Attributes \u00b6 LTMLabels Class labels in the LTM. LTMSamples Samples in the LTM. STMLabels Class labels in the STM. STMSamples Samples in the STM. Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> dataset = synth . ConceptDriftStream ( position = 500 , width = 20 , seed = 1 ) . take ( 1000 ) >>> model = neighbors . SAMKNNClassifier ( window_size = 100 ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) # doctest: +SKIP Accuracy : 56.70 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. Notes \u00b6 This modules uses libNearestNeighbor, a C++ library used to speed up some of the algorithm's computations. When invoking the library's functions it's important to pass the right argument type. Although most of this framework's functionality will work with python standard types, the C++ library will work with 8-bit labels, which is already done by the SAMKNN class, but may be absent in custom classes that use SAMKNN static methods, or other custom functions that use the C++ library. References \u00b6 Losing, Viktor, Barbara Hammer, and Heiko Wersing. \"Knn classifier with self adjusting memory for heterogeneous concept drift.\" In Data Mining (ICDM), 2016 IEEE 16th International Conference on, pp. 291-300. IEEE, 2016. \u21a9","title":"SAMKNNClassifier"},{"location":"api/neighbors/SAMKNNClassifier/#samknnclassifier","text":"Self Adjusting Memory coupled with the kNN classifier. The Self Adjusting Memory (SAM) 1 model builds an ensemble with models targeting current or former concepts. SAM is built using two memories: STM for the current concept, and the LTM to retain information about past concepts. A cleaning process is in charge of controlling the size of the STM while keeping the information in the LTM consistent with the STM.","title":"SAMKNNClassifier"},{"location":"api/neighbors/SAMKNNClassifier/#parameters","text":"n_neighbors ( int ) \u2013 defaults to 5 number of evaluated nearest neighbors. distance_weighting \u2013 defaults to True Type of weighting of the nearest neighbors. It True will use 'distance'. Otherwise, will use 'uniform' (majority voting). window_size ( int ) \u2013 defaults to 5000 Maximum number of overall stored data points. ltm_size ( float ) \u2013 defaults to 0.4 Proportion of the overall instances that may be used for the LTM. This is only relevant when the maximum number(maxSize) of stored instances is reached. min_stm_size ( int ) \u2013 defaults to 50 Minimum STM size which is evaluated during the STM size adaption. stm_aprox_adaption \u2013 defaults to True Type of STM size adaption. - If True approximates the interleaved test-train error and is significantly faster than the exact version. - If False calculates the interleaved test-train error exactly for each of the evaluated window sizes, which often has to be recalculated from the scratch. - If None , the STM is not adapted at all. If additionally use_ltm=False , then this algorithm is simply a kNN with fixed sliding window size. use_ltm \u2013 defaults to True Specifies whether the LTM should be used at all.","title":"Parameters"},{"location":"api/neighbors/SAMKNNClassifier/#attributes","text":"LTMLabels Class labels in the LTM. LTMSamples Samples in the LTM. STMLabels Class labels in the STM. STMSamples Samples in the STM.","title":"Attributes"},{"location":"api/neighbors/SAMKNNClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import neighbors >>> dataset = synth . ConceptDriftStream ( position = 500 , width = 20 , seed = 1 ) . take ( 1000 ) >>> model = neighbors . SAMKNNClassifier ( window_size = 100 ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) # doctest: +SKIP Accuracy : 56.70 %","title":"Examples"},{"location":"api/neighbors/SAMKNNClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/neighbors/SAMKNNClassifier/#notes","text":"This modules uses libNearestNeighbor, a C++ library used to speed up some of the algorithm's computations. When invoking the library's functions it's important to pass the right argument type. Although most of this framework's functionality will work with python standard types, the C++ library will work with 8-bit labels, which is already done by the SAMKNN class, but may be absent in custom classes that use SAMKNN static methods, or other custom functions that use the C++ library.","title":"Notes"},{"location":"api/neighbors/SAMKNNClassifier/#references","text":"Losing, Viktor, Barbara Hammer, and Heiko Wersing. \"Knn classifier with self adjusting memory for heterogeneous concept drift.\" In Data Mining (ICDM), 2016 IEEE 16th International Conference on, pp. 291-300. IEEE, 2016. \u21a9","title":"References"},{"location":"api/neural-net/MLPRegressor/","text":"MLPRegressor \u00b6 Multi-layer Perceptron for regression. This model is still work in progress. Here are some features that still need implementing: learn_one and predict_one just cast the input dict to a single row dataframe and then call learn_many and predict_many respectively. This is very inefficient. - Not all of the optimizers in the optim module can be used as they are not all vectorised. - Emerging and disappearing features are not supported. Each instance/batch has to have the same features. - The gradient haven't been numerically checked. Parameters \u00b6 hidden_dims The dimensions of the hidden layers. For example, specifying (10, 20) means that there are two hidden layers with 10 and 20 neurons, respectively. Note that the number of layers the network contains is equal to the number of hidden layers plus two (to account for the input and output layers). activations The activation functions to use at each layer, including the input and output layers. Therefore you need to specify three activation if you specify one hidden layer. loss ( optim.losses.Loss ) \u2013 defaults to None Loss function. Defaults to optim.losses.Squared . optimizer ( optim.Optimizer ) \u2013 defaults to None Optimizer. Defaults to optim.SGD(.01) . seed ( int ) \u2013 defaults to None Random number generation seed. Set this for reproducibility. Attributes \u00b6 n_layers Return the number of layers in the network. The number of layers is equal to the number of hidden layers plus 2. The 2 accounts for the input layer and the output layer. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import neural_net as nn >>> from river import optim >>> from river import preprocessing as pp >>> from river import metrics >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 5 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . Identity ... ), ... optimizer = optim . SGD ( 1e-3 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.589827 You can also use this to process mini-batches of data. >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 10 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . ReLU ... ), ... optimizer = optim . SGD ( 1e-4 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> batch_size = 32 >>> for epoch in range ( 10 ): ... for xb in pd . read_csv ( dataset . path , chunksize = batch_size ): ... yb = xb . pop ( 'five_thirty_eight' ) ... y_pred = model . predict_many ( xb ) ... model = model . learn_many ( xb , yb ) >>> model . predict_many ( xb ) five_thirty_eight 992 39.361609 993 46.398536 994 42.094086 995 40.195802 996 40.782954 997 40.839678 998 40.896403 999 48.362659 1000 42.021849 Methods \u00b6 call Make predictions. Parameters X ( pandas.core.frame.DataFrame ) clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Train the network. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.frame.DataFrame ) learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_many predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"MLPRegressor"},{"location":"api/neural-net/MLPRegressor/#mlpregressor","text":"Multi-layer Perceptron for regression. This model is still work in progress. Here are some features that still need implementing: learn_one and predict_one just cast the input dict to a single row dataframe and then call learn_many and predict_many respectively. This is very inefficient. - Not all of the optimizers in the optim module can be used as they are not all vectorised. - Emerging and disappearing features are not supported. Each instance/batch has to have the same features. - The gradient haven't been numerically checked.","title":"MLPRegressor"},{"location":"api/neural-net/MLPRegressor/#parameters","text":"hidden_dims The dimensions of the hidden layers. For example, specifying (10, 20) means that there are two hidden layers with 10 and 20 neurons, respectively. Note that the number of layers the network contains is equal to the number of hidden layers plus two (to account for the input and output layers). activations The activation functions to use at each layer, including the input and output layers. Therefore you need to specify three activation if you specify one hidden layer. loss ( optim.losses.Loss ) \u2013 defaults to None Loss function. Defaults to optim.losses.Squared . optimizer ( optim.Optimizer ) \u2013 defaults to None Optimizer. Defaults to optim.SGD(.01) . seed ( int ) \u2013 defaults to None Random number generation seed. Set this for reproducibility.","title":"Parameters"},{"location":"api/neural-net/MLPRegressor/#attributes","text":"n_layers Return the number of layers in the network. The number of layers is equal to the number of hidden layers plus 2. The 2 accounts for the input layer and the output layer.","title":"Attributes"},{"location":"api/neural-net/MLPRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import neural_net as nn >>> from river import optim >>> from river import preprocessing as pp >>> from river import metrics >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 5 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . Identity ... ), ... optimizer = optim . SGD ( 1e-3 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.589827 You can also use this to process mini-batches of data. >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 10 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . ReLU ... ), ... optimizer = optim . SGD ( 1e-4 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> batch_size = 32 >>> for epoch in range ( 10 ): ... for xb in pd . read_csv ( dataset . path , chunksize = batch_size ): ... yb = xb . pop ( 'five_thirty_eight' ) ... y_pred = model . predict_many ( xb ) ... model = model . learn_many ( xb , yb ) >>> model . predict_many ( xb ) five_thirty_eight 992 39.361609 993 46.398536 994 42.094086 995 40.195802 996 40.782954 997 40.839678 998 40.896403 999 48.362659 1000 42.021849","title":"Examples"},{"location":"api/neural-net/MLPRegressor/#methods","text":"call Make predictions. Parameters X ( pandas.core.frame.DataFrame ) clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Train the network. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.frame.DataFrame ) learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_many predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/neural-net/activations/Identity/","text":"Identity \u00b6 Identity activation function. Methods \u00b6 apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Identity"},{"location":"api/neural-net/activations/Identity/#identity","text":"Identity activation function.","title":"Identity"},{"location":"api/neural-net/activations/Identity/#methods","text":"apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Methods"},{"location":"api/neural-net/activations/ReLU/","text":"ReLU \u00b6 Rectified Linear Unit (ReLU) activation function. Methods \u00b6 apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"ReLU"},{"location":"api/neural-net/activations/ReLU/#relu","text":"Rectified Linear Unit (ReLU) activation function.","title":"ReLU"},{"location":"api/neural-net/activations/ReLU/#methods","text":"apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Methods"},{"location":"api/neural-net/activations/Sigmoid/","text":"Sigmoid \u00b6 Sigmoid activation function. Methods \u00b6 apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Sigmoid"},{"location":"api/neural-net/activations/Sigmoid/#sigmoid","text":"Sigmoid activation function.","title":"Sigmoid"},{"location":"api/neural-net/activations/Sigmoid/#methods","text":"apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Methods"},{"location":"api/optim/AMSGrad/","text":"AMSGrad \u00b6 AMSGrad optimizer. Parameters \u00b6 lr ( Union[float, optim.schedulers.Scheduler ] ) \u2013 defaults to 0.1 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 correct_bias \u2013 defaults to True Attributes \u00b6 m ( collections.defaultdict ) v ( collections.defaultdict ) v_hat ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AMSGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.865724 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Reddi, S.J., Kale, S. and Kumar, S., 2019. On the convergence of adam and beyond. arXiv preprint arXiv:1904.09237 \u21a9","title":"AMSGrad"},{"location":"api/optim/AMSGrad/#amsgrad","text":"AMSGrad optimizer.","title":"AMSGrad"},{"location":"api/optim/AMSGrad/#parameters","text":"lr ( Union[float, optim.schedulers.Scheduler ] ) \u2013 defaults to 0.1 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 correct_bias \u2013 defaults to True","title":"Parameters"},{"location":"api/optim/AMSGrad/#attributes","text":"m ( collections.defaultdict ) v ( collections.defaultdict ) v_hat ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AMSGrad/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AMSGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.865724","title":"Examples"},{"location":"api/optim/AMSGrad/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/AMSGrad/#references","text":"Reddi, S.J., Kale, S. and Kumar, S., 2019. On the convergence of adam and beyond. arXiv preprint arXiv:1904.09237 \u21a9","title":"References"},{"location":"api/optim/AdaBound/","text":"AdaBound \u00b6 AdaBound optimizer. Parameters \u00b6 lr \u2013 defaults to 0.001 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 gamma \u2013 defaults to 0.001 final_lr \u2013 defaults to 0.1 Attributes \u00b6 m ( collections.defaultdict ) s ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaBound () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.879004 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Luo, L., Xiong, Y., Liu, Y. and Sun, X., 2019. Adaptive gradient methods with dynamic bound of learning rate. arXiv preprint arXiv:1902.09843 \u21a9","title":"AdaBound"},{"location":"api/optim/AdaBound/#adabound","text":"AdaBound optimizer.","title":"AdaBound"},{"location":"api/optim/AdaBound/#parameters","text":"lr \u2013 defaults to 0.001 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 gamma \u2013 defaults to 0.001 final_lr \u2013 defaults to 0.1","title":"Parameters"},{"location":"api/optim/AdaBound/#attributes","text":"m ( collections.defaultdict ) s ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaBound/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaBound () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.879004","title":"Examples"},{"location":"api/optim/AdaBound/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/AdaBound/#references","text":"Luo, L., Xiong, Y., Liu, Y. and Sun, X., 2019. Adaptive gradient methods with dynamic bound of learning rate. arXiv preprint arXiv:1902.09843 \u21a9","title":"References"},{"location":"api/optim/AdaDelta/","text":"AdaDelta \u00b6 AdaDelta optimizer. Parameters \u00b6 rho \u2013 defaults to 0.95 eps \u2013 defaults to 1e-08 Attributes \u00b6 g2 ( collections.defaultdict ) s2 ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaDelta () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.805611 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Zeiler, M.D., 2012. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701. \u21a9","title":"AdaDelta"},{"location":"api/optim/AdaDelta/#adadelta","text":"AdaDelta optimizer.","title":"AdaDelta"},{"location":"api/optim/AdaDelta/#parameters","text":"rho \u2013 defaults to 0.95 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/AdaDelta/#attributes","text":"g2 ( collections.defaultdict ) s2 ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaDelta/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaDelta () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.805611","title":"Examples"},{"location":"api/optim/AdaDelta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/AdaDelta/#references","text":"Zeiler, M.D., 2012. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701. \u21a9","title":"References"},{"location":"api/optim/AdaGrad/","text":"AdaGrad \u00b6 AdaGrad optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 eps \u2013 defaults to 1e-08 Attributes \u00b6 g2 ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.880143 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Duchi, J., Hazan, E. and Singer, Y., 2011. Adaptive subgradient methods for online learning and stochastic optimization. Journal of machine learning research, 12(Jul), pp.2121-2159. \u21a9","title":"AdaGrad"},{"location":"api/optim/AdaGrad/#adagrad","text":"AdaGrad optimizer.","title":"AdaGrad"},{"location":"api/optim/AdaGrad/#parameters","text":"lr \u2013 defaults to 0.1 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/AdaGrad/#attributes","text":"g2 ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaGrad/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.880143","title":"Examples"},{"location":"api/optim/AdaGrad/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/AdaGrad/#references","text":"Duchi, J., Hazan, E. and Singer, Y., 2011. Adaptive subgradient methods for online learning and stochastic optimization. Journal of machine learning research, 12(Jul), pp.2121-2159. \u21a9","title":"References"},{"location":"api/optim/AdaMax/","text":"AdaMax \u00b6 AdaMax optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 Attributes \u00b6 m ( collections.defaultdict ) v ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaMax () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.875332 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9 Ruder, S., 2016. An overview of gradient descent optimization algorithms. arXiv preprint arXiv:1609.04747. \u21a9","title":"AdaMax"},{"location":"api/optim/AdaMax/#adamax","text":"AdaMax optimizer.","title":"AdaMax"},{"location":"api/optim/AdaMax/#parameters","text":"lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/AdaMax/#attributes","text":"m ( collections.defaultdict ) v ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaMax/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaMax () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.875332","title":"Examples"},{"location":"api/optim/AdaMax/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/AdaMax/#references","text":"Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9 Ruder, S., 2016. An overview of gradient descent optimization algorithms. arXiv preprint arXiv:1609.04747. \u21a9","title":"References"},{"location":"api/optim/Adam/","text":"Adam \u00b6 Adam optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 Attributes \u00b6 m ( collections.defaultdict ) v ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Adam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.86496 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9","title":"Adam"},{"location":"api/optim/Adam/#adam","text":"Adam optimizer.","title":"Adam"},{"location":"api/optim/Adam/#parameters","text":"lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/Adam/#attributes","text":"m ( collections.defaultdict ) v ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/Adam/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Adam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.86496","title":"Examples"},{"location":"api/optim/Adam/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/Adam/#references","text":"Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9","title":"References"},{"location":"api/optim/Averager/","text":"Averager \u00b6 Averaged stochastic gradient descent. This is a wrapper that can be applied to any stochastic gradient descent optimiser. Note that this implementation differs than what may be found elsewhere. Essentially, the average of the weights is usually only used at the end of the optimisation, once all the data has been seen. However, in this implementation the optimiser returns the current averaged weights. Parameters \u00b6 optimizer ( optim.Optimizer ) An optimizer for which the produced weights will be averaged. start ( int ) \u2013 defaults to 0 Indicates the number of iterations to wait before starting the average. Essentially, nothing happens differently before the number of iterations reaches this value. Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Averager ( optim . SGD ( 0.01 ), 100 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.878924 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Bottou, L., 2010. Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT'2010 (pp. 177-186). Physica-Verlag HD. \u21a9 Stochastic Algorithms for One-Pass Learning slides by L\u00e9on Bottou \u21a9 Xu, W., 2011. Towards optimal one pass large scale learning with averaged stochastic gradient descent. arXiv preprint arXiv:1107.2490. \u21a9","title":"Averager"},{"location":"api/optim/Averager/#averager","text":"Averaged stochastic gradient descent. This is a wrapper that can be applied to any stochastic gradient descent optimiser. Note that this implementation differs than what may be found elsewhere. Essentially, the average of the weights is usually only used at the end of the optimisation, once all the data has been seen. However, in this implementation the optimiser returns the current averaged weights.","title":"Averager"},{"location":"api/optim/Averager/#parameters","text":"optimizer ( optim.Optimizer ) An optimizer for which the produced weights will be averaged. start ( int ) \u2013 defaults to 0 Indicates the number of iterations to wait before starting the average. Essentially, nothing happens differently before the number of iterations reaches this value.","title":"Parameters"},{"location":"api/optim/Averager/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/Averager/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Averager ( optim . SGD ( 0.01 ), 100 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.878924","title":"Examples"},{"location":"api/optim/Averager/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/Averager/#references","text":"Bottou, L., 2010. Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT'2010 (pp. 177-186). Physica-Verlag HD. \u21a9 Stochastic Algorithms for One-Pass Learning slides by L\u00e9on Bottou \u21a9 Xu, W., 2011. Towards optimal one pass large scale learning with averaged stochastic gradient descent. arXiv preprint arXiv:1107.2490. \u21a9","title":"References"},{"location":"api/optim/FTRLProximal/","text":"FTRLProximal \u00b6 FTRL-Proximal optimizer. Parameters \u00b6 alpha \u2013 defaults to 0.05 beta \u2013 defaults to 1.0 l1 \u2013 defaults to 0.0 l2 \u2013 defaults to 1.0 Attributes \u00b6 z ( collections.defaultdict ) n ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . FTRLProximal () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.876588 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9 Tensorflow's FtrlOptimizer \u21a9","title":"FTRLProximal"},{"location":"api/optim/FTRLProximal/#ftrlproximal","text":"FTRL-Proximal optimizer.","title":"FTRLProximal"},{"location":"api/optim/FTRLProximal/#parameters","text":"alpha \u2013 defaults to 0.05 beta \u2013 defaults to 1.0 l1 \u2013 defaults to 0.0 l2 \u2013 defaults to 1.0","title":"Parameters"},{"location":"api/optim/FTRLProximal/#attributes","text":"z ( collections.defaultdict ) n ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/FTRLProximal/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . FTRLProximal () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.876588","title":"Examples"},{"location":"api/optim/FTRLProximal/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/FTRLProximal/#references","text":"McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9 Tensorflow's FtrlOptimizer \u21a9","title":"References"},{"location":"api/optim/Momentum/","text":"Momentum \u00b6 Momentum optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Momentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.841645 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Momentum"},{"location":"api/optim/Momentum/#momentum","text":"Momentum optimizer.","title":"Momentum"},{"location":"api/optim/Momentum/#parameters","text":"lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9","title":"Parameters"},{"location":"api/optim/Momentum/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/Momentum/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Momentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.841645","title":"Examples"},{"location":"api/optim/Momentum/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/Nadam/","text":"Nadam \u00b6 Nadam optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Nadam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.865961 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Nadam: A combination of adam and nesterov \u21a9","title":"Nadam"},{"location":"api/optim/Nadam/#nadam","text":"Nadam optimizer.","title":"Nadam"},{"location":"api/optim/Nadam/#parameters","text":"lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/Nadam/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/Nadam/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Nadam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.865961","title":"Examples"},{"location":"api/optim/Nadam/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/Nadam/#references","text":"Nadam: A combination of adam and nesterov \u21a9","title":"References"},{"location":"api/optim/NesterovMomentum/","text":"NesterovMomentum \u00b6 Nesterov Momentum optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . NesterovMomentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.842932 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"NesterovMomentum"},{"location":"api/optim/NesterovMomentum/#nesterovmomentum","text":"Nesterov Momentum optimizer.","title":"NesterovMomentum"},{"location":"api/optim/NesterovMomentum/#parameters","text":"lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9","title":"Parameters"},{"location":"api/optim/NesterovMomentum/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/NesterovMomentum/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . NesterovMomentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.842932","title":"Examples"},{"location":"api/optim/NesterovMomentum/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/Optimizer/","text":"Optimizer \u00b6 Optimizer interface. Every optimizer inherits from this base interface. Parameters \u00b6 lr ( Union[ optim.schedulers.Scheduler , float] ) Attributes \u00b6 learning_rate ( float ) Returns the current learning rate value. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Optimizer"},{"location":"api/optim/Optimizer/#optimizer","text":"Optimizer interface. Every optimizer inherits from this base interface.","title":"Optimizer"},{"location":"api/optim/Optimizer/#parameters","text":"lr ( Union[ optim.schedulers.Scheduler , float] )","title":"Parameters"},{"location":"api/optim/Optimizer/#attributes","text":"learning_rate ( float ) Returns the current learning rate value.","title":"Attributes"},{"location":"api/optim/Optimizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/RMSProp/","text":"RMSProp \u00b6 RMSProp optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 eps \u2013 defaults to 1e-08 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . RMSProp () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.872378 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Divide the gradient by a running average of itsrecent magnitude \u21a9","title":"RMSProp"},{"location":"api/optim/RMSProp/#rmsprop","text":"RMSProp optimizer.","title":"RMSProp"},{"location":"api/optim/RMSProp/#parameters","text":"lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/RMSProp/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/RMSProp/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . RMSProp () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.872378","title":"Examples"},{"location":"api/optim/RMSProp/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/RMSProp/#references","text":"Divide the gradient by a running average of itsrecent magnitude \u21a9","title":"References"},{"location":"api/optim/SGD/","text":"SGD \u00b6 Plain stochastic gradient descent. Parameters \u00b6 lr \u2013 defaults to 0.01 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . SGD ( 0.1 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.878521 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict ) References \u00b6 Robbins, H. and Monro, S., 1951. A stochastic approximation method. The annals of mathematical statistics, pp.400-407 \u21a9","title":"SGD"},{"location":"api/optim/SGD/#sgd","text":"Plain stochastic gradient descent.","title":"SGD"},{"location":"api/optim/SGD/#parameters","text":"lr \u2013 defaults to 0.01","title":"Parameters"},{"location":"api/optim/SGD/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/SGD/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . SGD ( 0.1 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 0.878521","title":"Examples"},{"location":"api/optim/SGD/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. g (dict): A dictionary of gradients. Returns: The updated weights. Parameters w ( dict ) g ( dict )","title":"Methods"},{"location":"api/optim/SGD/#references","text":"Robbins, H. and Monro, S., 1951. A stochastic approximation method. The annals of mathematical statistics, pp.400-407 \u21a9","title":"References"},{"location":"api/optim/initializers/Constant/","text":"Constant \u00b6 Constant initializer which always returns the same value. Parameters \u00b6 value ( float ) Examples \u00b6 >>> from river import optim >>> init = optim . initializers . Constant ( value = 3.14 ) >>> init ( shape = 1 ) 3.14 >>> init ( shape = 2 ) array ([ 3.14 , 3.14 ]) Methods \u00b6 call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Constant"},{"location":"api/optim/initializers/Constant/#constant","text":"Constant initializer which always returns the same value.","title":"Constant"},{"location":"api/optim/initializers/Constant/#parameters","text":"value ( float )","title":"Parameters"},{"location":"api/optim/initializers/Constant/#examples","text":">>> from river import optim >>> init = optim . initializers . Constant ( value = 3.14 ) >>> init ( shape = 1 ) 3.14 >>> init ( shape = 2 ) array ([ 3.14 , 3.14 ])","title":"Examples"},{"location":"api/optim/initializers/Constant/#methods","text":"call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/optim/initializers/Normal/","text":"Normal \u00b6 Random normal initializer which simulate a normal distribution with specified parameters. Parameters \u00b6 mu \u2013 defaults to 0.0 The mean of the normal distribution sigma \u2013 defaults to 1.0 The standard deviation of the normal distribution seed \u2013 defaults to None Random number generation seed that can be set for reproducibility. Examples \u00b6 >>> from river import optim >>> init = optim . initializers . Normal ( mu = 0 , sigma = 1 , seed = 42 ) >>> init ( shape = 1 ) 0.496714 >>> init ( shape = 2 ) array ([ - 0.1382643 , 0.64768854 ]) Methods \u00b6 call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Normal"},{"location":"api/optim/initializers/Normal/#normal","text":"Random normal initializer which simulate a normal distribution with specified parameters.","title":"Normal"},{"location":"api/optim/initializers/Normal/#parameters","text":"mu \u2013 defaults to 0.0 The mean of the normal distribution sigma \u2013 defaults to 1.0 The standard deviation of the normal distribution seed \u2013 defaults to None Random number generation seed that can be set for reproducibility.","title":"Parameters"},{"location":"api/optim/initializers/Normal/#examples","text":">>> from river import optim >>> init = optim . initializers . Normal ( mu = 0 , sigma = 1 , seed = 42 ) >>> init ( shape = 1 ) 0.496714 >>> init ( shape = 2 ) array ([ - 0.1382643 , 0.64768854 ])","title":"Examples"},{"location":"api/optim/initializers/Normal/#methods","text":"call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/optim/initializers/Zeros/","text":"Zeros \u00b6 Constant initializer which always returns zeros. Examples \u00b6 >>> from river import optim >>> init = optim . initializers . Zeros () >>> init ( shape = 1 ) 0.0 >>> init ( shape = 2 ) array ([ 0. , 0. ]) Methods \u00b6 call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Zeros"},{"location":"api/optim/initializers/Zeros/#zeros","text":"Constant initializer which always returns zeros.","title":"Zeros"},{"location":"api/optim/initializers/Zeros/#examples","text":">>> from river import optim >>> init = optim . initializers . Zeros () >>> init ( shape = 1 ) 0.0 >>> init ( shape = 2 ) array ([ 0. , 0. ])","title":"Examples"},{"location":"api/optim/initializers/Zeros/#methods","text":"call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/optim/losses/Absolute/","text":"Absolute \u00b6 Absolute loss, also known as the mean absolute error or L1 loss. Mathematically, it is defined as \\[L = |p_i - y_i|\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = sgn(p_i - y_i)\\] Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Absolute () >>> loss ( - 42 , 42 ) 84 >>> loss . gradient ( 1 , 2 ) 1 >>> loss . gradient ( 2 , 1 ) - 1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Absolute"},{"location":"api/optim/losses/Absolute/#absolute","text":"Absolute loss, also known as the mean absolute error or L1 loss. Mathematically, it is defined as \\[L = |p_i - y_i|\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = sgn(p_i - y_i)\\]","title":"Absolute"},{"location":"api/optim/losses/Absolute/#examples","text":">>> from river import optim >>> loss = optim . losses . Absolute () >>> loss ( - 42 , 42 ) 84 >>> loss . gradient ( 1 , 2 ) 1 >>> loss . gradient ( 2 , 1 ) - 1","title":"Examples"},{"location":"api/optim/losses/Absolute/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/BinaryFocalLoss/","text":"BinaryFocalLoss \u00b6 Binary focal loss. This implements the \"star\" algorithm from the appendix of the focal loss paper. Parameters \u00b6 gamma \u2013 defaults to 2 beta \u2013 defaults to 1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 Lin, T.Y., Goyal, P., Girshick, R., He, K. and Doll\u00e1r, P., 2017. Focal loss for dense object detection. In Proceedings of the IEEE international conference on computer vision (pp. 2980-2988)","title":"BinaryFocalLoss"},{"location":"api/optim/losses/BinaryFocalLoss/#binaryfocalloss","text":"Binary focal loss. This implements the \"star\" algorithm from the appendix of the focal loss paper.","title":"BinaryFocalLoss"},{"location":"api/optim/losses/BinaryFocalLoss/#parameters","text":"gamma \u2013 defaults to 2 beta \u2013 defaults to 1","title":"Parameters"},{"location":"api/optim/losses/BinaryFocalLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/BinaryFocalLoss/#references","text":"Lin, T.Y., Goyal, P., Girshick, R., He, K. and Doll\u00e1r, P., 2017. Focal loss for dense object detection. In Proceedings of the IEEE international conference on computer vision (pp. 2980-2988)","title":"References"},{"location":"api/optim/losses/BinaryLoss/","text":"BinaryLoss \u00b6 A loss appropriate for binary classification tasks. Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"BinaryLoss"},{"location":"api/optim/losses/BinaryLoss/#binaryloss","text":"A loss appropriate for binary classification tasks.","title":"BinaryLoss"},{"location":"api/optim/losses/BinaryLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Cauchy/","text":"Cauchy \u00b6 Cauchy loss function. Parameters \u00b6 C \u2013 defaults to 80 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 \"Effect of MAE\" Kaggle discussion \u21a9 Paris Madness Kaggle kernel \u21a9","title":"Cauchy"},{"location":"api/optim/losses/Cauchy/#cauchy","text":"Cauchy loss function.","title":"Cauchy"},{"location":"api/optim/losses/Cauchy/#parameters","text":"C \u2013 defaults to 80","title":"Parameters"},{"location":"api/optim/losses/Cauchy/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Cauchy/#references","text":"\"Effect of MAE\" Kaggle discussion \u21a9 Paris Madness Kaggle kernel \u21a9","title":"References"},{"location":"api/optim/losses/CrossEntropy/","text":"CrossEntropy \u00b6 Cross entropy loss. This is a generalization of logistic loss to multiple classes. Parameters \u00b6 class_weight ( Dict[Union[bool, str, int], float] ) \u2013 defaults to None A dictionary that indicates what weight to associate with each class. Examples \u00b6 >>> from river import optim >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> loss = optim . losses . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss ( yt , yp )) 1.222454 1.116929 1.437209 1.509797 >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss . gradient ( yt , yp )) { 0 : - 0.70549363 , 1 : 0.34216758 , 2 : 0.36332605 } { 0 : 0.21290077 , 1 : - 0.67271668 , 2 : 0.45981591 } { 0 : 0.42860913 , 1 : 0.33380113 , 2 : - 0.76241026 } { 0 : 0.44941979 , 1 : 0.32962558 , 2 : - 0.77904537 } Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 What is Softmax regression and how is it related to Logistic regression? \u21a9","title":"CrossEntropy"},{"location":"api/optim/losses/CrossEntropy/#crossentropy","text":"Cross entropy loss. This is a generalization of logistic loss to multiple classes.","title":"CrossEntropy"},{"location":"api/optim/losses/CrossEntropy/#parameters","text":"class_weight ( Dict[Union[bool, str, int], float] ) \u2013 defaults to None A dictionary that indicates what weight to associate with each class.","title":"Parameters"},{"location":"api/optim/losses/CrossEntropy/#examples","text":">>> from river import optim >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> loss = optim . losses . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss ( yt , yp )) 1.222454 1.116929 1.437209 1.509797 >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss . gradient ( yt , yp )) { 0 : - 0.70549363 , 1 : 0.34216758 , 2 : 0.36332605 } { 0 : 0.21290077 , 1 : - 0.67271668 , 2 : 0.45981591 } { 0 : 0.42860913 , 1 : 0.33380113 , 2 : - 0.76241026 } { 0 : 0.44941979 , 1 : 0.32962558 , 2 : - 0.77904537 }","title":"Examples"},{"location":"api/optim/losses/CrossEntropy/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/CrossEntropy/#references","text":"What is Softmax regression and how is it related to Logistic regression? \u21a9","title":"References"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/","text":"EpsilonInsensitiveHinge \u00b6 Epsilon-insensitive hinge loss. Parameters \u00b6 eps \u2013 defaults to 0.1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"EpsilonInsensitiveHinge"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#epsiloninsensitivehinge","text":"Epsilon-insensitive hinge loss.","title":"EpsilonInsensitiveHinge"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#parameters","text":"eps \u2013 defaults to 0.1","title":"Parameters"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Hinge/","text":"Hinge \u00b6 Computes the hinge loss. Mathematically, it is defined as \\[L = max(0, 1 - p_i * y_i)\\] It's gradient w.r.t. to \\(p_i\\) is \\[ \\\\frac{\\\\partial L}{\\\\partial y_i} = \\\\left\\{ \\\\begin{array}{ll} \\\\ 0 & p_iy_i \\geqslant 1 \\\\\\\\ \\\\ - y_i & p_iy_i < 1 \\\\end{array} \\\\right. \\] Parameters \u00b6 threshold \u2013 defaults to 1.0 Margin threshold. 1 yield the loss used in SVMs, whilst 0 is equivalent to the loss used in the Perceptron algorithm. Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Hinge ( threshold = 1 ) >>> loss ( 1 , . 2 ) 0.8 >>> loss . gradient ( 1 , . 2 ) - 1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Hinge"},{"location":"api/optim/losses/Hinge/#hinge","text":"Computes the hinge loss. Mathematically, it is defined as \\[L = max(0, 1 - p_i * y_i)\\] It's gradient w.r.t. to \\(p_i\\) is \\[ \\\\frac{\\\\partial L}{\\\\partial y_i} = \\\\left\\{ \\\\begin{array}{ll} \\\\ 0 & p_iy_i \\geqslant 1 \\\\\\\\ \\\\ - y_i & p_iy_i < 1 \\\\end{array} \\\\right. \\]","title":"Hinge"},{"location":"api/optim/losses/Hinge/#parameters","text":"threshold \u2013 defaults to 1.0 Margin threshold. 1 yield the loss used in SVMs, whilst 0 is equivalent to the loss used in the Perceptron algorithm.","title":"Parameters"},{"location":"api/optim/losses/Hinge/#examples","text":">>> from river import optim >>> loss = optim . losses . Hinge ( threshold = 1 ) >>> loss ( 1 , . 2 ) 0.8 >>> loss . gradient ( 1 , . 2 ) - 1","title":"Examples"},{"location":"api/optim/losses/Hinge/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Log/","text":"Log \u00b6 Logarithmic loss. This loss function expects each provided y_pred to be a logit. In other words if must be the raw output of a linear model or a neural network. Parameters \u00b6 weight_pos \u2013 defaults to 1.0 weight_neg \u2013 defaults to 1.0 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 Logit Wikipedia page \u21a9","title":"Log"},{"location":"api/optim/losses/Log/#log","text":"Logarithmic loss. This loss function expects each provided y_pred to be a logit. In other words if must be the raw output of a linear model or a neural network.","title":"Log"},{"location":"api/optim/losses/Log/#parameters","text":"weight_pos \u2013 defaults to 1.0 weight_neg \u2013 defaults to 1.0","title":"Parameters"},{"location":"api/optim/losses/Log/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Log/#references","text":"Logit Wikipedia page \u21a9","title":"References"},{"location":"api/optim/losses/MultiClassLoss/","text":"MultiClassLoss \u00b6 A loss appropriate for multi-class classification tasks. Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"MultiClassLoss"},{"location":"api/optim/losses/MultiClassLoss/#multiclassloss","text":"A loss appropriate for multi-class classification tasks.","title":"MultiClassLoss"},{"location":"api/optim/losses/MultiClassLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Poisson/","text":"Poisson \u00b6 Poisson loss. The Poisson loss is usually more suited for regression with count data than the squared loss. Mathematically, it is defined as \\[L = exp(p_i) - y_i \\times p_i\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = exp(p_i) - y_i\\] Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Poisson"},{"location":"api/optim/losses/Poisson/#poisson","text":"Poisson loss. The Poisson loss is usually more suited for regression with count data than the squared loss. Mathematically, it is defined as \\[L = exp(p_i) - y_i \\times p_i\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = exp(p_i) - y_i\\]","title":"Poisson"},{"location":"api/optim/losses/Poisson/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Quantile/","text":"Quantile \u00b6 Quantile loss. Parameters \u00b6 alpha \u2013 defaults to 0.5 Desired quantile to attain. Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Quantile ( 0.5 ) >>> loss ( 1 , 3 ) 1.0 >>> loss . gradient ( 1 , 3 ) 0.5 >>> loss . gradient ( 3 , 1 ) - 0.5 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 Wikipedia article on quantile regression \u21a9 Derivative from WolframAlpha \u21a9","title":"Quantile"},{"location":"api/optim/losses/Quantile/#quantile","text":"Quantile loss.","title":"Quantile"},{"location":"api/optim/losses/Quantile/#parameters","text":"alpha \u2013 defaults to 0.5 Desired quantile to attain.","title":"Parameters"},{"location":"api/optim/losses/Quantile/#examples","text":">>> from river import optim >>> loss = optim . losses . Quantile ( 0.5 ) >>> loss ( 1 , 3 ) 1.0 >>> loss . gradient ( 1 , 3 ) 0.5 >>> loss . gradient ( 3 , 1 ) - 0.5","title":"Examples"},{"location":"api/optim/losses/Quantile/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Quantile/#references","text":"Wikipedia article on quantile regression \u21a9 Derivative from WolframAlpha \u21a9","title":"References"},{"location":"api/optim/losses/RegressionLoss/","text":"RegressionLoss \u00b6 A loss appropriate for regression tasks. Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"RegressionLoss"},{"location":"api/optim/losses/RegressionLoss/#regressionloss","text":"A loss appropriate for regression tasks.","title":"RegressionLoss"},{"location":"api/optim/losses/RegressionLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Squared/","text":"Squared \u00b6 Squared loss, also known as the L2 loss. Mathematically, it is defined as \\[L = (p_i - y_i) ^ 2\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = 2 imes (p_i - y_i)\\] One thing to note is that this convention is consistent with Vowpal Wabbit and PyTorch, but not with scikit-learn. Indeed, scikit-learn divides the loss by 2, making the 2 disappear in the gradient. Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Squared () >>> loss ( - 4 , 5 ) 81 >>> loss . gradient ( - 4 , 5 ) 18 >>> loss . gradient ( 5 , - 4 ) - 18 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Squared"},{"location":"api/optim/losses/Squared/#squared","text":"Squared loss, also known as the L2 loss. Mathematically, it is defined as \\[L = (p_i - y_i) ^ 2\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = 2 imes (p_i - y_i)\\] One thing to note is that this convention is consistent with Vowpal Wabbit and PyTorch, but not with scikit-learn. Indeed, scikit-learn divides the loss by 2, making the 2 disappear in the gradient.","title":"Squared"},{"location":"api/optim/losses/Squared/#examples","text":">>> from river import optim >>> loss = optim . losses . Squared () >>> loss ( - 4 , 5 ) 81 >>> loss . gradient ( - 4 , 5 ) 18 >>> loss . gradient ( 5 , - 4 ) - 18","title":"Examples"},{"location":"api/optim/losses/Squared/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/schedulers/Constant/","text":"Constant \u00b6 Always uses the same learning rate. Parameters \u00b6 learning_rate ( float ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Constant"},{"location":"api/optim/schedulers/Constant/#constant","text":"Always uses the same learning rate.","title":"Constant"},{"location":"api/optim/schedulers/Constant/#parameters","text":"learning_rate ( float )","title":"Parameters"},{"location":"api/optim/schedulers/Constant/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/optim/schedulers/InverseScaling/","text":"InverseScaling \u00b6 Reduces the learning rate using a power schedule. Assuming an initial learning rate \\(\\eta\\) , the learning rate at step \\(t\\) is: \\[\\\\frac{eta}{(t + 1) ^ p}\\] where \\(p\\) is a user-defined parameter. Parameters \u00b6 learning_rate ( float ) power \u2013 defaults to 0.5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"InverseScaling"},{"location":"api/optim/schedulers/InverseScaling/#inversescaling","text":"Reduces the learning rate using a power schedule. Assuming an initial learning rate \\(\\eta\\) , the learning rate at step \\(t\\) is: \\[\\\\frac{eta}{(t + 1) ^ p}\\] where \\(p\\) is a user-defined parameter.","title":"InverseScaling"},{"location":"api/optim/schedulers/InverseScaling/#parameters","text":"learning_rate ( float ) power \u2013 defaults to 0.5","title":"Parameters"},{"location":"api/optim/schedulers/InverseScaling/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/optim/schedulers/Optimal/","text":"Optimal \u00b6 Optimal learning schedule as proposed by L\u00e9on Bottou. Parameters \u00b6 loss ( optim.losses.Loss ) alpha \u2013 defaults to 0.0001 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int ) References \u00b6 Bottou, L., 2012. Stochastic gradient descent tricks. In Neural networks: Tricks of the trade (pp. 421-436). Springer, Berlin, Heidelberg. \u21a9","title":"Optimal"},{"location":"api/optim/schedulers/Optimal/#optimal","text":"Optimal learning schedule as proposed by L\u00e9on Bottou.","title":"Optimal"},{"location":"api/optim/schedulers/Optimal/#parameters","text":"loss ( optim.losses.Loss ) alpha \u2013 defaults to 0.0001","title":"Parameters"},{"location":"api/optim/schedulers/Optimal/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/optim/schedulers/Optimal/#references","text":"Bottou, L., 2012. Stochastic gradient descent tricks. In Neural networks: Tricks of the trade (pp. 421-436). Springer, Berlin, Heidelberg. \u21a9","title":"References"},{"location":"api/optim/schedulers/Scheduler/","text":"Scheduler \u00b6 Can be used to program the learning rate schedule of an optim.Optimizer . Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Scheduler"},{"location":"api/optim/schedulers/Scheduler/#scheduler","text":"Can be used to program the learning rate schedule of an optim.Optimizer .","title":"Scheduler"},{"location":"api/optim/schedulers/Scheduler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/preprocessing/AdaptiveStandardScaler/","text":"AdaptiveStandardScaler \u00b6 Scales data using exponentially weighted moving average and variance. Under the hood, a exponentially weighted running mean and variance are maintained for each feature. This can potentially provide better results for drifting data in comparison to preprocessing.StandardScaler . Indeed, the latter computes a global mean and variance for each feature, whereas this scaler weights data in proportion to their recency. Parameters \u00b6 alpha \u2013 defaults to 0.3 This parameter is passed to stats.EWVar . It is expected to be in [0, 1]. More weight is assigned to recent samples the closer alpha is to 1. Examples \u00b6 Consider the following series which contains a positive trend. >>> import random >>> random . seed ( 42 ) >>> X = [ ... { 'x' : random . uniform ( 4 + i , 6 + i )} ... for i in range ( 8 ) ... ] >>> for x in X : ... print ( x ) { 'x' : 5.278 } { 'x' : 5.050 } { 'x' : 6.550 } { 'x' : 7.446 } { 'x' : 9.472 } { 'x' : 10.353 } { 'x' : 11.784 } { 'x' : 11.173 } This scaler works well with this kind of data because it uses statistics that assign higher weight to more recent data. >>> from river import preprocessing >>> scaler = preprocessing . AdaptiveStandardScaler ( alpha =. 6 ) >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 0.816 } { 'x' : 0.812 } { 'x' : 0.695 } { 'x' : 0.754 } { 'x' : 0.598 } { 'x' : 0.651 } { 'x' : 0.124 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"AdaptiveStandardScaler"},{"location":"api/preprocessing/AdaptiveStandardScaler/#adaptivestandardscaler","text":"Scales data using exponentially weighted moving average and variance. Under the hood, a exponentially weighted running mean and variance are maintained for each feature. This can potentially provide better results for drifting data in comparison to preprocessing.StandardScaler . Indeed, the latter computes a global mean and variance for each feature, whereas this scaler weights data in proportion to their recency.","title":"AdaptiveStandardScaler"},{"location":"api/preprocessing/AdaptiveStandardScaler/#parameters","text":"alpha \u2013 defaults to 0.3 This parameter is passed to stats.EWVar . It is expected to be in [0, 1]. More weight is assigned to recent samples the closer alpha is to 1.","title":"Parameters"},{"location":"api/preprocessing/AdaptiveStandardScaler/#examples","text":"Consider the following series which contains a positive trend. >>> import random >>> random . seed ( 42 ) >>> X = [ ... { 'x' : random . uniform ( 4 + i , 6 + i )} ... for i in range ( 8 ) ... ] >>> for x in X : ... print ( x ) { 'x' : 5.278 } { 'x' : 5.050 } { 'x' : 6.550 } { 'x' : 7.446 } { 'x' : 9.472 } { 'x' : 10.353 } { 'x' : 11.784 } { 'x' : 11.173 } This scaler works well with this kind of data because it uses statistics that assign higher weight to more recent data. >>> from river import preprocessing >>> scaler = preprocessing . AdaptiveStandardScaler ( alpha =. 6 ) >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 0.816 } { 'x' : 0.812 } { 'x' : 0.695 } { 'x' : 0.754 } { 'x' : 0.598 } { 'x' : 0.651 } { 'x' : 0.124 }","title":"Examples"},{"location":"api/preprocessing/AdaptiveStandardScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/Binarizer/","text":"Binarizer \u00b6 Binarizes the data to 0 or 1 according to a threshold. Parameters \u00b6 threshold \u2013 defaults to 0.0 Values above this are replaced by 1 and the others by 0. dtype \u2013 defaults to <class 'bool'> The desired data type to apply. Examples \u00b6 >>> import river >>> import numpy as np >>> rng = np . random . RandomState ( 42 ) >>> X = [{ 'x1' : v , 'x2' : int ( v )} for v in rng . uniform ( low =- 4 , high = 4 , size = 6 )] >>> binarizer = river . preprocessing . Binarizer () >>> for x in X : ... print ( binarizer . learn_one ( x ) . transform_one ( x )) { 'x1' : False , 'x2' : False } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : False } { 'x1' : False , 'x2' : False } { 'x1' : False , 'x2' : False } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Binarizer"},{"location":"api/preprocessing/Binarizer/#binarizer","text":"Binarizes the data to 0 or 1 according to a threshold.","title":"Binarizer"},{"location":"api/preprocessing/Binarizer/#parameters","text":"threshold \u2013 defaults to 0.0 Values above this are replaced by 1 and the others by 0. dtype \u2013 defaults to <class 'bool'> The desired data type to apply.","title":"Parameters"},{"location":"api/preprocessing/Binarizer/#examples","text":">>> import river >>> import numpy as np >>> rng = np . random . RandomState ( 42 ) >>> X = [{ 'x1' : v , 'x2' : int ( v )} for v in rng . uniform ( low =- 4 , high = 4 , size = 6 )] >>> binarizer = river . preprocessing . Binarizer () >>> for x in X : ... print ( binarizer . learn_one ( x ) . transform_one ( x )) { 'x1' : False , 'x2' : False } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : False } { 'x1' : False , 'x2' : False } { 'x1' : False , 'x2' : False }","title":"Examples"},{"location":"api/preprocessing/Binarizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/FeatureHasher/","text":"FeatureHasher \u00b6 Implements the hashing trick. Each pair of (name, value) features is hashed into a random integer. A module operator is then used to make sure the hash is in a certain range. We use the Murmurhash implementation from scikit-learn. Parameters \u00b6 n_features \u2013 defaults to 1048576 The number by which each hash will be moduloed by. seed ( int ) \u2013 defaults to None Set the seed to produce identical results. Examples \u00b6 >>> import river >>> hasher = river . preprocessing . FeatureHasher ( n_features = 10 , seed = 42 ) >>> X = [ ... { 'dog' : 1 , 'cat' : 2 , 'elephant' : 4 }, ... { 'dog' : 2 , 'run' : 5 } ... ] >>> for x in X : ... print ( hasher . transform_one ( x )) Counter ({ 1 : 4 , 9 : 2 , 8 : 1 }) Counter ({ 4 : 5 , 8 : 2 }) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Wikipedia article on feature vectorization using the hashing trick \u21a9","title":"FeatureHasher"},{"location":"api/preprocessing/FeatureHasher/#featurehasher","text":"Implements the hashing trick. Each pair of (name, value) features is hashed into a random integer. A module operator is then used to make sure the hash is in a certain range. We use the Murmurhash implementation from scikit-learn.","title":"FeatureHasher"},{"location":"api/preprocessing/FeatureHasher/#parameters","text":"n_features \u2013 defaults to 1048576 The number by which each hash will be moduloed by. seed ( int ) \u2013 defaults to None Set the seed to produce identical results.","title":"Parameters"},{"location":"api/preprocessing/FeatureHasher/#examples","text":">>> import river >>> hasher = river . preprocessing . FeatureHasher ( n_features = 10 , seed = 42 ) >>> X = [ ... { 'dog' : 1 , 'cat' : 2 , 'elephant' : 4 }, ... { 'dog' : 2 , 'run' : 5 } ... ] >>> for x in X : ... print ( hasher . transform_one ( x )) Counter ({ 1 : 4 , 9 : 2 , 8 : 1 }) Counter ({ 4 : 5 , 8 : 2 })","title":"Examples"},{"location":"api/preprocessing/FeatureHasher/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/FeatureHasher/#references","text":"Wikipedia article on feature vectorization using the hashing trick \u21a9","title":"References"},{"location":"api/preprocessing/LDA/","text":"LDA \u00b6 Online Latent Dirichlet Allocation with Infinite Vocabulary. Latent Dirichlet allocation (LDA) is a probabilistic approach for exploring topics in document collections. The key advantage of this variant is that it assumes an infinite vocabulary, meaning that the set of tokens does not have to known in advance, as opposed to the implementation from sklearn The results produced by this implementation are identical to those from the original implementation proposed by the method's authors. This class takes as input token counts. Therefore, it requires you to tokenize beforehand. You can do so by using a feature_extraction.BagOfWords instance, as shown in the example below. Parameters \u00b6 n_components \u2013 defaults to 10 Number of topics of the latent Drichlet allocation. number_of_documents \u2013 defaults to 1000000.0 Estimated number of documents. alpha_theta \u2013 defaults to 0.5 Hyper-parameter of the Dirichlet distribution of topics. alpha_beta \u2013 defaults to 100.0 Hyper-parameter of the Dirichlet process of distribution over words. tau \u2013 defaults to 64.0 Learning inertia to prevent premature convergence. kappa \u2013 defaults to 0.75 The learning rate kappa controls how quickly new parameters estimates replace the old ones. kappa \u2208 (0.5, 1] is required for convergence. vocab_prune_interval \u2013 defaults to 10 Interval at which to refresh the words topics distribution. number_of_samples \u2013 defaults to 10 Number of iteration to computes documents topics distribution. ranking_smooth_factor \u2013 defaults to 1e-12 burn_in_sweeps \u2013 defaults to 5 Number of iteration necessaries while analyzing a document before updating document topics distribution. maximum_size_vocabulary \u2013 defaults to 4000 Maximum size of the stored vocabulary. seed ( int ) \u2013 defaults to None Random number seed used for reproducibility. Attributes \u00b6 counter ( int ) The current number of observed documents. truncation_size_prime ( int ) Number of distincts words stored in the vocabulary. Updated before processing a document. truncation_size ( int ) Number of distincts words stored in the vocabulary. Updated after processing a document. word_to_index ( dict ) Words as keys and indexes as values. index_to_word ( dict ) Indexes as keys and words as values. nu_1 ( dict ) Weights of the words. Component of the variational inference. nu_2 ( dict ) Weights of the words. Component of the variational inference. Examples \u00b6 >>> from river import compose >>> from river import feature_extraction >>> from river import preprocessing >>> X = [ ... 'weather cold' , ... 'weather hot dry' , ... 'weather cold rainy' , ... 'weather hot' , ... 'weather cold humid' , ... ] >>> lda = compose . Pipeline ( ... feature_extraction . BagOfWords (), ... preprocessing . LDA ( ... n_components = 2 , ... number_of_documents = 60 , ... seed = 42 ... ) ... ) >>> for x in X : ... lda = lda . learn_one ( x ) ... topics = lda . transform_one ( x ) ... print ( topics ) { 0 : 2.5 , 1 : 0.5 } { 0 : 2.5 , 1 : 1.5 } { 0 : 1.5 , 1 : 2.5 } { 0 : 1.5 , 1 : 1.5 } { 0 : 0.5 , 1 : 3.5 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self learn_transform_one Equivalent to lda.learn_one(x).transform_one(x) s, but faster. Parameters x ( dict ) Returns dict : Component attributions for the input document. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Zhai, K. and Boyd-Graber, J., 2013, February. Online latent Dirichlet allocation with infinite vocabulary. In International Conference on Machine Learning (pp. 561-569). \u21a9 PyInfVoc on GitHub \u21a9","title":"LDA"},{"location":"api/preprocessing/LDA/#lda","text":"Online Latent Dirichlet Allocation with Infinite Vocabulary. Latent Dirichlet allocation (LDA) is a probabilistic approach for exploring topics in document collections. The key advantage of this variant is that it assumes an infinite vocabulary, meaning that the set of tokens does not have to known in advance, as opposed to the implementation from sklearn The results produced by this implementation are identical to those from the original implementation proposed by the method's authors. This class takes as input token counts. Therefore, it requires you to tokenize beforehand. You can do so by using a feature_extraction.BagOfWords instance, as shown in the example below.","title":"LDA"},{"location":"api/preprocessing/LDA/#parameters","text":"n_components \u2013 defaults to 10 Number of topics of the latent Drichlet allocation. number_of_documents \u2013 defaults to 1000000.0 Estimated number of documents. alpha_theta \u2013 defaults to 0.5 Hyper-parameter of the Dirichlet distribution of topics. alpha_beta \u2013 defaults to 100.0 Hyper-parameter of the Dirichlet process of distribution over words. tau \u2013 defaults to 64.0 Learning inertia to prevent premature convergence. kappa \u2013 defaults to 0.75 The learning rate kappa controls how quickly new parameters estimates replace the old ones. kappa \u2208 (0.5, 1] is required for convergence. vocab_prune_interval \u2013 defaults to 10 Interval at which to refresh the words topics distribution. number_of_samples \u2013 defaults to 10 Number of iteration to computes documents topics distribution. ranking_smooth_factor \u2013 defaults to 1e-12 burn_in_sweeps \u2013 defaults to 5 Number of iteration necessaries while analyzing a document before updating document topics distribution. maximum_size_vocabulary \u2013 defaults to 4000 Maximum size of the stored vocabulary. seed ( int ) \u2013 defaults to None Random number seed used for reproducibility.","title":"Parameters"},{"location":"api/preprocessing/LDA/#attributes","text":"counter ( int ) The current number of observed documents. truncation_size_prime ( int ) Number of distincts words stored in the vocabulary. Updated before processing a document. truncation_size ( int ) Number of distincts words stored in the vocabulary. Updated after processing a document. word_to_index ( dict ) Words as keys and indexes as values. index_to_word ( dict ) Indexes as keys and words as values. nu_1 ( dict ) Weights of the words. Component of the variational inference. nu_2 ( dict ) Weights of the words. Component of the variational inference.","title":"Attributes"},{"location":"api/preprocessing/LDA/#examples","text":">>> from river import compose >>> from river import feature_extraction >>> from river import preprocessing >>> X = [ ... 'weather cold' , ... 'weather hot dry' , ... 'weather cold rainy' , ... 'weather hot' , ... 'weather cold humid' , ... ] >>> lda = compose . Pipeline ( ... feature_extraction . BagOfWords (), ... preprocessing . LDA ( ... n_components = 2 , ... number_of_documents = 60 , ... seed = 42 ... ) ... ) >>> for x in X : ... lda = lda . learn_one ( x ) ... topics = lda . transform_one ( x ) ... print ( topics ) { 0 : 2.5 , 1 : 0.5 } { 0 : 2.5 , 1 : 1.5 } { 0 : 1.5 , 1 : 2.5 } { 0 : 1.5 , 1 : 1.5 } { 0 : 0.5 , 1 : 3.5 }","title":"Examples"},{"location":"api/preprocessing/LDA/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self learn_transform_one Equivalent to lda.learn_one(x).transform_one(x) s, but faster. Parameters x ( dict ) Returns dict : Component attributions for the input document. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/LDA/#references","text":"Zhai, K. and Boyd-Graber, J., 2013, February. Online latent Dirichlet allocation with infinite vocabulary. In International Conference on Machine Learning (pp. 561-569). \u21a9 PyInfVoc on GitHub \u21a9","title":"References"},{"location":"api/preprocessing/MaxAbsScaler/","text":"MaxAbsScaler \u00b6 Scales the data to a [-1, 1] range based on absolute maximum. Under the hood a running absolute max is maintained. This scaler is meant for data that is already centered at zero or sparse data. It does not shift/center the data, and thus does not destroy any sparsity. Attributes \u00b6 abs_max ( dict ) Mapping between features and instances of stats.AbsMax . Examples \u00b6 >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MaxAbsScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 1.0 } { 'x' : 0.767216 } { 'x' : 0.861940 } { 'x' : 0.842308 } { 'x' : 1.0 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"MaxAbsScaler"},{"location":"api/preprocessing/MaxAbsScaler/#maxabsscaler","text":"Scales the data to a [-1, 1] range based on absolute maximum. Under the hood a running absolute max is maintained. This scaler is meant for data that is already centered at zero or sparse data. It does not shift/center the data, and thus does not destroy any sparsity.","title":"MaxAbsScaler"},{"location":"api/preprocessing/MaxAbsScaler/#attributes","text":"abs_max ( dict ) Mapping between features and instances of stats.AbsMax .","title":"Attributes"},{"location":"api/preprocessing/MaxAbsScaler/#examples","text":">>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MaxAbsScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 1.0 } { 'x' : 0.767216 } { 'x' : 0.861940 } { 'x' : 0.842308 } { 'x' : 1.0 }","title":"Examples"},{"location":"api/preprocessing/MaxAbsScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/MinMaxScaler/","text":"MinMaxScaler \u00b6 Scales the data to a fixed range from 0 to 1. Under the hood a running min and a running peak to peak (max - min) are maintained. Attributes \u00b6 min ( dict ) Mapping between features and instances of stats.Min . max ( dict ) Mapping between features and instances of stats.Max . Examples \u00b6 >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MinMaxScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : 0.0 } { 'x' : 0.406920 } { 'x' : 0.322582 } { 'x' : 1.0 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"MinMaxScaler"},{"location":"api/preprocessing/MinMaxScaler/#minmaxscaler","text":"Scales the data to a fixed range from 0 to 1. Under the hood a running min and a running peak to peak (max - min) are maintained.","title":"MinMaxScaler"},{"location":"api/preprocessing/MinMaxScaler/#attributes","text":"min ( dict ) Mapping between features and instances of stats.Min . max ( dict ) Mapping between features and instances of stats.Max .","title":"Attributes"},{"location":"api/preprocessing/MinMaxScaler/#examples","text":">>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MinMaxScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : 0.0 } { 'x' : 0.406920 } { 'x' : 0.322582 } { 'x' : 1.0 }","title":"Examples"},{"location":"api/preprocessing/MinMaxScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/Normalizer/","text":"Normalizer \u00b6 Scales a set of features so that it has unit norm. This is particularly useful when used after a feature_extraction.TFIDF . Parameters \u00b6 order \u2013 defaults to 2 Order of the norm (e.g. 2 corresponds to the \\(L^2\\) norm). Examples \u00b6 >>> from river import preprocessing >>> from river import stream >>> scaler = preprocessing . Normalizer ( order = 2 ) >>> X = [[ 4 , 1 , 2 , 2 ], ... [ 1 , 3 , 9 , 3 ], ... [ 5 , 7 , 5 , 1 ]] >>> for x , _ in stream . iter_array ( X ): ... print ( scaler . transform_one ( x )) { 0 : 0.8 , 1 : 0.2 , 2 : 0.4 , 3 : 0.4 } { 0 : 0.1 , 1 : 0.3 , 2 : 0.9 , 3 : 0.3 } { 0 : 0.5 , 1 : 0.7 , 2 : 0.5 , 3 : 0.1 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Normalizer"},{"location":"api/preprocessing/Normalizer/#normalizer","text":"Scales a set of features so that it has unit norm. This is particularly useful when used after a feature_extraction.TFIDF .","title":"Normalizer"},{"location":"api/preprocessing/Normalizer/#parameters","text":"order \u2013 defaults to 2 Order of the norm (e.g. 2 corresponds to the \\(L^2\\) norm).","title":"Parameters"},{"location":"api/preprocessing/Normalizer/#examples","text":">>> from river import preprocessing >>> from river import stream >>> scaler = preprocessing . Normalizer ( order = 2 ) >>> X = [[ 4 , 1 , 2 , 2 ], ... [ 1 , 3 , 9 , 3 ], ... [ 5 , 7 , 5 , 1 ]] >>> for x , _ in stream . iter_array ( X ): ... print ( scaler . transform_one ( x )) { 0 : 0.8 , 1 : 0.2 , 2 : 0.4 , 3 : 0.4 } { 0 : 0.1 , 1 : 0.3 , 2 : 0.9 , 3 : 0.3 } { 0 : 0.5 , 1 : 0.7 , 2 : 0.5 , 3 : 0.1 }","title":"Examples"},{"location":"api/preprocessing/Normalizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/OneHotEncoder/","text":"OneHotEncoder \u00b6 One-hot encoding. This transformer will encode every feature it is provided it with. You can apply it to a subset of features by composing it with compose.Select or compose.SelectType . Parameters \u00b6 sparse \u2013 defaults to False Whether or not 0s should be made explicit or not. Examples \u00b6 Let us first create an example dataset. >>> from pprint import pprint >>> import random >>> import string >>> random . seed ( 42 ) >>> alphabet = list ( string . ascii_lowercase ) >>> X = [ ... { ... 'c1' : random . choice ( alphabet ), ... 'c2' : random . choice ( alphabet ), ... } ... for _ in range ( 4 ) ... ] >>> pprint ( X ) [{ 'c1' : 'u' , 'c2' : 'd' }, { 'c1' : 'a' , 'c2' : 'x' }, { 'c1' : 'i' , 'c2' : 'h' }, { 'c1' : 'h' , 'c2' : 'e' }] We can now apply one-hot encoding. All the provided are one-hot encoded, there is therefore no need to specify which features to encode. >>> import river.preprocessing >>> oh = river . preprocessing . OneHotEncoder ( sparse = True ) >>> for x in X : ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c2_x' : 1 } { 'c1_i' : 1 , 'c2_h' : 1 } { 'c1_h' : 1 , 'c2_e' : 1 } The sparse parameter can be set to False in order to include the values that are not present in the output. >>> oh = river . preprocessing . OneHotEncoder ( sparse = False ) >>> for x in X [: 2 ]: ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2_d' : 0 , 'c2_x' : 1 } A subset of the features can be one-hot encoded by using an instance of compose.Select . >>> from river import compose >>> pp = compose . Select ( 'c1' ) | river . preprocessing . OneHotEncoder () >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 } You can preserve the c2 feature by using a union: >>> pp = compose . Select ( 'c1' ) | river . preprocessing . OneHotEncoder () >>> pp += compose . Select ( 'c2' ) >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 , 'c2' : 'd' } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2' : 'x' } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 , 'c2' : 'h' } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 , 'c2' : 'e' } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values.","title":"OneHotEncoder"},{"location":"api/preprocessing/OneHotEncoder/#onehotencoder","text":"One-hot encoding. This transformer will encode every feature it is provided it with. You can apply it to a subset of features by composing it with compose.Select or compose.SelectType .","title":"OneHotEncoder"},{"location":"api/preprocessing/OneHotEncoder/#parameters","text":"sparse \u2013 defaults to False Whether or not 0s should be made explicit or not.","title":"Parameters"},{"location":"api/preprocessing/OneHotEncoder/#examples","text":"Let us first create an example dataset. >>> from pprint import pprint >>> import random >>> import string >>> random . seed ( 42 ) >>> alphabet = list ( string . ascii_lowercase ) >>> X = [ ... { ... 'c1' : random . choice ( alphabet ), ... 'c2' : random . choice ( alphabet ), ... } ... for _ in range ( 4 ) ... ] >>> pprint ( X ) [{ 'c1' : 'u' , 'c2' : 'd' }, { 'c1' : 'a' , 'c2' : 'x' }, { 'c1' : 'i' , 'c2' : 'h' }, { 'c1' : 'h' , 'c2' : 'e' }] We can now apply one-hot encoding. All the provided are one-hot encoded, there is therefore no need to specify which features to encode. >>> import river.preprocessing >>> oh = river . preprocessing . OneHotEncoder ( sparse = True ) >>> for x in X : ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c2_x' : 1 } { 'c1_i' : 1 , 'c2_h' : 1 } { 'c1_h' : 1 , 'c2_e' : 1 } The sparse parameter can be set to False in order to include the values that are not present in the output. >>> oh = river . preprocessing . OneHotEncoder ( sparse = False ) >>> for x in X [: 2 ]: ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2_d' : 0 , 'c2_x' : 1 } A subset of the features can be one-hot encoded by using an instance of compose.Select . >>> from river import compose >>> pp = compose . Select ( 'c1' ) | river . preprocessing . OneHotEncoder () >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 } You can preserve the c2 feature by using a union: >>> pp = compose . Select ( 'c1' ) | river . preprocessing . OneHotEncoder () >>> pp += compose . Select ( 'c2' ) >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 , 'c2' : 'd' } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2' : 'x' } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 , 'c2' : 'h' } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 , 'c2' : 'e' }","title":"Examples"},{"location":"api/preprocessing/OneHotEncoder/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/PreviousImputer/","text":"PreviousImputer \u00b6 Imputes missing values by using the most recent value. Examples \u00b6 >>> from river import preprocessing >>> imputer = preprocessing . PreviousImputer () >>> imputer = imputer . learn_one ({ 'x' : 1 , 'y' : 2 }) >>> imputer . transform_one ({ 'y' : None }) { 'y' : 2 } >>> imputer . transform_one ({ 'x' : None }) { 'x' : 1 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"PreviousImputer"},{"location":"api/preprocessing/PreviousImputer/#previousimputer","text":"Imputes missing values by using the most recent value.","title":"PreviousImputer"},{"location":"api/preprocessing/PreviousImputer/#examples","text":">>> from river import preprocessing >>> imputer = preprocessing . PreviousImputer () >>> imputer = imputer . learn_one ({ 'x' : 1 , 'y' : 2 }) >>> imputer . transform_one ({ 'y' : None }) { 'y' : 2 } >>> imputer . transform_one ({ 'x' : None }) { 'x' : 1 }","title":"Examples"},{"location":"api/preprocessing/PreviousImputer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/RobustScaler/","text":"RobustScaler \u00b6 Scale features using statistics that are robust to outliers. This Scaler removes the median and scales the data according to the interquantile range. Parameters \u00b6 with_centering \u2013 defaults to True Whether to centre the data before scaling. with_scaling \u2013 defaults to True Whether to scale data to IQR. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Attributes \u00b6 median ( dict ) Mapping between features and instances of stats.Quantile(0.5) . iqr ( dict ) Mapping between features and instances of stats.IQR . Examples \u00b6 >>> from pprint import pprint >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> pprint ( X ) [{ 'x' : 10.557707 }, { 'x' : 8.100043 }, { 'x' : 9.100117 }, { 'x' : 8.892842 }, { 'x' : 10.945884 }] >>> scaler = preprocessing . RobustScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 1.0 } { 'x' : 0.0 } { 'x' : - 0.124499 } { 'x' : 1.108659 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"RobustScaler"},{"location":"api/preprocessing/RobustScaler/#robustscaler","text":"Scale features using statistics that are robust to outliers. This Scaler removes the median and scales the data according to the interquantile range.","title":"RobustScaler"},{"location":"api/preprocessing/RobustScaler/#parameters","text":"with_centering \u2013 defaults to True Whether to centre the data before scaling. with_scaling \u2013 defaults to True Whether to scale data to IQR. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1.","title":"Parameters"},{"location":"api/preprocessing/RobustScaler/#attributes","text":"median ( dict ) Mapping between features and instances of stats.Quantile(0.5) . iqr ( dict ) Mapping between features and instances of stats.IQR .","title":"Attributes"},{"location":"api/preprocessing/RobustScaler/#examples","text":">>> from pprint import pprint >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> pprint ( X ) [{ 'x' : 10.557707 }, { 'x' : 8.100043 }, { 'x' : 9.100117 }, { 'x' : 8.892842 }, { 'x' : 10.945884 }] >>> scaler = preprocessing . RobustScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 1.0 } { 'x' : 0.0 } { 'x' : - 0.124499 } { 'x' : 1.108659 }","title":"Examples"},{"location":"api/preprocessing/RobustScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/StandardScaler/","text":"StandardScaler \u00b6 Scales the data so that it has zero mean and unit variance. Under the hood, a running mean and a running variance are maintained. The scaling is slightly different than when scaling the data in batch because the exact means and variances are not known in advance. However, this doesn't have a detrimental impact on performance in the long run. This transformer supports mini-batches as well as single instances. In the mini-batch case, the number of columns and the ordering of the columns are allowed to change between subsequent calls. In other words, this transformer will keep working even if you add and/or remove features every time you call learn_many and transform_many . Examples \u00b6 >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 ), 'y' : random . uniform ( 8 , 12 )} for _ in range ( 6 )] >>> for x in X : ... print ( x ) { 'x' : 10.557 , 'y' : 8.100 } { 'x' : 9.100 , 'y' : 8.892 } { 'x' : 10.945 , 'y' : 10.706 } { 'x' : 11.568 , 'y' : 8.347 } { 'x' : 9.687 , 'y' : 8.119 } { 'x' : 8.874 , 'y' : 10.021 } >>> scaler = preprocessing . StandardScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 , 'y' : 0.0 } { 'x' : - 0.999 , 'y' : 0.999 } { 'x' : 0.937 , 'y' : 1.350 } { 'x' : 1.129 , 'y' : - 0.651 } { 'x' : - 0.776 , 'y' : - 0.729 } { 'x' : - 1.274 , 'y' : 0.992 } This transformer also supports mini-batch updates. You can call learn_many and provide a pandas.DataFrame : >>> import pandas as pd >>> X = pd . DataFrame . from_dict ( X ) >>> scaler = preprocessing . StandardScaler () >>> scaler = scaler . learn_many ( X [: 3 ]) >>> scaler = scaler . learn_many ( X [ 3 :]) You can then call transform_many to scale a mini-batch of features: >>> scaler . transform_many ( X ) x y 0 0.444600 - 0.933384 1 - 1.044259 - 0.138809 2 0.841106 1.679208 3 1.477301 - 0.685117 4 - 0.444084 - 0.914195 5 - 1.274664 0.992296 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. Note that the update formulas for mean and variance are slightly different than in the single instance case, but they produce exactly the same result. Parameters X ( pandas.core.frame.DataFrame ) learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_many Scale a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Welford's Method (and Friends) \u21a9 Batch updates for simple statistics \u21a9","title":"StandardScaler"},{"location":"api/preprocessing/StandardScaler/#standardscaler","text":"Scales the data so that it has zero mean and unit variance. Under the hood, a running mean and a running variance are maintained. The scaling is slightly different than when scaling the data in batch because the exact means and variances are not known in advance. However, this doesn't have a detrimental impact on performance in the long run. This transformer supports mini-batches as well as single instances. In the mini-batch case, the number of columns and the ordering of the columns are allowed to change between subsequent calls. In other words, this transformer will keep working even if you add and/or remove features every time you call learn_many and transform_many .","title":"StandardScaler"},{"location":"api/preprocessing/StandardScaler/#examples","text":">>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 ), 'y' : random . uniform ( 8 , 12 )} for _ in range ( 6 )] >>> for x in X : ... print ( x ) { 'x' : 10.557 , 'y' : 8.100 } { 'x' : 9.100 , 'y' : 8.892 } { 'x' : 10.945 , 'y' : 10.706 } { 'x' : 11.568 , 'y' : 8.347 } { 'x' : 9.687 , 'y' : 8.119 } { 'x' : 8.874 , 'y' : 10.021 } >>> scaler = preprocessing . StandardScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 , 'y' : 0.0 } { 'x' : - 0.999 , 'y' : 0.999 } { 'x' : 0.937 , 'y' : 1.350 } { 'x' : 1.129 , 'y' : - 0.651 } { 'x' : - 0.776 , 'y' : - 0.729 } { 'x' : - 1.274 , 'y' : 0.992 } This transformer also supports mini-batch updates. You can call learn_many and provide a pandas.DataFrame : >>> import pandas as pd >>> X = pd . DataFrame . from_dict ( X ) >>> scaler = preprocessing . StandardScaler () >>> scaler = scaler . learn_many ( X [: 3 ]) >>> scaler = scaler . learn_many ( X [ 3 :]) You can then call transform_many to scale a mini-batch of features: >>> scaler . transform_many ( X ) x y 0 0.444600 - 0.933384 1 - 1.044259 - 0.138809 2 0.841106 1.679208 3 1.477301 - 0.685117 4 - 0.444084 - 0.914195 5 - 1.274664 0.992296","title":"Examples"},{"location":"api/preprocessing/StandardScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. Note that the update formulas for mean and variance are slightly different than in the single instance case, but they produce exactly the same result. Parameters X ( pandas.core.frame.DataFrame ) learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_many Scale a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/StandardScaler/#references","text":"Welford's Method (and Friends) \u21a9 Batch updates for simple statistics \u21a9","title":"References"},{"location":"api/preprocessing/StatImputer/","text":"StatImputer \u00b6 Replaces missing values with a statistic. This transformer allows you to replace missing values with the value of a running statistic. During a call to learn_one , for each feature, a statistic is updated whenever a numeric feature is observed. When transform_one is called, each feature with a None value is replaced with the current value of the corresponding statistic. Parameters \u00b6 imputers A list of tuples where each tuple has two elements. The first elements is a feature name and the second value is an instance of stats.Univariate . The second value can also be an arbitrary value, such as -1, in which case the missing values will be replaced with it. Examples \u00b6 >>> from river import preprocessing >>> from river import stats For numeric data, we can use a stats.Mean() to replace missing values by the running average of the previously seen values: >>> X = [ ... { 'temperature' : 1 }, ... { 'temperature' : 8 }, ... { 'temperature' : 3 }, ... { 'temperature' : None }, ... { 'temperature' : 4 } ... ] >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'temperature' : 1 } { 'temperature' : 8 } { 'temperature' : 3 } { 'temperature' : 4.0 } { 'temperature' : 4 } For discrete/categorical data, a common practice is to stats.Mode to replace missing values by the most commonly seen value: >>> X = [ ... { 'weather' : 'sunny' }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'sunny' }, ... { 'weather' : None }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'rainy' }, ... { 'weather' : None } ... ] >>> imp = preprocessing . StatImputer (( 'weather' , stats . Mode ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } You can also choose to replace missing values with a constant value, as so: >>> imp = preprocessing . StatImputer (( 'weather' , 'missing' )) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'missing' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'missing' } Multiple imputers can be defined by providing a tuple for each feature which you want to impute: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : None , 'temperature' : 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : None , 'temperature' : None } ... ] >>> imp = preprocessing . StatImputer ( ... ( 'temperature' , stats . Mean ()), ... ( 'weather' , stats . Mode ()) ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 5.5 } { 'weather' : 'sunny' , 'temperature' : 4 } { 'weather' : 'snowy' , 'temperature' : - 4 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : 0.8333 } A sophisticated way to go about imputation is condition the statistics on a given feature. For instance, we might want to replace a missing temperature with the average temperature of a particular weather condition. As an example, consider the following dataset where the temperature is missing, but not the weather condition: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'rainy' , 'temperature' : 4 }, ... { 'weather' : 'sunny' , 'temperature' : 10 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'sunny' , 'temperature' : 12 }, ... { 'weather' : 'rainy' , 'temperature' : None } ... ] Each missing temperature can be replaced with the average temperature of the corresponding weather condition as so: >>> from river import compose >>> imp = compose . Grouper ( ... preprocessing . StatImputer (( 'temperature' , stats . Mean ())), ... by = 'weather' ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 8.0 } { 'weather' : 'rainy' , 'temperature' : 4 } { 'weather' : 'sunny' , 'temperature' : 10 } { 'weather' : 'sunny' , 'temperature' : 9.0 } { 'weather' : 'sunny' , 'temperature' : 12 } { 'weather' : 'rainy' , 'temperature' : 3.5 } Note that you can also create a Grouper with the * operator: >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) * 'weather' Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"StatImputer"},{"location":"api/preprocessing/StatImputer/#statimputer","text":"Replaces missing values with a statistic. This transformer allows you to replace missing values with the value of a running statistic. During a call to learn_one , for each feature, a statistic is updated whenever a numeric feature is observed. When transform_one is called, each feature with a None value is replaced with the current value of the corresponding statistic.","title":"StatImputer"},{"location":"api/preprocessing/StatImputer/#parameters","text":"imputers A list of tuples where each tuple has two elements. The first elements is a feature name and the second value is an instance of stats.Univariate . The second value can also be an arbitrary value, such as -1, in which case the missing values will be replaced with it.","title":"Parameters"},{"location":"api/preprocessing/StatImputer/#examples","text":">>> from river import preprocessing >>> from river import stats For numeric data, we can use a stats.Mean() to replace missing values by the running average of the previously seen values: >>> X = [ ... { 'temperature' : 1 }, ... { 'temperature' : 8 }, ... { 'temperature' : 3 }, ... { 'temperature' : None }, ... { 'temperature' : 4 } ... ] >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'temperature' : 1 } { 'temperature' : 8 } { 'temperature' : 3 } { 'temperature' : 4.0 } { 'temperature' : 4 } For discrete/categorical data, a common practice is to stats.Mode to replace missing values by the most commonly seen value: >>> X = [ ... { 'weather' : 'sunny' }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'sunny' }, ... { 'weather' : None }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'rainy' }, ... { 'weather' : None } ... ] >>> imp = preprocessing . StatImputer (( 'weather' , stats . Mode ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } You can also choose to replace missing values with a constant value, as so: >>> imp = preprocessing . StatImputer (( 'weather' , 'missing' )) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'missing' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'missing' } Multiple imputers can be defined by providing a tuple for each feature which you want to impute: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : None , 'temperature' : 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : None , 'temperature' : None } ... ] >>> imp = preprocessing . StatImputer ( ... ( 'temperature' , stats . Mean ()), ... ( 'weather' , stats . Mode ()) ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 5.5 } { 'weather' : 'sunny' , 'temperature' : 4 } { 'weather' : 'snowy' , 'temperature' : - 4 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : 0.8333 } A sophisticated way to go about imputation is condition the statistics on a given feature. For instance, we might want to replace a missing temperature with the average temperature of a particular weather condition. As an example, consider the following dataset where the temperature is missing, but not the weather condition: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'rainy' , 'temperature' : 4 }, ... { 'weather' : 'sunny' , 'temperature' : 10 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'sunny' , 'temperature' : 12 }, ... { 'weather' : 'rainy' , 'temperature' : None } ... ] Each missing temperature can be replaced with the average temperature of the corresponding weather condition as so: >>> from river import compose >>> imp = compose . Grouper ( ... preprocessing . StatImputer (( 'temperature' , stats . Mean ())), ... by = 'weather' ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 8.0 } { 'weather' : 'rainy' , 'temperature' : 4 } { 'weather' : 'sunny' , 'temperature' : 10 } { 'weather' : 'sunny' , 'temperature' : 9.0 } { 'weather' : 'sunny' , 'temperature' : 12 } { 'weather' : 'rainy' , 'temperature' : 3.5 } Note that you can also create a Grouper with the * operator: >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) * 'weather'","title":"Examples"},{"location":"api/preprocessing/StatImputer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/proba/Gaussian/","text":"Gaussian \u00b6 Normal distribution with parameters mu and sigma. Attributes \u00b6 mode Most likely value. mu n_samples The number of observed samples. sigma Examples \u00b6 >>> from river import proba >>> p = proba . Gaussian () . update ( 6 ) . update ( 7 ) >>> p \ud835\udca9 ( \u03bc = 6.500 , \u03c3 = 0.707 ) >>> p . pdf ( 6.5 ) 0.564189 Methods \u00b6 cdf Cumulative density function, i.e. P(X <= x). Parameters x pdf Probability density function, i.e. P(x <= X < x+dx) / dx. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x w \u2013 defaults to 1.0","title":"Gaussian"},{"location":"api/proba/Gaussian/#gaussian","text":"Normal distribution with parameters mu and sigma.","title":"Gaussian"},{"location":"api/proba/Gaussian/#attributes","text":"mode Most likely value. mu n_samples The number of observed samples. sigma","title":"Attributes"},{"location":"api/proba/Gaussian/#examples","text":">>> from river import proba >>> p = proba . Gaussian () . update ( 6 ) . update ( 7 ) >>> p \ud835\udca9 ( \u03bc = 6.500 , \u03c3 = 0.707 ) >>> p . pdf ( 6.5 ) 0.564189","title":"Examples"},{"location":"api/proba/Gaussian/#methods","text":"cdf Cumulative density function, i.e. P(X <= x). Parameters x pdf Probability density function, i.e. P(x <= X < x+dx) / dx. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x w \u2013 defaults to 1.0","title":"Methods"},{"location":"api/proba/Multinomial/","text":"Multinomial \u00b6 Multinomial distribution for categorical data. Parameters \u00b6 events ( Union[dict, list] ) \u2013 defaults to None An optional list of events that already occurred. Attributes \u00b6 mode n_samples The number of observed samples. Examples \u00b6 >>> from river import proba >>> p = proba . Multinomial ([ 'green' ] * 3 ) >>> p = p . update ( 'red' ) >>> p . pmf ( 'red' ) 0.25 >>> p . update ( 'red' ) . update ( 'red' ) . pmf ( 'green' ) 0.5 Methods \u00b6 pmf Probability mass function. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"Multinomial"},{"location":"api/proba/Multinomial/#multinomial","text":"Multinomial distribution for categorical data.","title":"Multinomial"},{"location":"api/proba/Multinomial/#parameters","text":"events ( Union[dict, list] ) \u2013 defaults to None An optional list of events that already occurred.","title":"Parameters"},{"location":"api/proba/Multinomial/#attributes","text":"mode n_samples The number of observed samples.","title":"Attributes"},{"location":"api/proba/Multinomial/#examples","text":">>> from river import proba >>> p = proba . Multinomial ([ 'green' ] * 3 ) >>> p = p . update ( 'red' ) >>> p . pmf ( 'red' ) 0.25 >>> p . update ( 'red' ) . update ( 'red' ) . pmf ( 'green' ) 0.5","title":"Examples"},{"location":"api/proba/Multinomial/#methods","text":"pmf Probability mass function. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"Methods"},{"location":"api/reco/Baseline/","text":"Baseline \u00b6 Baseline for recommender systems. A first-order approximation of the bias involved in target. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i}\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored. Parameters \u00b6 optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. loss ( optim.losses.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 regularization amount used to push weights towards 0. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. Attributes \u00b6 global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user bias weights. i_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item bias weights. Examples \u00b6 >>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . Baseline ( optimizer = optim . SGD ( 0.005 )) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 6.538120 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. References \u00b6 Matrix factorization techniques for recommender systems \u21a9","title":"Baseline"},{"location":"api/reco/Baseline/#baseline","text":"Baseline for recommender systems. A first-order approximation of the bias involved in target. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i}\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.","title":"Baseline"},{"location":"api/reco/Baseline/#parameters","text":"optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. loss ( optim.losses.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 regularization amount used to push weights towards 0. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value.","title":"Parameters"},{"location":"api/reco/Baseline/#attributes","text":"global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user bias weights. i_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item bias weights.","title":"Attributes"},{"location":"api/reco/Baseline/#examples","text":">>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . Baseline ( optimizer = optim . SGD ( 0.005 )) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 6.538120","title":"Examples"},{"location":"api/reco/Baseline/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/reco/Baseline/#references","text":"Matrix factorization techniques for recommender systems \u21a9","title":"References"},{"location":"api/reco/BiasedMF/","text":"BiasedMF \u00b6 Biased Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. The last term being simply the dot product between the latent vectors of the given user-item pair: \\[\\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. bias_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the bias weights. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent weights. loss ( optim.losses.Loss ) \u2013 defaults to None The loss function to optimize for. l2_bias \u2013 defaults to 0.0 Amount of L2 regularization used to push bias weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_bias_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user bias weights. i_bias_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item bias weights. u_latent_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user latent weights. i_latent_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item latent weights. Examples \u00b6 >>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . BiasedMF ( ... n_factors = 10 , ... bias_optimizer = optim . SGD ( 0.025 ), ... latent_optimizer = optim . SGD ( 0.025 ), ... latent_initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 71 ) ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 6.489025 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. References \u00b6 Paterek, A., 2007, August. Improving regularized singular value decomposition for collaborative filtering. In Proceedings of KDD cup and workshop (Vol. 2007, pp. 5-8) \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"BiasedMF"},{"location":"api/reco/BiasedMF/#biasedmf","text":"Biased Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. The last term being simply the dot product between the latent vectors of the given user-item pair: \\[\\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.","title":"BiasedMF"},{"location":"api/reco/BiasedMF/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. bias_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the bias weights. latent_optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent weights. loss ( optim.losses.Loss ) \u2013 defaults to None The loss function to optimize for. l2_bias \u2013 defaults to 0.0 Amount of L2 regularization used to push bias weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. weight_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Weights initialization scheme. latent_initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/reco/BiasedMF/#attributes","text":"global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_bias_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user bias weights. i_bias_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item bias weights. u_latent_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user latent weights. i_latent_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item latent weights.","title":"Attributes"},{"location":"api/reco/BiasedMF/#examples","text":">>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . BiasedMF ( ... n_factors = 10 , ... bias_optimizer = optim . SGD ( 0.025 ), ... latent_optimizer = optim . SGD ( 0.025 ), ... latent_initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 71 ) ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 6.489025","title":"Examples"},{"location":"api/reco/BiasedMF/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/reco/BiasedMF/#references","text":"Paterek, A., 2007, August. Improving regularized singular value decomposition for collaborative filtering. In Proceedings of KDD cup and workshop (Vol. 2007, pp. 5-8) \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"References"},{"location":"api/reco/FunkMF/","text":"FunkMF \u00b6 Funk Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user latent weights. i_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item latent weights. Examples \u00b6 >>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . FunkMF ( ... n_factors = 10 , ... optimizer = optim . SGD ( 0.1 ), ... initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 11 ), ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 1.866272 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. References \u00b6 Netflix update: Try this at home \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"FunkMF"},{"location":"api/reco/FunkMF/#funkmf","text":"Funk Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.","title":"FunkMF"},{"location":"api/reco/FunkMF/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. optimizer ( optim.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. initializer ( optim.initializers.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/reco/FunkMF/#attributes","text":"u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the user latent weights. i_optimizer ( optim.Optimizer ) The sequential optimizer used for updating the item latent weights.","title":"Attributes"},{"location":"api/reco/FunkMF/#examples","text":">>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . FunkMF ( ... n_factors = 10 , ... optimizer = optim . SGD ( 0.1 ), ... initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 11 ), ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 1.866272","title":"Examples"},{"location":"api/reco/FunkMF/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/reco/FunkMF/#references","text":"Netflix update: Try this at home \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"References"},{"location":"api/reco/RandomNormal/","text":"RandomNormal \u00b6 Predicts random values sampled from a normal distribution. The parameters of the normal distribution are fitted with running statistics. This is equivalent to using surprise.prediction_algorithms.random_pred.NormalPredictor . This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored. Parameters \u00b6 seed \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 mean stats.Mean variance stats.Var Examples \u00b6 >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . RandomNormal ( seed = 42 ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 6.883895 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"RandomNormal"},{"location":"api/reco/RandomNormal/#randomnormal","text":"Predicts random values sampled from a normal distribution. The parameters of the normal distribution are fitted with running statistics. This is equivalent to using surprise.prediction_algorithms.random_pred.NormalPredictor . This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.","title":"RandomNormal"},{"location":"api/reco/RandomNormal/#parameters","text":"seed \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/reco/RandomNormal/#attributes","text":"mean stats.Mean variance stats.Var","title":"Attributes"},{"location":"api/reco/RandomNormal/#examples","text":">>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . RandomNormal ( seed = 42 ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' }) 6.883895","title":"Examples"},{"location":"api/reco/RandomNormal/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/stats/AbsMax/","text":"AbsMax \u00b6 Running absolute max. Attributes \u00b6 abs_max ( float ) The current absolute max. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> abs_max = stats . AbsMax () >>> for x in X : ... print ( abs_max . update ( x ) . get ()) 1 4 4 4 5 6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"AbsMax"},{"location":"api/stats/AbsMax/#absmax","text":"Running absolute max.","title":"AbsMax"},{"location":"api/stats/AbsMax/#attributes","text":"abs_max ( float ) The current absolute max.","title":"Attributes"},{"location":"api/stats/AbsMax/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> abs_max = stats . AbsMax () >>> for x in X : ... print ( abs_max . update ( x ) . get ()) 1 4 4 4 5 6","title":"Examples"},{"location":"api/stats/AbsMax/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/AutoCorr/","text":"AutoCorr \u00b6 Measures the serial correlation. This method computes the Pearson correlation between the current value and the value seen n steps before. Parameters \u00b6 lag ( int ) Attributes \u00b6 name Examples \u00b6 The following examples are taken from the pandas documentation . >>> from river import stats >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 - 1.0 0.103552 >>> auto_corr = stats . AutoCorr ( lag = 2 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 - 1.0 >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 1 , 0 , 0 , 0 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"AutoCorr"},{"location":"api/stats/AutoCorr/#autocorr","text":"Measures the serial correlation. This method computes the Pearson correlation between the current value and the value seen n steps before.","title":"AutoCorr"},{"location":"api/stats/AutoCorr/#parameters","text":"lag ( int )","title":"Parameters"},{"location":"api/stats/AutoCorr/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/AutoCorr/#examples","text":"The following examples are taken from the pandas documentation . >>> from river import stats >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 - 1.0 0.103552 >>> auto_corr = stats . AutoCorr ( lag = 2 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 - 1.0 >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 1 , 0 , 0 , 0 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 0","title":"Examples"},{"location":"api/stats/AutoCorr/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/BayesianMean/","text":"BayesianMean \u00b6 Estimates a mean using outside information. Parameters \u00b6 prior ( float ) prior_weight ( float ) Attributes \u00b6 name Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Additive smoothing \u21a9 Bayesian average \u21a9 Practical example of Bayes estimators \u21a9","title":"BayesianMean"},{"location":"api/stats/BayesianMean/#bayesianmean","text":"Estimates a mean using outside information.","title":"BayesianMean"},{"location":"api/stats/BayesianMean/#parameters","text":"prior ( float ) prior_weight ( float )","title":"Parameters"},{"location":"api/stats/BayesianMean/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/BayesianMean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/BayesianMean/#references","text":"Additive smoothing \u21a9 Bayesian average \u21a9 Practical example of Bayes estimators \u21a9","title":"References"},{"location":"api/stats/Bivariate/","text":"Bivariate \u00b6 A bivariate statistic measures a relationship between two variables. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Bivariate"},{"location":"api/stats/Bivariate/#bivariate","text":"A bivariate statistic measures a relationship between two variables.","title":"Bivariate"},{"location":"api/stats/Bivariate/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/Count/","text":"Count \u00b6 A simple counter. Attributes \u00b6 n ( int ) The current number of observations. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x \u2013 defaults to None","title":"Count"},{"location":"api/stats/Count/#count","text":"A simple counter.","title":"Count"},{"location":"api/stats/Count/#attributes","text":"n ( int ) The current number of observations.","title":"Attributes"},{"location":"api/stats/Count/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x \u2013 defaults to None","title":"Methods"},{"location":"api/stats/Cov/","text":"Cov \u00b6 Covariance. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. Examples \u00b6 >>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , 0.12 ] >>> cov = stats . Cov () >>> for xi , yi in zip ( x , y ): ... print ( cov . update ( xi , yi ) . get ()) 0.0 - 1.044999 - 4.286 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y w \u2013 defaults to 1.0 Notes \u00b6 The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\) . References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9 Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-) variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12). \u21a9","title":"Cov"},{"location":"api/stats/Cov/#cov","text":"Covariance.","title":"Cov"},{"location":"api/stats/Cov/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/Cov/#examples","text":">>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , 0.12 ] >>> cov = stats . Cov () >>> for xi , yi in zip ( x , y ): ... print ( cov . update ( xi , yi ) . get ()) 0.0 - 1.044999 - 4.286","title":"Examples"},{"location":"api/stats/Cov/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y w \u2013 defaults to 1.0","title":"Methods"},{"location":"api/stats/Cov/#notes","text":"The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\) .","title":"Notes"},{"location":"api/stats/Cov/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9 Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-) variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12). \u21a9","title":"References"},{"location":"api/stats/EWMean/","text":"EWMean \u00b6 Exponentially weighted mean. Parameters \u00b6 alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values. Attributes \u00b6 mean ( float ) The running exponentially weighted mean. Examples \u00b6 >>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewm = stats . EWMean ( alpha = 0.5 ) >>> for x in X : ... print ( ewm . update ( x ) . get ()) 1 2.0 3.5 3.75 4.875 6.4375 6.71875 7.859375 9.4296875 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"EWMean"},{"location":"api/stats/EWMean/#ewmean","text":"Exponentially weighted mean.","title":"EWMean"},{"location":"api/stats/EWMean/#parameters","text":"alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values.","title":"Parameters"},{"location":"api/stats/EWMean/#attributes","text":"mean ( float ) The running exponentially weighted mean.","title":"Attributes"},{"location":"api/stats/EWMean/#examples","text":">>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewm = stats . EWMean ( alpha = 0.5 ) >>> for x in X : ... print ( ewm . update ( x ) . get ()) 1 2.0 3.5 3.75 4.875 6.4375 6.71875 7.859375 9.4296875","title":"Examples"},{"location":"api/stats/EWMean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/EWMean/#references","text":"Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"References"},{"location":"api/stats/EWVar/","text":"EWVar \u00b6 Exponentially weighted variance. To calculate the variance we use the fact that Var(X) = Mean(x^2) - Mean(x)^2 and internally we use the exponentially weighted mean of x/x^2 to calculate this. Parameters \u00b6 alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values. Attributes \u00b6 variance ( float ) The running exponentially weighted variance. Examples \u00b6 >>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewv = stats . EWVar ( alpha = 0.5 ) >>> for x in X : ... print ( ewv . update ( x ) . get ()) 0 1.0 2.75 1.4375 1.984375 3.43359375 1.7958984375 2.198974609375 3.56536865234375 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"EWVar"},{"location":"api/stats/EWVar/#ewvar","text":"Exponentially weighted variance. To calculate the variance we use the fact that Var(X) = Mean(x^2) - Mean(x)^2 and internally we use the exponentially weighted mean of x/x^2 to calculate this.","title":"EWVar"},{"location":"api/stats/EWVar/#parameters","text":"alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values.","title":"Parameters"},{"location":"api/stats/EWVar/#attributes","text":"variance ( float ) The running exponentially weighted variance.","title":"Attributes"},{"location":"api/stats/EWVar/#examples","text":">>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewv = stats . EWVar ( alpha = 0.5 ) >>> for x in X : ... print ( ewv . update ( x ) . get ()) 0 1.0 2.75 1.4375 1.984375 3.43359375 1.7958984375 2.198974609375 3.56536865234375","title":"Examples"},{"location":"api/stats/EWVar/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/EWVar/#references","text":"Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"References"},{"location":"api/stats/Entropy/","text":"Entropy \u00b6 Running entropy. Parameters \u00b6 alpha \u2013 defaults to 1 Fading factor. eps \u2013 defaults to 1e-08 Small value that will be added to the denominator to avoid division by zero. Attributes \u00b6 entropy ( float ) The running entropy. n ( int ) The current number of observations. counter ( collections.Counter ) Count the number of times the values have occurred Examples \u00b6 >>> import math >>> import random >>> import numpy as np >>> from scipy.stats import entropy >>> from river import stats >>> def entropy_list ( labels , base = None ): ... value , counts = np . unique ( labels , return_counts = True ) ... return entropy ( counts , base = base ) >>> SEED = 42 * 1337 >>> random . seed ( SEED ) >>> entro = stats . Entropy ( alpha = 1 ) >>> list_animal = [] >>> for animal , num_val in zip ([ 'cat' , 'dog' , 'bird' ],[ 301 , 401 , 601 ]): ... list_animal += [ animal for i in range ( num_val )] >>> random . shuffle ( list_animal ) >>> for animal in list_animal : ... _ = entro . update ( animal ) >>> print ( f ' { entro . get () : .6f } ' ) 1.058093 >>> print ( f ' { entropy_list ( list_animal ) : .6f } ' ) 1.058093 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Sovdat, B., 2014. Updating Formulas and Algorithms for Computing Entropy and Gini Index from Time-Changing Data Streams. arXiv preprint arXiv:1403.6348. \u21a9","title":"Entropy"},{"location":"api/stats/Entropy/#entropy","text":"Running entropy.","title":"Entropy"},{"location":"api/stats/Entropy/#parameters","text":"alpha \u2013 defaults to 1 Fading factor. eps \u2013 defaults to 1e-08 Small value that will be added to the denominator to avoid division by zero.","title":"Parameters"},{"location":"api/stats/Entropy/#attributes","text":"entropy ( float ) The running entropy. n ( int ) The current number of observations. counter ( collections.Counter ) Count the number of times the values have occurred","title":"Attributes"},{"location":"api/stats/Entropy/#examples","text":">>> import math >>> import random >>> import numpy as np >>> from scipy.stats import entropy >>> from river import stats >>> def entropy_list ( labels , base = None ): ... value , counts = np . unique ( labels , return_counts = True ) ... return entropy ( counts , base = base ) >>> SEED = 42 * 1337 >>> random . seed ( SEED ) >>> entro = stats . Entropy ( alpha = 1 ) >>> list_animal = [] >>> for animal , num_val in zip ([ 'cat' , 'dog' , 'bird' ],[ 301 , 401 , 601 ]): ... list_animal += [ animal for i in range ( num_val )] >>> random . shuffle ( list_animal ) >>> for animal in list_animal : ... _ = entro . update ( animal ) >>> print ( f ' { entro . get () : .6f } ' ) 1.058093 >>> print ( f ' { entropy_list ( list_animal ) : .6f } ' ) 1.058093","title":"Examples"},{"location":"api/stats/Entropy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Entropy/#references","text":"Sovdat, B., 2014. Updating Formulas and Algorithms for Computing Entropy and Gini Index from Time-Changing Data Streams. arXiv preprint arXiv:1403.6348. \u21a9","title":"References"},{"location":"api/stats/IQR/","text":"IQR \u00b6 Computes the interquartile range. Parameters \u00b6 q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 . Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> iqr = stats . IQR ( q_inf = 0.25 , q_sup = 0.75 ) >>> for i in range ( 0 , 1001 ): ... iqr = iqr . update ( i ) ... if i % 100 == 0 : ... print ( iqr . get ()) 0 50.0 100.0 150.0 200.0 250.0 300.0 350.0 400.0 450.0 500.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"IQR"},{"location":"api/stats/IQR/#iqr","text":"Computes the interquartile range.","title":"IQR"},{"location":"api/stats/IQR/#parameters","text":"q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 .","title":"Parameters"},{"location":"api/stats/IQR/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/IQR/#examples","text":">>> from river import stats >>> iqr = stats . IQR ( q_inf = 0.25 , q_sup = 0.75 ) >>> for i in range ( 0 , 1001 ): ... iqr = iqr . update ( i ) ... if i % 100 == 0 : ... print ( iqr . get ()) 0 50.0 100.0 150.0 200.0 250.0 300.0 350.0 400.0 450.0 500.0","title":"Examples"},{"location":"api/stats/IQR/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Kurtosis/","text":"Kurtosis \u00b6 Running kurtosis using Welford's algorithm. Parameters \u00b6 bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias. Attributes \u00b6 name Examples \u00b6 >>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> kurtosis = river . stats . Kurtosis ( bias = False ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 1.4130027920707047 0.15367976585756438 0.46142633246812653 - 1.620647789230658 - 1.3540178492487054 - 1.2310268787102745 - 0.9490372374384453 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = False )) - 3.0 - 2.0 - 1.4999999999999998 1.4130027920707082 0.15367976585756082 0.46142633246812403 - 1.620647789230658 - 1.3540178492487063 - 1.2310268787102738 - 0.9490372374384459 >>> kurtosis = river . stats . Kurtosis ( bias = True ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 - 1.011599627723906 - 0.9615800585356089 - 0.6989395431537853 - 1.4252699121794408 - 1.311437071070812 - 1.246289111322894 - 1.082283689864171 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = True )) - 3.0 - 2.0 - 1.4999999999999998 - 1.0115996277239057 - 0.9615800585356098 - 0.6989395431537861 - 1.425269912179441 - 1.3114370710708125 - 1.2462891113228936 - 1.0822836898641714 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9","title":"Kurtosis"},{"location":"api/stats/Kurtosis/#kurtosis","text":"Running kurtosis using Welford's algorithm.","title":"Kurtosis"},{"location":"api/stats/Kurtosis/#parameters","text":"bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias.","title":"Parameters"},{"location":"api/stats/Kurtosis/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Kurtosis/#examples","text":">>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> kurtosis = river . stats . Kurtosis ( bias = False ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 1.4130027920707047 0.15367976585756438 0.46142633246812653 - 1.620647789230658 - 1.3540178492487054 - 1.2310268787102745 - 0.9490372374384453 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = False )) - 3.0 - 2.0 - 1.4999999999999998 1.4130027920707082 0.15367976585756082 0.46142633246812403 - 1.620647789230658 - 1.3540178492487063 - 1.2310268787102738 - 0.9490372374384459 >>> kurtosis = river . stats . Kurtosis ( bias = True ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 - 1.011599627723906 - 0.9615800585356089 - 0.6989395431537853 - 1.4252699121794408 - 1.311437071070812 - 1.246289111322894 - 1.082283689864171 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = True )) - 3.0 - 2.0 - 1.4999999999999998 - 1.0115996277239057 - 0.9615800585356098 - 0.6989395431537861 - 1.425269912179441 - 1.3114370710708125 - 1.2462891113228936 - 1.0822836898641714","title":"Examples"},{"location":"api/stats/Kurtosis/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Kurtosis/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9","title":"References"},{"location":"api/stats/Link/","text":"Link \u00b6 A link joins two univariate statistics as a sequence. This can be used to pipe the output of one statistic to the input of another. This can be used, for instance, to calculate the mean of the variance of a variable. It can also be used to compute shifted statistics by piping statistics with an instance of stats.Shift . Note that a link is not meant to be instantiated via this class definition. Instead, users can link statistics together via the | operator. Parameters \u00b6 left ( river.stats.base.Univariate ) right ( river.stats.base.Univariate ) The output from left 's get method is passed to right 's update method if left 's get method doesn't produce None. Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () No values have been seen, therefore get defaults to the initial value of stats.Mean , which is 0. >>> stat . get () 0. Let us now call update . >>> stat = stat . update ( 1 ) The output from get will still be 0. The reason is that stats.Shift has not enough values, and therefore outputs it's default value, which is None . The stats.Mean instance is therefore not updated. >>> stat . get () 0.0 On the next call to update , the stats.Shift instance has seen enough values, and therefore the mean can be updated. The mean is therefore equal to 1, because that's the only value from the past. >>> stat = stat . update ( 3 ) >>> stat . get () 1.0 On the subsequent call to update, the mean will be updated with the value 3. >>> stat = stat . update ( 4 ) >>> stat . get () 2.0 Note that composing statistics returns a new statistic with it's own name. >>> stat . name 'mean_of_shift_1' Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Link"},{"location":"api/stats/Link/#link","text":"A link joins two univariate statistics as a sequence. This can be used to pipe the output of one statistic to the input of another. This can be used, for instance, to calculate the mean of the variance of a variable. It can also be used to compute shifted statistics by piping statistics with an instance of stats.Shift . Note that a link is not meant to be instantiated via this class definition. Instead, users can link statistics together via the | operator.","title":"Link"},{"location":"api/stats/Link/#parameters","text":"left ( river.stats.base.Univariate ) right ( river.stats.base.Univariate ) The output from left 's get method is passed to right 's update method if left 's get method doesn't produce None.","title":"Parameters"},{"location":"api/stats/Link/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Link/#examples","text":">>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () No values have been seen, therefore get defaults to the initial value of stats.Mean , which is 0. >>> stat . get () 0. Let us now call update . >>> stat = stat . update ( 1 ) The output from get will still be 0. The reason is that stats.Shift has not enough values, and therefore outputs it's default value, which is None . The stats.Mean instance is therefore not updated. >>> stat . get () 0.0 On the next call to update , the stats.Shift instance has seen enough values, and therefore the mean can be updated. The mean is therefore equal to 1, because that's the only value from the past. >>> stat = stat . update ( 3 ) >>> stat . get () 1.0 On the subsequent call to update, the mean will be updated with the value 3. >>> stat = stat . update ( 4 ) >>> stat . get () 2.0 Note that composing statistics returns a new statistic with it's own name. >>> stat . name 'mean_of_shift_1'","title":"Examples"},{"location":"api/stats/Link/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Max/","text":"Max \u00b6 Running max. Attributes \u00b6 max ( float ) The current max. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> _max = stats . Max () >>> for x in X : ... print ( _max . update ( x ) . get ()) 1 1 3 3 5 5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Max"},{"location":"api/stats/Max/#max","text":"Running max.","title":"Max"},{"location":"api/stats/Max/#attributes","text":"max ( float ) The current max.","title":"Attributes"},{"location":"api/stats/Max/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> _max = stats . Max () >>> for x in X : ... print ( _max . update ( x ) . get ()) 1 1 3 3 5 5","title":"Examples"},{"location":"api/stats/Max/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Mean/","text":"Mean \u00b6 Running mean. Attributes \u00b6 mean ( float ) The current value of the mean. n ( float ) The current sum of weights. If each passed weight was 1, then this is equal to the number of seen observations. Examples \u00b6 >>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Mean () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 4.0 - 3.0 - 2.0 - 1.0 0.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 References \u00b6 West, D. H. D. (1979). Updating mean and variance estimates: An improved method. Communications of the ACM, 22(9), 532-535. \u21a9 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"Mean"},{"location":"api/stats/Mean/#mean","text":"Running mean.","title":"Mean"},{"location":"api/stats/Mean/#attributes","text":"mean ( float ) The current value of the mean. n ( float ) The current sum of weights. If each passed weight was 1, then this is equal to the number of seen observations.","title":"Attributes"},{"location":"api/stats/Mean/#examples","text":">>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Mean () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 4.0 - 3.0 - 2.0 - 1.0 0.0","title":"Examples"},{"location":"api/stats/Mean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0","title":"Methods"},{"location":"api/stats/Mean/#references","text":"West, D. H. D. (1979). Updating mean and variance estimates: An improved method. Communications of the ACM, 22(9), 532-535. \u21a9 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"References"},{"location":"api/stats/Min/","text":"Min \u00b6 Running min. Attributes \u00b6 min ( float ) The current min. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Min"},{"location":"api/stats/Min/#min","text":"Running min.","title":"Min"},{"location":"api/stats/Min/#attributes","text":"min ( float ) The current min.","title":"Attributes"},{"location":"api/stats/Min/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Mode/","text":"Mode \u00b6 Running mode. The mode is simply the most common value. An approximate mode can be computed by setting the number of first unique values to count. Parameters \u00b6 k \u2013 defaults to 25 Only the first k unique values will be included. If k equals -1, the exact mode is computed. Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> X = [ 'sunny' , 'cloudy' , 'cloudy' , 'rainy' , 'rainy' , 'rainy' ] >>> mode = stats . Mode ( k = 2 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy cloudy >>> mode = stats . Mode ( k =- 1 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy rainy Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Mode"},{"location":"api/stats/Mode/#mode","text":"Running mode. The mode is simply the most common value. An approximate mode can be computed by setting the number of first unique values to count.","title":"Mode"},{"location":"api/stats/Mode/#parameters","text":"k \u2013 defaults to 25 Only the first k unique values will be included. If k equals -1, the exact mode is computed.","title":"Parameters"},{"location":"api/stats/Mode/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Mode/#examples","text":">>> from river import stats >>> X = [ 'sunny' , 'cloudy' , 'cloudy' , 'rainy' , 'rainy' , 'rainy' ] >>> mode = stats . Mode ( k = 2 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy cloudy >>> mode = stats . Mode ( k =- 1 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy rainy","title":"Examples"},{"location":"api/stats/Mode/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/NUnique/","text":"NUnique \u00b6 Approximate number of unique values counter. This is basically an implementation of the HyperLogLog algorithm. Adapted from hypy . The code is a bit too terse but it will do for now. Parameters \u00b6 error_rate \u2013 defaults to 0.01 Desired error rate. Memory usage is inversely proportional to this value. seed ( int ) \u2013 defaults to None Set the seed to produce identical results. Attributes \u00b6 n_bits ( int ) n_buckets ( int ) buckets ( list ) Examples \u00b6 >>> import string >>> from river import stats >>> alphabet = string . ascii_lowercase >>> n_unique = stats . NUnique ( error_rate = 0.2 , seed = 42 ) >>> n_unique . update ( 'a' ) . get () 1 >>> n_unique . update ( 'b' ) . get () 2 >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 31 Lowering the error_rate parameter will increase the precision. >>> n_unique = stats . NUnique ( error_rate = 0.01 , seed = 42 ) >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 26 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 My favorite algorithm (and data structure): HyperLogLog \u21a9 Flajolet, P., Fusy, \u00c9., Gandouet, O. and Meunier, F., 2007, June. Hyperloglog: the analysis of a near-optimal cardinality estimation algorithm. \u21a9","title":"NUnique"},{"location":"api/stats/NUnique/#nunique","text":"Approximate number of unique values counter. This is basically an implementation of the HyperLogLog algorithm. Adapted from hypy . The code is a bit too terse but it will do for now.","title":"NUnique"},{"location":"api/stats/NUnique/#parameters","text":"error_rate \u2013 defaults to 0.01 Desired error rate. Memory usage is inversely proportional to this value. seed ( int ) \u2013 defaults to None Set the seed to produce identical results.","title":"Parameters"},{"location":"api/stats/NUnique/#attributes","text":"n_bits ( int ) n_buckets ( int ) buckets ( list )","title":"Attributes"},{"location":"api/stats/NUnique/#examples","text":">>> import string >>> from river import stats >>> alphabet = string . ascii_lowercase >>> n_unique = stats . NUnique ( error_rate = 0.2 , seed = 42 ) >>> n_unique . update ( 'a' ) . get () 1 >>> n_unique . update ( 'b' ) . get () 2 >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 31 Lowering the error_rate parameter will increase the precision. >>> n_unique = stats . NUnique ( error_rate = 0.01 , seed = 42 ) >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 26","title":"Examples"},{"location":"api/stats/NUnique/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/NUnique/#references","text":"My favorite algorithm (and data structure): HyperLogLog \u21a9 Flajolet, P., Fusy, \u00c9., Gandouet, O. and Meunier, F., 2007, June. Hyperloglog: the analysis of a near-optimal cardinality estimation algorithm. \u21a9","title":"References"},{"location":"api/stats/PeakToPeak/","text":"PeakToPeak \u00b6 Running peak to peak (max - min). Attributes \u00b6 max ( stats.Max ) The running max. min ( stats.Min ) The running min. p2p ( float ) The running peak to peak. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 4 ] >>> ptp = stats . PeakToPeak () >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 7 7 8 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"PeakToPeak"},{"location":"api/stats/PeakToPeak/#peaktopeak","text":"Running peak to peak (max - min).","title":"PeakToPeak"},{"location":"api/stats/PeakToPeak/#attributes","text":"max ( stats.Max ) The running max. min ( stats.Min ) The running min. p2p ( float ) The running peak to peak.","title":"Attributes"},{"location":"api/stats/PeakToPeak/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 4 ] >>> ptp = stats . PeakToPeak () >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 7 7 8","title":"Examples"},{"location":"api/stats/PeakToPeak/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/PearsonCorr/","text":"PearsonCorr \u00b6 Online Pearson correlation. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. Attributes \u00b6 var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y . Examples \u00b6 >>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . PearsonCorr () >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.774596 0.866025 0.878310 0.866025 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"PearsonCorr"},{"location":"api/stats/PearsonCorr/#pearsoncorr","text":"Online Pearson correlation.","title":"PearsonCorr"},{"location":"api/stats/PearsonCorr/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/PearsonCorr/#attributes","text":"var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y .","title":"Attributes"},{"location":"api/stats/PearsonCorr/#examples","text":">>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . PearsonCorr () >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.774596 0.866025 0.878310 0.866025","title":"Examples"},{"location":"api/stats/PearsonCorr/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/Quantile/","text":"Quantile \u00b6 Running quantile. Uses the P\u00b2 algorithm, which is also known as the \"Piecewise-Parabolic quantile estimator\". The code is inspired by LiveStat's implementation 2 . Parameters \u00b6 q \u2013 defaults to 0.5 Determines which quantile to compute, must be comprised between 0 and 1. Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> import numpy as np >>> np . random . seed ( 42 * 1337 ) >>> mu , sigma = 0 , 1 >>> s = np . random . normal ( mu , sigma , 500 ) >>> median = stats . Quantile ( 0.5 ) >>> for x in s : ... _ = median . update ( x ) >>> print ( f 'The estimated value of the 50th (median) quantile is { median . get () : .4f } ' ) The estimated value of the 50 th ( median ) quantile is - 0.0275 >>> print ( f 'The real value of the 50th (median) quantile is { np . median ( s ) : .4f } ' ) The real value of the 50 th ( median ) quantile is - 0.0135 >>> percentile_17 = stats . Quantile ( 0.17 ) >>> for x in s : ... _ = percentile_17 . update ( x ) >>> print ( f 'The estimated value of the 17th quantile is { percentile_17 . get () : .4f } ' ) The estimated value of the 17 th quantile is - 0.8652 >>> print ( f 'The real value of the 17th quantile is { np . percentile ( s , 17 ) : .4f } ' ) The real value of the 17 th quantile is - 0.9072 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 The P\u00b2 Algorithm for Dynamic Univariateal Computing Calculation of Quantiles and Editor Histograms Without Storing Observations \u21a9 LiveStats \u21a9 P\u00b2 quantile estimator: estimating the median without storing values \u21a9","title":"Quantile"},{"location":"api/stats/Quantile/#quantile","text":"Running quantile. Uses the P\u00b2 algorithm, which is also known as the \"Piecewise-Parabolic quantile estimator\". The code is inspired by LiveStat's implementation 2 .","title":"Quantile"},{"location":"api/stats/Quantile/#parameters","text":"q \u2013 defaults to 0.5 Determines which quantile to compute, must be comprised between 0 and 1.","title":"Parameters"},{"location":"api/stats/Quantile/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Quantile/#examples","text":">>> from river import stats >>> import numpy as np >>> np . random . seed ( 42 * 1337 ) >>> mu , sigma = 0 , 1 >>> s = np . random . normal ( mu , sigma , 500 ) >>> median = stats . Quantile ( 0.5 ) >>> for x in s : ... _ = median . update ( x ) >>> print ( f 'The estimated value of the 50th (median) quantile is { median . get () : .4f } ' ) The estimated value of the 50 th ( median ) quantile is - 0.0275 >>> print ( f 'The real value of the 50th (median) quantile is { np . median ( s ) : .4f } ' ) The real value of the 50 th ( median ) quantile is - 0.0135 >>> percentile_17 = stats . Quantile ( 0.17 ) >>> for x in s : ... _ = percentile_17 . update ( x ) >>> print ( f 'The estimated value of the 17th quantile is { percentile_17 . get () : .4f } ' ) The estimated value of the 17 th quantile is - 0.8652 >>> print ( f 'The real value of the 17th quantile is { np . percentile ( s , 17 ) : .4f } ' ) The real value of the 17 th quantile is - 0.9072","title":"Examples"},{"location":"api/stats/Quantile/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Quantile/#references","text":"The P\u00b2 Algorithm for Dynamic Univariateal Computing Calculation of Quantiles and Editor Histograms Without Storing Observations \u21a9 LiveStats \u21a9 P\u00b2 quantile estimator: estimating the median without storing values \u21a9","title":"References"},{"location":"api/stats/RollingAbsMax/","text":"RollingAbsMax \u00b6 Running absolute max over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name size window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_absmax = stats . RollingAbsMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_absmax . update ( x ) . get ()) 1 4 4 3 2 2 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"RollingAbsMax"},{"location":"api/stats/RollingAbsMax/#rollingabsmax","text":"Running absolute max over a window.","title":"RollingAbsMax"},{"location":"api/stats/RollingAbsMax/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingAbsMax/#attributes","text":"name size window_size","title":"Attributes"},{"location":"api/stats/RollingAbsMax/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_absmax = stats . RollingAbsMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_absmax . update ( x ) . get ()) 1 4 4 3 2 2","title":"Examples"},{"location":"api/stats/RollingAbsMax/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingCov/","text":"RollingCov \u00b6 Rolling covariance. Parameters \u00b6 window_size Size of the window over which to compute the covariance. ddof \u2013 defaults to 1 Delta Degrees of Freedom. Attributes \u00b6 window_size Examples \u00b6 >>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 , 1 , - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , . 12 , 1 , 3 , 1.1 , . 12 ] >>> rcov = stats . RollingCov ( 3 ) >>> for xi , yi in zip ( x , y ): ... print ( rcov . update ( xi , yi ) . get ()) 0.0 - 1.045 - 4.286 - 1.382 - 4.589 - 1.415 - 4.286 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"RollingCov"},{"location":"api/stats/RollingCov/#rollingcov","text":"Rolling covariance.","title":"RollingCov"},{"location":"api/stats/RollingCov/#parameters","text":"window_size Size of the window over which to compute the covariance. ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/RollingCov/#attributes","text":"window_size","title":"Attributes"},{"location":"api/stats/RollingCov/#examples","text":">>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 , 1 , - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , . 12 , 1 , 3 , 1.1 , . 12 ] >>> rcov = stats . RollingCov ( 3 ) >>> for xi , yi in zip ( x , y ): ... print ( rcov . update ( xi , yi ) . get ()) 0.0 - 1.045 - 4.286 - 1.382 - 4.589 - 1.415 - 4.286","title":"Examples"},{"location":"api/stats/RollingCov/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/RollingIQR/","text":"RollingIQR \u00b6 Computes the rolling interquartile range. Parameters \u00b6 window_size ( int ) Size of the window. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 . Attributes \u00b6 name size window_size Examples \u00b6 >>> from river import stats >>> rolling_iqr = stats . RollingIQR ( ... q_inf = 0.25 , ... q_sup = 0.75 , ... window_size = 100 ... ) >>> for i in range ( 0 , 1001 ): ... rolling_iqr = rolling_iqr . update ( i ) ... if i % 100 == 0 : ... print ( rolling_iqr . get ()) 0 50 50 50 50 50 50 50 50 50 50 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"RollingIQR"},{"location":"api/stats/RollingIQR/#rollingiqr","text":"Computes the rolling interquartile range.","title":"RollingIQR"},{"location":"api/stats/RollingIQR/#parameters","text":"window_size ( int ) Size of the window. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 .","title":"Parameters"},{"location":"api/stats/RollingIQR/#attributes","text":"name size window_size","title":"Attributes"},{"location":"api/stats/RollingIQR/#examples","text":">>> from river import stats >>> rolling_iqr = stats . RollingIQR ( ... q_inf = 0.25 , ... q_sup = 0.75 , ... window_size = 100 ... ) >>> for i in range ( 0 , 1001 ): ... rolling_iqr = rolling_iqr . update ( i ) ... if i % 100 == 0 : ... print ( rolling_iqr . get ()) 0 50 50 50 50 50 50 50 50 50 50","title":"Examples"},{"location":"api/stats/RollingIQR/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMax/","text":"RollingMax \u00b6 Running max over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name size window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_max = stats . RollingMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_max . update ( x ) . get ()) 1 1 3 3 2 2 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"RollingMax"},{"location":"api/stats/RollingMax/#rollingmax","text":"Running max over a window.","title":"RollingMax"},{"location":"api/stats/RollingMax/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMax/#attributes","text":"name size window_size","title":"Attributes"},{"location":"api/stats/RollingMax/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_max = stats . RollingMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_max . update ( x ) . get ()) 1 1 3 3 2 2","title":"Examples"},{"location":"api/stats/RollingMax/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMean/","text":"RollingMean \u00b6 Running average over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name size window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> rmean = stats . RollingMean ( window_size = 2 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.5 3.5 4.5 5.5 >>> rmean = stats . RollingMean ( window_size = 3 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.0 3.0 4.0 5.0 Methods \u00b6 append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get popleft revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingMean"},{"location":"api/stats/RollingMean/#rollingmean","text":"Running average over a window.","title":"RollingMean"},{"location":"api/stats/RollingMean/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMean/#attributes","text":"name size window_size","title":"Attributes"},{"location":"api/stats/RollingMean/#examples","text":">>> from river import stats >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> rmean = stats . RollingMean ( window_size = 2 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.5 3.5 4.5 5.5 >>> rmean = stats . RollingMean ( window_size = 3 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.0 3.0 4.0 5.0","title":"Examples"},{"location":"api/stats/RollingMean/#methods","text":"append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get popleft revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMin/","text":"RollingMin \u00b6 Running min over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name size window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_min = stats . RollingMin ( 2 ) >>> for x in X : ... print ( rolling_min . update ( x ) . get ()) 1 - 4 - 4 - 2 - 2 1 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"RollingMin"},{"location":"api/stats/RollingMin/#rollingmin","text":"Running min over a window.","title":"RollingMin"},{"location":"api/stats/RollingMin/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMin/#attributes","text":"name size window_size","title":"Attributes"},{"location":"api/stats/RollingMin/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_min = stats . RollingMin ( 2 ) >>> for x in X : ... print ( rolling_min . update ( x ) . get ()) 1 - 4 - 4 - 2 - 2 1","title":"Examples"},{"location":"api/stats/RollingMin/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMode/","text":"RollingMode \u00b6 Running mode over a window. The mode is the most common value. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 counts ( collections.defaultdict ) Value counts. Examples \u00b6 >>> from river import stats >>> X = [ 'sunny' , 'sunny' , 'sunny' , 'rainy' , 'rainy' , 'rainy' , 'rainy' ] >>> rolling_mode = stats . RollingMode ( window_size = 2 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny rainy rainy rainy >>> rolling_mode = stats . RollingMode ( window_size = 5 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny sunny rainy rainy Methods \u00b6 append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get popleft revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingMode"},{"location":"api/stats/RollingMode/#rollingmode","text":"Running mode over a window. The mode is the most common value.","title":"RollingMode"},{"location":"api/stats/RollingMode/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMode/#attributes","text":"counts ( collections.defaultdict ) Value counts.","title":"Attributes"},{"location":"api/stats/RollingMode/#examples","text":">>> from river import stats >>> X = [ 'sunny' , 'sunny' , 'sunny' , 'rainy' , 'rainy' , 'rainy' , 'rainy' ] >>> rolling_mode = stats . RollingMode ( window_size = 2 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny rainy rainy rainy >>> rolling_mode = stats . RollingMode ( window_size = 5 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny sunny rainy rainy","title":"Examples"},{"location":"api/stats/RollingMode/#methods","text":"append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get popleft revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingPeakToPeak/","text":"RollingPeakToPeak \u00b6 Running peak to peak (max - min) over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 max ( stats.RollingMax ) The running rolling max. min ( stats.RollingMin ) The running rolling min. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> ptp = stats . RollingPeakToPeak ( window_size = 2 ) >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 5 4 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingPeakToPeak"},{"location":"api/stats/RollingPeakToPeak/#rollingpeaktopeak","text":"Running peak to peak (max - min) over a window.","title":"RollingPeakToPeak"},{"location":"api/stats/RollingPeakToPeak/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingPeakToPeak/#attributes","text":"max ( stats.RollingMax ) The running rolling max. min ( stats.RollingMin ) The running rolling min.","title":"Attributes"},{"location":"api/stats/RollingPeakToPeak/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> ptp = stats . RollingPeakToPeak ( window_size = 2 ) >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 5 4 1","title":"Examples"},{"location":"api/stats/RollingPeakToPeak/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingPearsonCorr/","text":"RollingPearsonCorr \u00b6 Rolling Pearson correlation. Parameters \u00b6 window_size Amount of samples over which to compute the correlation. ddof \u2013 defaults to 1 Delta Degrees of Freedom. Attributes \u00b6 var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y . Examples \u00b6 >>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . RollingPearsonCorr ( window_size = 4 ) >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.7745966692414834 0.894427190999916 0.7745966692414834 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"RollingPearsonCorr"},{"location":"api/stats/RollingPearsonCorr/#rollingpearsoncorr","text":"Rolling Pearson correlation.","title":"RollingPearsonCorr"},{"location":"api/stats/RollingPearsonCorr/#parameters","text":"window_size Amount of samples over which to compute the correlation. ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/RollingPearsonCorr/#attributes","text":"var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y .","title":"Attributes"},{"location":"api/stats/RollingPearsonCorr/#examples","text":">>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . RollingPearsonCorr ( window_size = 4 ) >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.7745966692414834 0.894427190999916 0.7745966692414834 0","title":"Examples"},{"location":"api/stats/RollingPearsonCorr/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/RollingQuantile/","text":"RollingQuantile \u00b6 Running quantile over a window. Parameters \u00b6 q Determines which quantile to compute, must be comprised between 0 and 1. window_size Size of the window. Attributes \u00b6 name size window_size Examples \u00b6 >>> from river import stats >>> rolling_quantile = stats . RollingQuantile ( ... q =. 5 , ... window_size = 100 , ... ) >>> for i in range ( 0 , 1001 ): ... rolling_quantile = rolling_quantile . update ( i ) ... if i % 100 == 0 : ... print ( rolling_quantile . get ()) 0 50 150 250 350 450 550 650 750 850 950 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x References \u00b6 Left sorted \u21a9","title":"RollingQuantile"},{"location":"api/stats/RollingQuantile/#rollingquantile","text":"Running quantile over a window.","title":"RollingQuantile"},{"location":"api/stats/RollingQuantile/#parameters","text":"q Determines which quantile to compute, must be comprised between 0 and 1. window_size Size of the window.","title":"Parameters"},{"location":"api/stats/RollingQuantile/#attributes","text":"name size window_size","title":"Attributes"},{"location":"api/stats/RollingQuantile/#examples","text":">>> from river import stats >>> rolling_quantile = stats . RollingQuantile ( ... q =. 5 , ... window_size = 100 , ... ) >>> for i in range ( 0 , 1001 ): ... rolling_quantile = rolling_quantile . update ( i ) ... if i % 100 == 0 : ... print ( rolling_quantile . get ()) 0 50 150 250 350 450 550 650 750 850 950","title":"Examples"},{"location":"api/stats/RollingQuantile/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert and return the called instance. Parameters x sort update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingQuantile/#references","text":"Left sorted \u21a9","title":"References"},{"location":"api/stats/RollingSEM/","text":"RollingSEM \u00b6 Running standard error of the mean over a window. Parameters \u00b6 window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom for the variance. Attributes \u00b6 correction_factor name window_size Examples \u00b6 >>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 1.0 3.0 2.0 4.0 >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 0.881917 2.403700 2.905932 2.309401 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingSEM"},{"location":"api/stats/RollingSEM/#rollingsem","text":"Running standard error of the mean over a window.","title":"RollingSEM"},{"location":"api/stats/RollingSEM/#parameters","text":"window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom for the variance.","title":"Parameters"},{"location":"api/stats/RollingSEM/#attributes","text":"correction_factor name window_size","title":"Attributes"},{"location":"api/stats/RollingSEM/#examples","text":">>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 1.0 3.0 2.0 4.0 >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 0.881917 2.403700 2.905932 2.309401","title":"Examples"},{"location":"api/stats/RollingSEM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingSum/","text":"RollingSum \u00b6 Running sum over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 sum ( int ) The running rolling sum. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_sum = stats . RollingSum ( 2 ) >>> for x in X : ... print ( rolling_sum . update ( x ) . get ()) 1 - 3 - 1 1 0 3 Methods \u00b6 append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get popleft revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingSum"},{"location":"api/stats/RollingSum/#rollingsum","text":"Running sum over a window.","title":"RollingSum"},{"location":"api/stats/RollingSum/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingSum/#attributes","text":"sum ( int ) The running rolling sum.","title":"Attributes"},{"location":"api/stats/RollingSum/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_sum = stats . RollingSum ( 2 ) >>> for x in X : ... print ( rolling_sum . update ( x ) . get ()) 1 - 3 - 1 1 0 3","title":"Examples"},{"location":"api/stats/RollingSum/#methods","text":"append clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. extend get popleft revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingVar/","text":"RollingVar \u00b6 Running variance over a window. Parameters \u00b6 window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom for the variance. Attributes \u00b6 sos ( float ) Sum of squares over the current window. rmean ( stats.RollingMean ) Examples \u00b6 >>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.0 18.0 8.0 32.0 >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.333333 17.333333 25.333333 16.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingVar"},{"location":"api/stats/RollingVar/#rollingvar","text":"Running variance over a window.","title":"RollingVar"},{"location":"api/stats/RollingVar/#parameters","text":"window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom for the variance.","title":"Parameters"},{"location":"api/stats/RollingVar/#attributes","text":"sos ( float ) Sum of squares over the current window. rmean ( stats.RollingMean )","title":"Attributes"},{"location":"api/stats/RollingVar/#examples","text":">>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.0 18.0 8.0 32.0 >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.333333 17.333333 25.333333 16.0","title":"Examples"},{"location":"api/stats/RollingVar/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/SEM/","text":"SEM \u00b6 Running standard error of the mean using Welford's algorithm. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n is the number of seen elements. Attributes \u00b6 n ( int ) Number of observations. Examples \u00b6 >>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> sem = river . stats . SEM () >>> for x in X : ... print ( sem . update ( x ) . get ()) 0.0 1.0 0.577350 0.853912 1.240967 1.447219 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9","title":"SEM"},{"location":"api/stats/SEM/#sem","text":"Running standard error of the mean using Welford's algorithm.","title":"SEM"},{"location":"api/stats/SEM/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n is the number of seen elements.","title":"Parameters"},{"location":"api/stats/SEM/#attributes","text":"n ( int ) Number of observations.","title":"Attributes"},{"location":"api/stats/SEM/#examples","text":">>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> sem = river . stats . SEM () >>> for x in X : ... print ( sem . update ( x ) . get ()) 0.0 1.0 0.577350 0.853912 1.240967 1.447219","title":"Examples"},{"location":"api/stats/SEM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x w \u2013 defaults to 1.0","title":"Methods"},{"location":"api/stats/SEM/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9","title":"References"},{"location":"api/stats/Shift/","text":"Shift \u00b6 Shifts a data stream by returning past values. This can be used to compute statistics over past data. For instance, if you're computing daily averages, then shifting by 7 will be equivalent to computing averages from a week ago. Shifting values is useful when you're calculating an average over a target value. Indeed, in this case it's important to shift the values in order not to introduce leakage. The recommended way to do this is to feature_extraction.TargetAgg , which already takes care of shifting the target values once. Parameters \u00b6 amount \u2013 defaults to 1 Shift amount. The get method will return the t - amount value, where t is the current moment. fill_value \u2013 defaults to None This value will be returned by the get method if not enough values have been observed. Attributes \u00b6 name Examples \u00b6 It is rare to have to use Shift by itself. A more common usage is to compose it with other statistics. This can be done via the | operator. >>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () >>> for i in range ( 5 ): ... stat = stat . update ( i ) ... print ( stat . get ()) 0.0 0.0 0.5 1.0 1.5 A common usecase for using Shift is when computing statistics on shifted data. For instance, say you have a dataset which records the amount of sales for a set of shops. You might then have a shop field and a sales field. Let's say you want to look at the average amount of sales per shop. You can do this by using a feature_extraction.Agg . When you call transform_one , you're expecting it to return the average amount of sales, without including today's sales. You can do this by prepending an instance of stats.Mean with an instance of stats.Shift . >>> from river import feature_extraction >>> agg = feature_extraction . Agg ( ... on = 'sales' , ... how = stats . Shift ( 1 ) | stats . Mean (), ... by = 'shop' ... ) Let's define a little example dataset. >>> X = iter ([ ... { 'shop' : 'Ikea' , 'sales' : 10 }, ... { 'shop' : 'Ikea' , 'sales' : 15 }, ... { 'shop' : 'Ikea' , 'sales' : 20 } ... ]) Now let's call the learn_one method to update our feature extractor. >>> x = next ( X ) >>> agg = agg . learn_one ( x ) At this point, the average defaults to the initial value of stats.Mean , which is 0. >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 0.0 } We can now update our feature extractor with the next data point and check the output. >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 10.0 } >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 12.5 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Shift"},{"location":"api/stats/Shift/#shift","text":"Shifts a data stream by returning past values. This can be used to compute statistics over past data. For instance, if you're computing daily averages, then shifting by 7 will be equivalent to computing averages from a week ago. Shifting values is useful when you're calculating an average over a target value. Indeed, in this case it's important to shift the values in order not to introduce leakage. The recommended way to do this is to feature_extraction.TargetAgg , which already takes care of shifting the target values once.","title":"Shift"},{"location":"api/stats/Shift/#parameters","text":"amount \u2013 defaults to 1 Shift amount. The get method will return the t - amount value, where t is the current moment. fill_value \u2013 defaults to None This value will be returned by the get method if not enough values have been observed.","title":"Parameters"},{"location":"api/stats/Shift/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Shift/#examples","text":"It is rare to have to use Shift by itself. A more common usage is to compose it with other statistics. This can be done via the | operator. >>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () >>> for i in range ( 5 ): ... stat = stat . update ( i ) ... print ( stat . get ()) 0.0 0.0 0.5 1.0 1.5 A common usecase for using Shift is when computing statistics on shifted data. For instance, say you have a dataset which records the amount of sales for a set of shops. You might then have a shop field and a sales field. Let's say you want to look at the average amount of sales per shop. You can do this by using a feature_extraction.Agg . When you call transform_one , you're expecting it to return the average amount of sales, without including today's sales. You can do this by prepending an instance of stats.Mean with an instance of stats.Shift . >>> from river import feature_extraction >>> agg = feature_extraction . Agg ( ... on = 'sales' , ... how = stats . Shift ( 1 ) | stats . Mean (), ... by = 'shop' ... ) Let's define a little example dataset. >>> X = iter ([ ... { 'shop' : 'Ikea' , 'sales' : 10 }, ... { 'shop' : 'Ikea' , 'sales' : 15 }, ... { 'shop' : 'Ikea' , 'sales' : 20 } ... ]) Now let's call the learn_one method to update our feature extractor. >>> x = next ( X ) >>> agg = agg . learn_one ( x ) At this point, the average defaults to the initial value of stats.Mean , which is 0. >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 0.0 } We can now update our feature extractor with the next data point and check the output. >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 10.0 } >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 12.5 }","title":"Examples"},{"location":"api/stats/Shift/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Skew/","text":"Skew \u00b6 Running skew using Welford's algorithm. Parameters \u00b6 bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias. Attributes \u00b6 name Examples \u00b6 >>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> skew = river . stats . Skew ( bias = False ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 1.4802398132849872 0.5127437186677888 0.7803466510704751 1.056115628922055 0.5057840774320389 0.3478402420400934 0.4536710660918704 0.4123070197493227 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = False )) 0.0 0.0 - 1.4802398132849874 0.5127437186677893 0.7803466510704746 1.056115628922055 0.5057840774320389 0.3478402420400927 0.4536710660918703 0.4123070197493223 >>> skew = river . stats . Skew ( bias = True ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 0.6043053732501439 0.2960327239981376 0.5234724473423674 0.7712778043924866 0.39022088752624845 0.278892645224261 0.37425953513864063 0.3476878073823696 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = True )) 0.0 0.0 - 0.604305373250144 0.29603272399813796 0.5234724473423671 0.7712778043924865 0.39022088752624845 0.2788926452242604 0.3742595351386406 0.34768780738236926 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9","title":"Skew"},{"location":"api/stats/Skew/#skew","text":"Running skew using Welford's algorithm.","title":"Skew"},{"location":"api/stats/Skew/#parameters","text":"bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias.","title":"Parameters"},{"location":"api/stats/Skew/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Skew/#examples","text":">>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> skew = river . stats . Skew ( bias = False ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 1.4802398132849872 0.5127437186677888 0.7803466510704751 1.056115628922055 0.5057840774320389 0.3478402420400934 0.4536710660918704 0.4123070197493227 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = False )) 0.0 0.0 - 1.4802398132849874 0.5127437186677893 0.7803466510704746 1.056115628922055 0.5057840774320389 0.3478402420400927 0.4536710660918703 0.4123070197493223 >>> skew = river . stats . Skew ( bias = True ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 0.6043053732501439 0.2960327239981376 0.5234724473423674 0.7712778043924866 0.39022088752624845 0.278892645224261 0.37425953513864063 0.3476878073823696 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = True )) 0.0 0.0 - 0.604305373250144 0.29603272399813796 0.5234724473423671 0.7712778043924865 0.39022088752624845 0.2788926452242604 0.3742595351386406 0.34768780738236926","title":"Examples"},{"location":"api/stats/Skew/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Skew/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9","title":"References"},{"location":"api/stats/Sum/","text":"Sum \u00b6 Running sum. Attributes \u00b6 sum ( float ) The running sum. Examples \u00b6 >>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Sum () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 8.0 - 9.0 - 8.0 - 5.0 0.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Sum"},{"location":"api/stats/Sum/#sum","text":"Running sum.","title":"Sum"},{"location":"api/stats/Sum/#attributes","text":"sum ( float ) The running sum.","title":"Attributes"},{"location":"api/stats/Sum/#examples","text":">>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Sum () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 8.0 - 9.0 - 8.0 - 5.0 0.0","title":"Examples"},{"location":"api/stats/Sum/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Univariate/","text":"Univariate \u00b6 A univariate statistic measures a property of a variable. Attributes \u00b6 name Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Univariate"},{"location":"api/stats/Univariate/#univariate","text":"A univariate statistic measures a property of a variable.","title":"Univariate"},{"location":"api/stats/Univariate/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Univariate/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Var/","text":"Var \u00b6 Running variance using Welford's algorithm. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n represents the number of seen elements. Attributes \u00b6 mean ( stats.Mean ) The running mean. sigma ( float ) The running variance. Examples \u00b6 >>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> var = river . stats . Var () >>> for x in X : ... print ( var . update ( x ) . get ()) 0.0 2.0 1.0 2.916666 7.7 12.56666 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 Notes \u00b6 The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\\\text{ddof} \\le 1\\) . References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"Var"},{"location":"api/stats/Var/#var","text":"Running variance using Welford's algorithm.","title":"Var"},{"location":"api/stats/Var/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n represents the number of seen elements.","title":"Parameters"},{"location":"api/stats/Var/#attributes","text":"mean ( stats.Mean ) The running mean. sigma ( float ) The running variance.","title":"Attributes"},{"location":"api/stats/Var/#examples","text":">>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> var = river . stats . Var () >>> for x in X : ... print ( var . update ( x ) . get ()) 0.0 2.0 1.0 2.916666 7.7 12.56666","title":"Examples"},{"location":"api/stats/Var/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x w \u2013 defaults to 1.0","title":"Methods"},{"location":"api/stats/Var/#notes","text":"The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\\\text{ddof} \\le 1\\) .","title":"Notes"},{"location":"api/stats/Var/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"References"},{"location":"api/stream/Cache/","text":"Cache \u00b6 Utility for caching iterables. This can be used to save a stream of data to the disk in order to iterate over it faster the following time. This can save time depending on the nature of stream. The more processing happens in a stream, the more time will be saved. Even in the case where no processing is done apart from reading the data, the cache will save some time because it is using the pickle binary protocol. It can thus improve the speed in common cases such as reading from a CSV file. Parameters \u00b6 directory \u2013 defaults to None The path where to store the pickled data streams. If not provided, then it will be automatically inferred whenever possible, if not an exception will be raised. Attributes \u00b6 keys ( set ) The set of keys that are being cached. Examples \u00b6 >>> import time >>> from river import datasets >>> from river import stream >>> dataset = datasets . Phishing () >>> cache = stream . Cache () The cache can be used by wrapping it around an iterable. Because this is the first time are iterating over the data, nothing is cached. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.012813 If we do the same thing again, we can see the loop is now faster. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.001927 We can see an overview of the cache. The first line indicates the location of the cache. >>> cache # doctest: +SKIP / tmp phishing - 125.2 KiB Finally, we can clear the stream from the cache. >>> cache . clear ( 'phishing' ) >>> cache / tmp There is also a clear_all method to remove all the items in the cache. >>> cache . clear_all () Methods \u00b6 call Call self as a function. Parameters stream key \u2013 defaults to None clear Delete the cached stream associated with the given key. Parameters key ( str ) clear_all Delete all the cached streams.","title":"Cache"},{"location":"api/stream/Cache/#cache","text":"Utility for caching iterables. This can be used to save a stream of data to the disk in order to iterate over it faster the following time. This can save time depending on the nature of stream. The more processing happens in a stream, the more time will be saved. Even in the case where no processing is done apart from reading the data, the cache will save some time because it is using the pickle binary protocol. It can thus improve the speed in common cases such as reading from a CSV file.","title":"Cache"},{"location":"api/stream/Cache/#parameters","text":"directory \u2013 defaults to None The path where to store the pickled data streams. If not provided, then it will be automatically inferred whenever possible, if not an exception will be raised.","title":"Parameters"},{"location":"api/stream/Cache/#attributes","text":"keys ( set ) The set of keys that are being cached.","title":"Attributes"},{"location":"api/stream/Cache/#examples","text":">>> import time >>> from river import datasets >>> from river import stream >>> dataset = datasets . Phishing () >>> cache = stream . Cache () The cache can be used by wrapping it around an iterable. Because this is the first time are iterating over the data, nothing is cached. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.012813 If we do the same thing again, we can see the loop is now faster. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.001927 We can see an overview of the cache. The first line indicates the location of the cache. >>> cache # doctest: +SKIP / tmp phishing - 125.2 KiB Finally, we can clear the stream from the cache. >>> cache . clear ( 'phishing' ) >>> cache / tmp There is also a clear_all method to remove all the items in the cache. >>> cache . clear_all ()","title":"Examples"},{"location":"api/stream/Cache/#methods","text":"call Call self as a function. Parameters stream key \u2013 defaults to None clear Delete the cached stream associated with the given key. Parameters key ( str ) clear_all Delete all the cached streams.","title":"Methods"},{"location":"api/stream/iter-arff/","text":"iter_arff \u00b6 Iterates over rows from an ARFF file. Parameters \u00b6 filepath_or_buffer Either a string indicating the location of a CSV file, or a buffer object that has a read method. target ( str ) \u2013 defaults to None Name of the target field. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.","title":"iter_arff"},{"location":"api/stream/iter-arff/#iter_arff","text":"Iterates over rows from an ARFF file.","title":"iter_arff"},{"location":"api/stream/iter-arff/#parameters","text":"filepath_or_buffer Either a string indicating the location of a CSV file, or a buffer object that has a read method. target ( str ) \u2013 defaults to None Name of the target field. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.","title":"Parameters"},{"location":"api/stream/iter-array/","text":"iter_array \u00b6 Iterates over the rows from an array of features and an array of targets. This method is intended to work with numpy arrays, but should also work with Python lists. Parameters \u00b6 X ( numpy.ndarray ) A 2D array of features. y ( numpy.ndarray ) \u2013 defaults to None An optional array of targets. feature_names ( List[Hashable] ) \u2013 defaults to None An optional list of feature names. The features will be labeled with integers if no names are provided. target_names ( List[Hashable] ) \u2013 defaults to None An optional list of output names. The outputs will be labeled with integers if no names are provided. Only applies if there are multiple outputs, i.e. if y is a 2D array. shuffle ( bool ) \u2013 defaults to False Indicates whether or not to shuffle the input arrays before iterating over them. seed ( int ) \u2013 defaults to None Random seed used for shuffling the data. Examples \u00b6 >>> from river import stream >>> import numpy as np >>> X = np . array ([[ 1 , 2 , 3 ], [ 11 , 12 , 13 ]]) >>> Y = np . array ([ True , False ]) >>> dataset = stream . iter_array ( ... X , Y , ... feature_names = [ 'x1' , 'x2' , 'x3' ] ... ) >>> for x , y in dataset : ... print ( x , y ) { 'x1' : 1 , 'x2' : 2 , 'x3' : 3 } True { 'x1' : 11 , 'x2' : 12 , 'x3' : 13 } False","title":"iter_array"},{"location":"api/stream/iter-array/#iter_array","text":"Iterates over the rows from an array of features and an array of targets. This method is intended to work with numpy arrays, but should also work with Python lists.","title":"iter_array"},{"location":"api/stream/iter-array/#parameters","text":"X ( numpy.ndarray ) A 2D array of features. y ( numpy.ndarray ) \u2013 defaults to None An optional array of targets. feature_names ( List[Hashable] ) \u2013 defaults to None An optional list of feature names. The features will be labeled with integers if no names are provided. target_names ( List[Hashable] ) \u2013 defaults to None An optional list of output names. The outputs will be labeled with integers if no names are provided. Only applies if there are multiple outputs, i.e. if y is a 2D array. shuffle ( bool ) \u2013 defaults to False Indicates whether or not to shuffle the input arrays before iterating over them. seed ( int ) \u2013 defaults to None Random seed used for shuffling the data.","title":"Parameters"},{"location":"api/stream/iter-array/#examples","text":">>> from river import stream >>> import numpy as np >>> X = np . array ([[ 1 , 2 , 3 ], [ 11 , 12 , 13 ]]) >>> Y = np . array ([ True , False ]) >>> dataset = stream . iter_array ( ... X , Y , ... feature_names = [ 'x1' , 'x2' , 'x3' ] ... ) >>> for x , y in dataset : ... print ( x , y ) { 'x1' : 1 , 'x2' : 2 , 'x3' : 3 } True { 'x1' : 11 , 'x2' : 12 , 'x3' : 13 } False","title":"Examples"},{"location":"api/stream/iter-csv/","text":"iter_csv \u00b6 Iterates over rows from a CSV file. Reading CSV files can be quite slow. If, for whatever reason, you're going to loop through the same file multiple times, then we recommend that you to use the stream.Cache utility. Parameters \u00b6 filepath_or_buffer Either a string indicating the location of a CSV file, or a buffer object that has a read method. target ( Union[str, List[str]] ) \u2013 defaults to None A single target column is assumed if a string is passed. A multiple output scenario is assumed if a list of strings is passed. A None value will be assigned to each y if this parameter is omitted. converters ( dict ) \u2013 defaults to None A dict mapping feature names to callables used to parse their associated values. parse_dates ( dict ) \u2013 defaults to None A dict mapping feature names to a format passed to the datetime.datetime.strptime method. drop ( List[str] ) \u2013 defaults to None Fields to ignore. fraction \u2013 defaults to 1.0 Sampling fraction. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'. seed ( int ) \u2013 defaults to None If specified, the sampling will be deterministic. field_size_limit ( int ) \u2013 defaults to None If not None , this will be passed to the csv.field_size_limit function. kwargs All other keyword arguments are passed to the underlying csv.DictReader . Examples \u00b6 Although this function is designed to handle different kinds of inputs, the most common use case is to read a file on the disk. We'll first create a little CSV file to illustrate. >>> tv_shows = '''name,year,rating ... Planet Earth II,2016,9.5 ... Planet Earth,2006,9.4 ... Band of Brothers,2001,9.4 ... Breaking Bad,2008,9.4 ... Chernobyl,2019,9.4 ... ''' >>> with open ( 'tv_shows.csv' , mode = 'w' ) as f : ... _ = f . write ( tv_shows ) We can now go through the rows one by one. We can use the converters parameter to cast the rating field value as a float . We can also convert the year to a datetime via the parse_dates parameter. >>> from river import stream >>> params = { ... 'converters' : { 'rating' : float }, ... 'parse_dates' : { 'year' : '%Y' } ... } >>> for x , y in stream . iter_csv ( 'tv_shows.csv' , ** params ): ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 ), 'rating' : 9.5 } None { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None The value of y is always None because we haven't provided a value for the target parameter. Here is an example where a target is provided: >>> dataset = stream . iter_csv ( 'tv_shows.csv' , target = 'rating' , ** params ) >>> for x , y in dataset : ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 )} 9.5 { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 )} 9.4 Finally, let's delete the example file. >>> import os ; os . remove ( 'tv_shows.csv' )","title":"iter_csv"},{"location":"api/stream/iter-csv/#iter_csv","text":"Iterates over rows from a CSV file. Reading CSV files can be quite slow. If, for whatever reason, you're going to loop through the same file multiple times, then we recommend that you to use the stream.Cache utility.","title":"iter_csv"},{"location":"api/stream/iter-csv/#parameters","text":"filepath_or_buffer Either a string indicating the location of a CSV file, or a buffer object that has a read method. target ( Union[str, List[str]] ) \u2013 defaults to None A single target column is assumed if a string is passed. A multiple output scenario is assumed if a list of strings is passed. A None value will be assigned to each y if this parameter is omitted. converters ( dict ) \u2013 defaults to None A dict mapping feature names to callables used to parse their associated values. parse_dates ( dict ) \u2013 defaults to None A dict mapping feature names to a format passed to the datetime.datetime.strptime method. drop ( List[str] ) \u2013 defaults to None Fields to ignore. fraction \u2013 defaults to 1.0 Sampling fraction. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'. seed ( int ) \u2013 defaults to None If specified, the sampling will be deterministic. field_size_limit ( int ) \u2013 defaults to None If not None , this will be passed to the csv.field_size_limit function. kwargs All other keyword arguments are passed to the underlying csv.DictReader .","title":"Parameters"},{"location":"api/stream/iter-csv/#examples","text":"Although this function is designed to handle different kinds of inputs, the most common use case is to read a file on the disk. We'll first create a little CSV file to illustrate. >>> tv_shows = '''name,year,rating ... Planet Earth II,2016,9.5 ... Planet Earth,2006,9.4 ... Band of Brothers,2001,9.4 ... Breaking Bad,2008,9.4 ... Chernobyl,2019,9.4 ... ''' >>> with open ( 'tv_shows.csv' , mode = 'w' ) as f : ... _ = f . write ( tv_shows ) We can now go through the rows one by one. We can use the converters parameter to cast the rating field value as a float . We can also convert the year to a datetime via the parse_dates parameter. >>> from river import stream >>> params = { ... 'converters' : { 'rating' : float }, ... 'parse_dates' : { 'year' : '%Y' } ... } >>> for x , y in stream . iter_csv ( 'tv_shows.csv' , ** params ): ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 ), 'rating' : 9.5 } None { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None The value of y is always None because we haven't provided a value for the target parameter. Here is an example where a target is provided: >>> dataset = stream . iter_csv ( 'tv_shows.csv' , target = 'rating' , ** params ) >>> for x , y in dataset : ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 )} 9.5 { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 )} 9.4 Finally, let's delete the example file. >>> import os ; os . remove ( 'tv_shows.csv' )","title":"Examples"},{"location":"api/stream/iter-libsvm/","text":"iter_libsvm \u00b6 Iterates over a dataset in LIBSVM format. The LIBSVM format is a popular way in the machine learning community to store sparse datasets. Only numerical feature values are supported. The feature names will be considered as strings. Parameters \u00b6 filepath_or_buffer ( str ) Either a string indicating the location of a CSV file, or a buffer object that has a read method. target_type \u2013 defaults to <class 'float'> The type of the target value. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'. Examples \u00b6 >>> import io >>> from river import stream >>> data = io . StringIO ( '''+1 x:-134.26 y:0.2563 ... 1 x:-12 z:0.3 ... -1 y:.25 ... ''' ) >>> for x , y in stream . iter_libsvm ( data , target_type = int ): ... print ( y , x ) 1 { 'x' : - 134.26 , 'y' : 0.2563 } 1 { 'x' : - 12.0 , 'z' : 0.3 } - 1 { 'y' : 0.25 } References \u00b6 LIBSVM documentation \u21a9","title":"iter_libsvm"},{"location":"api/stream/iter-libsvm/#iter_libsvm","text":"Iterates over a dataset in LIBSVM format. The LIBSVM format is a popular way in the machine learning community to store sparse datasets. Only numerical feature values are supported. The feature names will be considered as strings.","title":"iter_libsvm"},{"location":"api/stream/iter-libsvm/#parameters","text":"filepath_or_buffer ( str ) Either a string indicating the location of a CSV file, or a buffer object that has a read method. target_type \u2013 defaults to <class 'float'> The type of the target value. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.","title":"Parameters"},{"location":"api/stream/iter-libsvm/#examples","text":">>> import io >>> from river import stream >>> data = io . StringIO ( '''+1 x:-134.26 y:0.2563 ... 1 x:-12 z:0.3 ... -1 y:.25 ... ''' ) >>> for x , y in stream . iter_libsvm ( data , target_type = int ): ... print ( y , x ) 1 { 'x' : - 134.26 , 'y' : 0.2563 } 1 { 'x' : - 12.0 , 'z' : 0.3 } - 1 { 'y' : 0.25 }","title":"Examples"},{"location":"api/stream/iter-libsvm/#references","text":"LIBSVM documentation \u21a9","title":"References"},{"location":"api/stream/iter-pandas/","text":"iter_pandas \u00b6 Iterates over the rows of a pandas.DataFrame . Parameters \u00b6 X ( pandas.core.frame.DataFrame ) A dataframe of features. y ( Union[pandas.core.series.Series, pandas.core.frame.DataFrame] ) \u2013 defaults to None A series or a dataframe with one column per target. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array . Examples \u00b6 >>> import pandas as pd >>> from river import stream >>> X = pd . DataFrame ({ ... 'x1' : [ 1 , 2 , 3 , 4 ], ... 'x2' : [ 'blue' , 'yellow' , 'yellow' , 'blue' ], ... 'y' : [ True , False , False , True ] ... }) >>> y = X . pop ( 'y' ) >>> for xi , yi in stream . iter_pandas ( X , y ): ... print ( xi , yi ) { 'x1' : 1 , 'x2' : 'blue' } True { 'x1' : 2 , 'x2' : 'yellow' } False { 'x1' : 3 , 'x2' : 'yellow' } False { 'x1' : 4 , 'x2' : 'blue' } True","title":"iter_pandas"},{"location":"api/stream/iter-pandas/#iter_pandas","text":"Iterates over the rows of a pandas.DataFrame .","title":"iter_pandas"},{"location":"api/stream/iter-pandas/#parameters","text":"X ( pandas.core.frame.DataFrame ) A dataframe of features. y ( Union[pandas.core.series.Series, pandas.core.frame.DataFrame] ) \u2013 defaults to None A series or a dataframe with one column per target. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array .","title":"Parameters"},{"location":"api/stream/iter-pandas/#examples","text":">>> import pandas as pd >>> from river import stream >>> X = pd . DataFrame ({ ... 'x1' : [ 1 , 2 , 3 , 4 ], ... 'x2' : [ 'blue' , 'yellow' , 'yellow' , 'blue' ], ... 'y' : [ True , False , False , True ] ... }) >>> y = X . pop ( 'y' ) >>> for xi , yi in stream . iter_pandas ( X , y ): ... print ( xi , yi ) { 'x1' : 1 , 'x2' : 'blue' } True { 'x1' : 2 , 'x2' : 'yellow' } False { 'x1' : 3 , 'x2' : 'yellow' } False { 'x1' : 4 , 'x2' : 'blue' } True","title":"Examples"},{"location":"api/stream/iter-sklearn-dataset/","text":"iter_sklearn_dataset \u00b6 Iterates rows from one of the datasets provided by scikit-learn. This allows you to use any dataset from scikit-learn's datasets module . For instance, you can use the fetch_openml function to get access to all of the datasets from the OpenML website. Parameters \u00b6 dataset ( 'sklearn.utils.Bunch' ) A scikit-learn dataset. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array . Examples \u00b6 >>> import pprint >>> from sklearn import datasets >>> from river import stream >>> dataset = datasets . load_boston () >>> for xi , yi in stream . iter_sklearn_dataset ( dataset ): ... pprint . pprint ( xi ) ... print ( yi ) ... break { 'AGE' : 65.2 , 'B' : 396.9 , 'CHAS' : 0.0 , 'CRIM' : 0.00632 , 'DIS' : 4.09 , 'INDUS' : 2.31 , 'LSTAT' : 4.98 , 'NOX' : 0.538 , 'PTRATIO' : 15.3 , 'RAD' : 1.0 , 'RM' : 6.575 , 'TAX' : 296.0 , 'ZN' : 18.0 } 24.0","title":"iter_sklearn_dataset"},{"location":"api/stream/iter-sklearn-dataset/#iter_sklearn_dataset","text":"Iterates rows from one of the datasets provided by scikit-learn. This allows you to use any dataset from scikit-learn's datasets module . For instance, you can use the fetch_openml function to get access to all of the datasets from the OpenML website.","title":"iter_sklearn_dataset"},{"location":"api/stream/iter-sklearn-dataset/#parameters","text":"dataset ( 'sklearn.utils.Bunch' ) A scikit-learn dataset. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array .","title":"Parameters"},{"location":"api/stream/iter-sklearn-dataset/#examples","text":">>> import pprint >>> from sklearn import datasets >>> from river import stream >>> dataset = datasets . load_boston () >>> for xi , yi in stream . iter_sklearn_dataset ( dataset ): ... pprint . pprint ( xi ) ... print ( yi ) ... break { 'AGE' : 65.2 , 'B' : 396.9 , 'CHAS' : 0.0 , 'CRIM' : 0.00632 , 'DIS' : 4.09 , 'INDUS' : 2.31 , 'LSTAT' : 4.98 , 'NOX' : 0.538 , 'PTRATIO' : 15.3 , 'RAD' : 1.0 , 'RM' : 6.575 , 'TAX' : 296.0 , 'ZN' : 18.0 } 24.0","title":"Examples"},{"location":"api/stream/iter-sql/","text":"iter_sql \u00b6 Iterates over the results from an SQL query. By default, SQLAlchemy prefetches results. Therefore, even though you can iterate over the resulting rows one by one, the results are in fact loaded in batch. You can modify this behavior by configuring the connection you pass to iter_sql . For instance, you can set the stream_results parameter to True , as explained in SQLAlchemy's documentation . Note, however, that this isn't available for all database engines. Parameters \u00b6 query ( Union[str, sqlalchemy.sql.selectable.Selectable] ) SQL query to be executed. conn ( sqlalchemy.engine.interfaces.Connectable ) An SQLAlchemy construct which has an execute method. In other words you can pass an engine, a connection, or a session. target_name ( str ) \u2013 defaults to None The name of the target field. If this is None , then y will also be None . Examples \u00b6 As an example we'll create an in-memory database with SQLAlchemy. >>> import datetime as dt >>> import sqlalchemy >>> engine = sqlalchemy . create_engine ( 'sqlite://' ) >>> metadata = sqlalchemy . MetaData () >>> t_sales = sqlalchemy . Table ( 'sales' , metadata , ... sqlalchemy . Column ( 'shop' , sqlalchemy . String , primary_key = True ), ... sqlalchemy . Column ( 'date' , sqlalchemy . Date , primary_key = True ), ... sqlalchemy . Column ( 'amount' , sqlalchemy . Integer ) ... ) >>> metadata . create_all ( engine ) >>> sales = [ ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 20 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 18 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 22 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 14 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 12 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 16 } ... ] >>> with engine . connect () as conn : ... _ = conn . execute ( t_sales . insert (), sales ) We can now query the database. We will set amount to be the target field. >>> from river import stream >>> with engine . connect () as conn : ... query = 'SELECT * FROM sales;' ... dataset = stream . iter_sql ( query , conn , target_name = 'amount' ) ... for x , y in dataset : ... print ( x , y ) { 'shop' : 'Hema' , 'date' : '2016-08-02' } 20 { 'shop' : 'Ikea' , 'date' : '2016-08-02' } 18 { 'shop' : 'Hema' , 'date' : '2016-08-03' } 22 { 'shop' : 'Ikea' , 'date' : '2016-08-03' } 14 { 'shop' : 'Hema' , 'date' : '2016-08-04' } 12 { 'shop' : 'Ikea' , 'date' : '2016-08-04' } 16","title":"iter_sql"},{"location":"api/stream/iter-sql/#iter_sql","text":"Iterates over the results from an SQL query. By default, SQLAlchemy prefetches results. Therefore, even though you can iterate over the resulting rows one by one, the results are in fact loaded in batch. You can modify this behavior by configuring the connection you pass to iter_sql . For instance, you can set the stream_results parameter to True , as explained in SQLAlchemy's documentation . Note, however, that this isn't available for all database engines.","title":"iter_sql"},{"location":"api/stream/iter-sql/#parameters","text":"query ( Union[str, sqlalchemy.sql.selectable.Selectable] ) SQL query to be executed. conn ( sqlalchemy.engine.interfaces.Connectable ) An SQLAlchemy construct which has an execute method. In other words you can pass an engine, a connection, or a session. target_name ( str ) \u2013 defaults to None The name of the target field. If this is None , then y will also be None .","title":"Parameters"},{"location":"api/stream/iter-sql/#examples","text":"As an example we'll create an in-memory database with SQLAlchemy. >>> import datetime as dt >>> import sqlalchemy >>> engine = sqlalchemy . create_engine ( 'sqlite://' ) >>> metadata = sqlalchemy . MetaData () >>> t_sales = sqlalchemy . Table ( 'sales' , metadata , ... sqlalchemy . Column ( 'shop' , sqlalchemy . String , primary_key = True ), ... sqlalchemy . Column ( 'date' , sqlalchemy . Date , primary_key = True ), ... sqlalchemy . Column ( 'amount' , sqlalchemy . Integer ) ... ) >>> metadata . create_all ( engine ) >>> sales = [ ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 20 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 18 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 22 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 14 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 12 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 16 } ... ] >>> with engine . connect () as conn : ... _ = conn . execute ( t_sales . insert (), sales ) We can now query the database. We will set amount to be the target field. >>> from river import stream >>> with engine . connect () as conn : ... query = 'SELECT * FROM sales;' ... dataset = stream . iter_sql ( query , conn , target_name = 'amount' ) ... for x , y in dataset : ... print ( x , y ) { 'shop' : 'Hema' , 'date' : '2016-08-02' } 20 { 'shop' : 'Ikea' , 'date' : '2016-08-02' } 18 { 'shop' : 'Hema' , 'date' : '2016-08-03' } 22 { 'shop' : 'Ikea' , 'date' : '2016-08-03' } 14 { 'shop' : 'Hema' , 'date' : '2016-08-04' } 12 { 'shop' : 'Ikea' , 'date' : '2016-08-04' } 16","title":"Examples"},{"location":"api/stream/shuffle/","text":"shuffle \u00b6 Shuffles a stream of data. This works by maintaining a buffer of elements. The first buffer_size elements are stored in memory. Once the buffer is full, a random element inside the buffer is yielded. Every time an element is yielded, the next element in the stream replaces it and the buffer is sampled again. Increasing buffer_size will improve the quality of the shuffling. If you really want to stream over your dataset in a \"good\" random order, the best way is to split your dataset into smaller datasets and loop over them in a round-robin fashion. You may do this by using the roundrobin recipe from the itertools module. Parameters \u00b6 stream ( Iterator ) The stream to shuffle. buffer_size ( int ) The size of the buffer which contains the elements help in memory. Increasing this will increase randomness but will incur more memory usage. seed ( int ) \u2013 defaults to None Random seed used for sampling. Examples \u00b6 >>> from river import stream >>> for i in stream . shuffle ( range ( 15 ), buffer_size = 5 , seed = 42 ): ... print ( i ) 0 5 2 1 8 9 6 4 11 12 10 7 14 13 3 References \u00b6 Visualizing TensorFlow's streaming shufflers \u21a9","title":"shuffle"},{"location":"api/stream/shuffle/#shuffle","text":"Shuffles a stream of data. This works by maintaining a buffer of elements. The first buffer_size elements are stored in memory. Once the buffer is full, a random element inside the buffer is yielded. Every time an element is yielded, the next element in the stream replaces it and the buffer is sampled again. Increasing buffer_size will improve the quality of the shuffling. If you really want to stream over your dataset in a \"good\" random order, the best way is to split your dataset into smaller datasets and loop over them in a round-robin fashion. You may do this by using the roundrobin recipe from the itertools module.","title":"shuffle"},{"location":"api/stream/shuffle/#parameters","text":"stream ( Iterator ) The stream to shuffle. buffer_size ( int ) The size of the buffer which contains the elements help in memory. Increasing this will increase randomness but will incur more memory usage. seed ( int ) \u2013 defaults to None Random seed used for sampling.","title":"Parameters"},{"location":"api/stream/shuffle/#examples","text":">>> from river import stream >>> for i in stream . shuffle ( range ( 15 ), buffer_size = 5 , seed = 42 ): ... print ( i ) 0 5 2 1 8 9 6 4 11 12 10 7 14 13 3","title":"Examples"},{"location":"api/stream/shuffle/#references","text":"Visualizing TensorFlow's streaming shufflers \u21a9","title":"References"},{"location":"api/stream/simulate-qa/","text":"simulate_qa \u00b6 Simulate a time-ordered question and answer session. This method allows looping through a dataset in the order in which it arrived. Indeed, it usually is the case that labels arrive after features. Being able to go through a dataset in arrival order enables assessing a model's performance in a reliable manner. For instance, the evaluate.progressive_val_score is a high-level method that can be used to score a model on a dataset. Under the hood it uses this method to determine the correct arrival order. Parameters \u00b6 dataset ( Iterator[Tuple[dict, Any]] ) A stream of (features, target) tuples. moment ( Union[str, Callable] ) The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. If a str is passed, then it will be used to obtain the time from the input features. delay ( Union[str, int, datetime.timedelta, Callable] ) The amount of time to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. If a scalar is passed, such an int or a datetime.timedelta , then the delay is constant. copy ( bool ) \u2013 defaults to True If True , then a separate copy of the features are yielded the second time around. This ensures that inadvertent modifications in downstream code don't have any effect. Examples \u00b6 The arrival delay isn't usually indicated in a dataset, but it might be able to be inferred from the features. As an example, we'll simulate the departure and arrival time of taxi trips. Let's first create a time table which records the departure time and the duration of seconds of several taxi trips. >>> import datetime as dt >>> time_table = [ ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 0 , 0 ), 900 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 10 , 0 ), 1800 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 20 , 0 ), 300 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 45 , 0 ), 400 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 50 , 0 ), 240 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 55 , 0 ), 450 ) ... ] We can now create a streaming dataset where the features are the departure dates and the targets are the durations. >>> dataset = ( ... ({ 'date' : date }, duration ) ... for date , duration in time_table ... ) Now, we can use simulate_qa to iterate over the events in the order in which they are meant to occur. >>> delay = lambda _ , y : dt . timedelta ( seconds = y ) >>> for i , x , y in simulate_qa ( dataset , moment = 'date' , delay = delay ): ... if y is None : ... print ( f ' { x [ \"date\" ] } - trip # { i } departs' ) ... else : ... arrival_date = x [ 'date' ] + dt . timedelta ( seconds = y ) ... print ( f ' { arrival_date } - trip # { i } arrives after { y } seconds' ) 2020 - 01 - 01 20 : 00 : 00 - trip #0 departs 2020 - 01 - 01 20 : 10 : 00 - trip #1 departs 2020 - 01 - 01 20 : 15 : 00 - trip #0 arrives after 900 seconds 2020 - 01 - 01 20 : 20 : 00 - trip #2 departs 2020 - 01 - 01 20 : 25 : 00 - trip #2 arrives after 300 seconds 2020 - 01 - 01 20 : 40 : 00 - trip #1 arrives after 1800 seconds 2020 - 01 - 01 20 : 45 : 00 - trip #3 departs 2020 - 01 - 01 20 : 50 : 00 - trip #4 departs 2020 - 01 - 01 20 : 51 : 40 - trip #3 arrives after 400 seconds 2020 - 01 - 01 20 : 54 : 00 - trip #4 arrives after 240 seconds 2020 - 01 - 01 20 : 55 : 00 - trip #5 departs 2020 - 01 - 01 21 : 02 : 30 - trip #5 arrives after 450 seconds This function is extremely practical because it provides a reliable way to evaluate the performance of a model in a real scenario. Indeed, it allows to make predictions and perform model updates in exactly the same manner that would happen live. For instance, it is used in evaluate.progressive_val_score , which is a higher level function for evaluating models in an online manner.","title":"simulate_qa"},{"location":"api/stream/simulate-qa/#simulate_qa","text":"Simulate a time-ordered question and answer session. This method allows looping through a dataset in the order in which it arrived. Indeed, it usually is the case that labels arrive after features. Being able to go through a dataset in arrival order enables assessing a model's performance in a reliable manner. For instance, the evaluate.progressive_val_score is a high-level method that can be used to score a model on a dataset. Under the hood it uses this method to determine the correct arrival order.","title":"simulate_qa"},{"location":"api/stream/simulate-qa/#parameters","text":"dataset ( Iterator[Tuple[dict, Any]] ) A stream of (features, target) tuples. moment ( Union[str, Callable] ) The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. If a str is passed, then it will be used to obtain the time from the input features. delay ( Union[str, int, datetime.timedelta, Callable] ) The amount of time to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. If a scalar is passed, such an int or a datetime.timedelta , then the delay is constant. copy ( bool ) \u2013 defaults to True If True , then a separate copy of the features are yielded the second time around. This ensures that inadvertent modifications in downstream code don't have any effect.","title":"Parameters"},{"location":"api/stream/simulate-qa/#examples","text":"The arrival delay isn't usually indicated in a dataset, but it might be able to be inferred from the features. As an example, we'll simulate the departure and arrival time of taxi trips. Let's first create a time table which records the departure time and the duration of seconds of several taxi trips. >>> import datetime as dt >>> time_table = [ ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 0 , 0 ), 900 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 10 , 0 ), 1800 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 20 , 0 ), 300 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 45 , 0 ), 400 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 50 , 0 ), 240 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 55 , 0 ), 450 ) ... ] We can now create a streaming dataset where the features are the departure dates and the targets are the durations. >>> dataset = ( ... ({ 'date' : date }, duration ) ... for date , duration in time_table ... ) Now, we can use simulate_qa to iterate over the events in the order in which they are meant to occur. >>> delay = lambda _ , y : dt . timedelta ( seconds = y ) >>> for i , x , y in simulate_qa ( dataset , moment = 'date' , delay = delay ): ... if y is None : ... print ( f ' { x [ \"date\" ] } - trip # { i } departs' ) ... else : ... arrival_date = x [ 'date' ] + dt . timedelta ( seconds = y ) ... print ( f ' { arrival_date } - trip # { i } arrives after { y } seconds' ) 2020 - 01 - 01 20 : 00 : 00 - trip #0 departs 2020 - 01 - 01 20 : 10 : 00 - trip #1 departs 2020 - 01 - 01 20 : 15 : 00 - trip #0 arrives after 900 seconds 2020 - 01 - 01 20 : 20 : 00 - trip #2 departs 2020 - 01 - 01 20 : 25 : 00 - trip #2 arrives after 300 seconds 2020 - 01 - 01 20 : 40 : 00 - trip #1 arrives after 1800 seconds 2020 - 01 - 01 20 : 45 : 00 - trip #3 departs 2020 - 01 - 01 20 : 50 : 00 - trip #4 departs 2020 - 01 - 01 20 : 51 : 40 - trip #3 arrives after 400 seconds 2020 - 01 - 01 20 : 54 : 00 - trip #4 arrives after 240 seconds 2020 - 01 - 01 20 : 55 : 00 - trip #5 departs 2020 - 01 - 01 21 : 02 : 30 - trip #5 arrives after 450 seconds This function is extremely practical because it provides a reliable way to evaluate the performance of a model in a real scenario. Indeed, it allows to make predictions and perform model updates in exactly the same manner that would happen live. For instance, it is used in evaluate.progressive_val_score , which is a higher level function for evaluating models in an online manner.","title":"Examples"},{"location":"api/synth/Agrawal/","text":"Agrawal \u00b6 Agrawal stream generator. The generator was introduced by Agrawal et al. 1 , and was a common source of data for early work on scaling up decision tree learners. The generator produces a stream containing nine features, six numeric and three categorical. There are 10 functions defined for generating binary class labels from the features. Presumably these determine whether the loan should be approved. Classification functions are listed in the original paper 1 . Feature | Description | Values salary | salary | uniformly distributed from 20k to 150k commission | commission | 0 if salary < 75k else uniformly distributed from 10k to 75k age | age | uniformly distributed from 20 to 80 elevel | education level | uniformly chosen from 0 to 4 car | car maker | uniformly chosen from 1 to 20 zipcode | zip code of the town | uniformly chosen from 0 to 8 hvalue | house value | uniformly distributed from 50k x zipcode to 100k x zipcode hyears | years house owned | uniformly distributed from 1 to 30 loan | total loan amount | uniformly distributed from 0 to 500k Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 The classification function to use for the generation. Valid values are from 0 to 9. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False If True, the class distribution will converge to a uniform distribution. perturbation ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. Each new sample will be perturbed by the magnitude of perturbation . Valid values are in the range [0.0 to 1.0]. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Agrawal ( classification_function = 0 , ... seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 68690.2154 , 81303.5729 , 62 , 4 , 6 , 2 , 419982.4410 , 11 , 433088.0728 ] 1 [ 98144.9515 , 0 , 43 , 2 , 1 , 7 , 266488.5281 , 6 , 389.3829 ] 0 [ 148987.502 , 0 , 52 , 3 , 11 , 8 , 79122.9140 , 27 , 199930.4858 ] 0 [ 26066.5362 , 83031.6639 , 34 , 2 , 11 , 6 , 444969.2657 , 25 , 23225.2063 ] 1 [ 98980.8307 , 0 , 40 , 0 , 6 , 1 , 1159108.4298 , 28 , 281644.1089 ] 0 Methods \u00b6 generate_drift Generate drift by switching the classification function randomly. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The 9 features are generated with the random generator, initialized with the seed passed by the user. Then, the classification function decides, as a function of all the attributes, whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. Finally, add noise if perturbation > 0.0. References \u00b6 Rakesh Agrawal, Tomasz Imielinksi, and Arun Swami. \"Database Mining: A Performance Perspective\", IEEE Transactions on Knowledge and Data Engineering, 5(6), December 1993. \u21a9 \u21a9","title":"Agrawal"},{"location":"api/synth/Agrawal/#agrawal","text":"Agrawal stream generator. The generator was introduced by Agrawal et al. 1 , and was a common source of data for early work on scaling up decision tree learners. The generator produces a stream containing nine features, six numeric and three categorical. There are 10 functions defined for generating binary class labels from the features. Presumably these determine whether the loan should be approved. Classification functions are listed in the original paper 1 . Feature | Description | Values salary | salary | uniformly distributed from 20k to 150k commission | commission | 0 if salary < 75k else uniformly distributed from 10k to 75k age | age | uniformly distributed from 20 to 80 elevel | education level | uniformly chosen from 0 to 4 car | car maker | uniformly chosen from 1 to 20 zipcode | zip code of the town | uniformly chosen from 0 to 8 hvalue | house value | uniformly distributed from 50k x zipcode to 100k x zipcode hyears | years house owned | uniformly distributed from 1 to 30 loan | total loan amount | uniformly distributed from 0 to 500k","title":"Agrawal"},{"location":"api/synth/Agrawal/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 The classification function to use for the generation. Valid values are from 0 to 9. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False If True, the class distribution will converge to a uniform distribution. perturbation ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. Each new sample will be perturbed by the magnitude of perturbation . Valid values are in the range [0.0 to 1.0].","title":"Parameters"},{"location":"api/synth/Agrawal/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Agrawal/#examples","text":">>> from river import synth >>> dataset = synth . Agrawal ( classification_function = 0 , ... seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 68690.2154 , 81303.5729 , 62 , 4 , 6 , 2 , 419982.4410 , 11 , 433088.0728 ] 1 [ 98144.9515 , 0 , 43 , 2 , 1 , 7 , 266488.5281 , 6 , 389.3829 ] 0 [ 148987.502 , 0 , 52 , 3 , 11 , 8 , 79122.9140 , 27 , 199930.4858 ] 0 [ 26066.5362 , 83031.6639 , 34 , 2 , 11 , 6 , 444969.2657 , 25 , 23225.2063 ] 1 [ 98980.8307 , 0 , 40 , 0 , 6 , 1 , 1159108.4298 , 28 , 281644.1089 ] 0","title":"Examples"},{"location":"api/synth/Agrawal/#methods","text":"generate_drift Generate drift by switching the classification function randomly. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Agrawal/#notes","text":"The sample generation works as follows: The 9 features are generated with the random generator, initialized with the seed passed by the user. Then, the classification function decides, as a function of all the attributes, whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. Finally, add noise if perturbation > 0.0.","title":"Notes"},{"location":"api/synth/Agrawal/#references","text":"Rakesh Agrawal, Tomasz Imielinksi, and Arun Swami. \"Database Mining: A Performance Perspective\", IEEE Transactions on Knowledge and Data Engineering, 5(6), December 1993. \u21a9 \u21a9","title":"References"},{"location":"api/synth/AnomalySine/","text":"AnomalySine \u00b6 Simulate a stream with anomalies in sine waves The data generated corresponds to sine ( attribute 1 ) and cosine ( attribute 2 ) functions. Anomalies are induced by replacing values from attribute 2 with values from a sine function different to the one used in attribute 1 . The contextual flag can be used to introduce contextual anomalies which are values in the normal global range, but abnormal compared to the seasonal pattern. Contextual attributes are introduced by replacing values in attribute 2 with values from attribute 1 . Parameters \u00b6 n_samples ( int ) \u2013 defaults to 10000 Number of samples n_anomalies ( int ) \u2013 defaults to 2500 Number of anomalies. Can't be larger than n_samples . contextual ( bool ) \u2013 defaults to False If True, will add contextual anomalies n_contextual ( int ) \u2013 defaults to 2500 Number of contextual anomalies. Can't be larger than n_samples . shift ( int ) \u2013 defaults to 4 Shift in number of samples applied when retrieving contextual anomalies noise ( float ) \u2013 defaults to 0.5 Amount of noise replace ( bool ) \u2013 defaults to True If True, anomalies are randomly sampled with replacement seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . AnomalySine ( seed = 12345 , ... n_samples = 100 , ... n_anomalies = 25 , ... contextual = True , ... n_contextual = 10 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'sine' : - 0.1023 , 'cosine' : 0.2171 } 0.0 { 'sine' : 0.4868 , 'cosine' : 0.6876 } 0.0 { 'sine' : 0.2197 , 'cosine' : 0.8612 } 0.0 { 'sine' : 0.4037 , 'cosine' : 0.2671 } 0.0 { 'sine' : 1.8243 , 'cosine' : 1.8268 } 1.0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"AnomalySine"},{"location":"api/synth/AnomalySine/#anomalysine","text":"Simulate a stream with anomalies in sine waves The data generated corresponds to sine ( attribute 1 ) and cosine ( attribute 2 ) functions. Anomalies are induced by replacing values from attribute 2 with values from a sine function different to the one used in attribute 1 . The contextual flag can be used to introduce contextual anomalies which are values in the normal global range, but abnormal compared to the seasonal pattern. Contextual attributes are introduced by replacing values in attribute 2 with values from attribute 1 .","title":"AnomalySine"},{"location":"api/synth/AnomalySine/#parameters","text":"n_samples ( int ) \u2013 defaults to 10000 Number of samples n_anomalies ( int ) \u2013 defaults to 2500 Number of anomalies. Can't be larger than n_samples . contextual ( bool ) \u2013 defaults to False If True, will add contextual anomalies n_contextual ( int ) \u2013 defaults to 2500 Number of contextual anomalies. Can't be larger than n_samples . shift ( int ) \u2013 defaults to 4 Shift in number of samples applied when retrieving contextual anomalies noise ( float ) \u2013 defaults to 0.5 Amount of noise replace ( bool ) \u2013 defaults to True If True, anomalies are randomly sampled with replacement seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random .","title":"Parameters"},{"location":"api/synth/AnomalySine/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/AnomalySine/#examples","text":">>> from river import synth >>> dataset = synth . AnomalySine ( seed = 12345 , ... n_samples = 100 , ... n_anomalies = 25 , ... contextual = True , ... n_contextual = 10 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'sine' : - 0.1023 , 'cosine' : 0.2171 } 0.0 { 'sine' : 0.4868 , 'cosine' : 0.6876 } 0.0 { 'sine' : 0.2197 , 'cosine' : 0.8612 } 0.0 { 'sine' : 0.4037 , 'cosine' : 0.2671 } 0.0 { 'sine' : 1.8243 , 'cosine' : 1.8268 } 1.0","title":"Examples"},{"location":"api/synth/AnomalySine/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/ConceptDriftStream/","text":"ConceptDriftStream \u00b6 Generates a stream with concept drift. A stream generator that adds concept drift or change by joining two streams. This is done by building a weighted combination of two pure distributions that characterizes the target concepts before and after the change. The sigmoid function is an elegant and practical solution to define the probability that each new instance of the stream belongs to the new concept after the drift. The sigmoid function introduces a gradual, smooth transition whose duration is controlled with two parameters: \\(p\\) , the position of the change. \\(w\\) , the width of the transition. The sigmoid function at sample \\(t\\) is \\[f(t) = 1/(1+e^{-4(t-p)/w})\\] Parameters \u00b6 stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Original stream drift_stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Drift stream position ( int ) \u2013 defaults to 5000 Central position of the concept drift change. width ( int ) \u2013 defaults to 1000 Width of concept drift change. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . alpha ( float ) \u2013 defaults to None Angle of change used to estimate the width of concept drift change. If set, it will override the width parameter. Valid values are in the range (0.0, 90.0]. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 5 , width = 2 ) >>> for x , y in dataset . take ( 10 ): ... print ( x , y ) { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 0.2979 , 1 : 2.1863 , 2 : 5.0535 } False { 0 : 0.2653 , 1 : 1.9883 , 2 : 6.4988 } False { 0 : 5.4494 , 1 : 2.2044 , 2 : 5.8926 } False { 0 : 8.0943 , 1 : 0.0649 , 2 : 8.0581 } False Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An optional way to estimate the width of the transition \\(w\\) is based on the angle \\(\u0007lpha\\) , \\(w = 1/ tan(\u0007lpha)\\) . Since width corresponds to the number of samples for the transition, the width is rounded to the nearest smaller integer. Notice that larger values of \\(\u0007lpha\\) result in smaller widths. For \\(\u0007lpha > 45.0\\) , the width is smaller than 1 so values are rounded to 1 to avoid division by zero errors.","title":"ConceptDriftStream"},{"location":"api/synth/ConceptDriftStream/#conceptdriftstream","text":"Generates a stream with concept drift. A stream generator that adds concept drift or change by joining two streams. This is done by building a weighted combination of two pure distributions that characterizes the target concepts before and after the change. The sigmoid function is an elegant and practical solution to define the probability that each new instance of the stream belongs to the new concept after the drift. The sigmoid function introduces a gradual, smooth transition whose duration is controlled with two parameters: \\(p\\) , the position of the change. \\(w\\) , the width of the transition. The sigmoid function at sample \\(t\\) is \\[f(t) = 1/(1+e^{-4(t-p)/w})\\]","title":"ConceptDriftStream"},{"location":"api/synth/ConceptDriftStream/#parameters","text":"stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Original stream drift_stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Drift stream position ( int ) \u2013 defaults to 5000 Central position of the concept drift change. width ( int ) \u2013 defaults to 1000 Width of concept drift change. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . alpha ( float ) \u2013 defaults to None Angle of change used to estimate the width of concept drift change. If set, it will override the width parameter. Valid values are in the range (0.0, 90.0].","title":"Parameters"},{"location":"api/synth/ConceptDriftStream/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/ConceptDriftStream/#examples","text":">>> from river import synth >>> dataset = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 5 , width = 2 ) >>> for x , y in dataset . take ( 10 ): ... print ( x , y ) { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 0.2979 , 1 : 2.1863 , 2 : 5.0535 } False { 0 : 0.2653 , 1 : 1.9883 , 2 : 6.4988 } False { 0 : 5.4494 , 1 : 2.2044 , 2 : 5.8926 } False { 0 : 8.0943 , 1 : 0.0649 , 2 : 8.0581 } False","title":"Examples"},{"location":"api/synth/ConceptDriftStream/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/ConceptDriftStream/#notes","text":"An optional way to estimate the width of the transition \\(w\\) is based on the angle \\(\u0007lpha\\) , \\(w = 1/ tan(\u0007lpha)\\) . Since width corresponds to the number of samples for the transition, the width is rounded to the nearest smaller integer. Notice that larger values of \\(\u0007lpha\\) result in smaller widths. For \\(\u0007lpha > 45.0\\) , the width is smaller than 1 so values are rounded to 1 to avoid division by zero errors.","title":"Notes"},{"location":"api/synth/Friedman/","text":"Friedman \u00b6 Friedman synthetic dataset. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. The target is defined by the following function: \\[y = 10 sin(\\pi x_0 x_1) + 20 (x_2 - 0.5)^2 + 10 x_3 + 5 x_4 + \\epsilon\\] In the last expression, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise. Therefore, only the first 5 features are relevant. Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Friedman ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Friedman, J.H., 1991. Multivariate adaptive regression splines. The annals of statistics, pp.1-67. \u21a9","title":"Friedman"},{"location":"api/synth/Friedman/#friedman","text":"Friedman synthetic dataset. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. The target is defined by the following function: \\[y = 10 sin(\\pi x_0 x_1) + 20 (x_2 - 0.5)^2 + 10 x_3 + 5 x_4 + \\epsilon\\] In the last expression, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise. Therefore, only the first 5 features are relevant.","title":"Friedman"},{"location":"api/synth/Friedman/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/Friedman/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Friedman/#examples","text":">>> from river import synth >>> dataset = synth . Friedman ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90","title":"Examples"},{"location":"api/synth/Friedman/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Friedman/#references","text":"Friedman, J.H., 1991. Multivariate adaptive regression splines. The annals of statistics, pp.1-67. \u21a9","title":"References"},{"location":"api/synth/FriedmanDrift/","text":"FriedmanDrift \u00b6 Friedman synthetic dataset with concept drifts. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. Only the first 5 features are relevant. The target is defined by different functions depending on the type of the drift. The three available modes of operation of the data generator are described in 1 . Parameters \u00b6 drift_type ( str ) \u2013 defaults to lea The variant of concept drift. - 'lea' : Local Expanding Abrupt drift. The concept drift appears in two distinct regions of the instance space, while the remaining regions are left unaltered. There are three points of abrupt change in the training dataset. At every consecutive change the regions of drift are expanded. - 'gra' : Global Recurring Abrupt drift. The concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs. - 'gsg' : Global and Slow Gradual drift. The concept drift affects all the instance space. However, the change is gradual and not abrupt. After each one of the two change points covered by this variant, and during a window of length transition_window , examples from both old and the new concepts are generated with equal probability. After the transition period, only the examples from the new concept are generated. position ( Tuple[int, ...] ) \u2013 defaults to (50000, 100000, 150000) The amount of monitored instances after which each concept drift occurs. A tuple with at least two element must be passed, where each number is greater than the preceding one. If drift_type='lea' , then the tuple must have three elements. transition_window ( int ) \u2013 defaults to 10000 The length of the transition window between two concepts. Only applicable when drift_type='gsg' . If set to zero, the drifts will be abrupt. Anytime transition_window > 0 , it defines a window in which instances of the new concept are gradually introduced among the examples from the old concept. During this transition phase, both old and new concepts appear with equal probability. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . FriedmanDrift ( ... drift_type = 'lea' , ... position = ( 1 , 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] - 2.65 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gra' , ... position = ( 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.96 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gsg' , ... position = ( 1 , 4 ), ... transition_window = 2 , ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.92 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 17.32 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 6.05 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Ikonomovska, E., Gama, J. and D\u017eeroski, S., 2011. Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), pp.128-168. \u21a9","title":"FriedmanDrift"},{"location":"api/synth/FriedmanDrift/#friedmandrift","text":"Friedman synthetic dataset with concept drifts. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. Only the first 5 features are relevant. The target is defined by different functions depending on the type of the drift. The three available modes of operation of the data generator are described in 1 .","title":"FriedmanDrift"},{"location":"api/synth/FriedmanDrift/#parameters","text":"drift_type ( str ) \u2013 defaults to lea The variant of concept drift. - 'lea' : Local Expanding Abrupt drift. The concept drift appears in two distinct regions of the instance space, while the remaining regions are left unaltered. There are three points of abrupt change in the training dataset. At every consecutive change the regions of drift are expanded. - 'gra' : Global Recurring Abrupt drift. The concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs. - 'gsg' : Global and Slow Gradual drift. The concept drift affects all the instance space. However, the change is gradual and not abrupt. After each one of the two change points covered by this variant, and during a window of length transition_window , examples from both old and the new concepts are generated with equal probability. After the transition period, only the examples from the new concept are generated. position ( Tuple[int, ...] ) \u2013 defaults to (50000, 100000, 150000) The amount of monitored instances after which each concept drift occurs. A tuple with at least two element must be passed, where each number is greater than the preceding one. If drift_type='lea' , then the tuple must have three elements. transition_window ( int ) \u2013 defaults to 10000 The length of the transition window between two concepts. Only applicable when drift_type='gsg' . If set to zero, the drifts will be abrupt. Anytime transition_window > 0 , it defines a window in which instances of the new concept are gradually introduced among the examples from the old concept. During this transition phase, both old and new concepts appear with equal probability. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/FriedmanDrift/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/FriedmanDrift/#examples","text":">>> from river import synth >>> dataset = synth . FriedmanDrift ( ... drift_type = 'lea' , ... position = ( 1 , 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] - 2.65 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gra' , ... position = ( 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.96 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gsg' , ... position = ( 1 , 4 ), ... transition_window = 2 , ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.92 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 17.32 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 6.05","title":"Examples"},{"location":"api/synth/FriedmanDrift/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/FriedmanDrift/#references","text":"Ikonomovska, E., Gama, J. and D\u017eeroski, S., 2011. Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), pp.128-168. \u21a9","title":"References"},{"location":"api/synth/Hyperplane/","text":"Hyperplane \u00b6 Hyperplane stream generator. Generates a problem of prediction class of a rotation hyperplane. It was used as testbed for CVFDT and VFDT in 1 . A hyperplane in d-dimensional space is the set of points \\(x\\) that satisfy \\[\\sum^{d}_{i=1} w_i x_i = w_0 = \\sum^{d}_{i=1} w_i\\] where \\(x_i\\) is the i-th coordinate of \\(x\\) . Examples for which \\(\\sum^{d}_{i=1} w_i x_i > w_0\\) , are labeled positive. Examples for which \\(\\sum^{d}_{i=1} w_i x_i \\leq w_0\\) , are labeled negative. Hyperplanes are useful for simulating time-changing concepts because we can change the orientation and position of the hyperplane in a smooth manner by changing the relative size of the weights. We introduce change to this dataset by adding drift to each weighted feature \\(w_i = w_i + d \\sigma\\) , where \\(\\sigma\\) is the probability that the direction of change is reversed and \\(d\\) is the change applied to each example. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_features ( int ) \u2013 defaults to 10 The number of attributes to generate. Higher than 2. n_drift_features ( int ) \u2013 defaults to 2 The number of attributes with drift. Higher than 2. mag_change ( float ) \u2013 defaults to 0.0 Magnitude of the change for every example. From 0.0 to 1.0. noise_percentage ( float ) \u2013 defaults to 0.05 Percentage of noise to add to the data. From 0.0 to 1.0. sigma ( float ) \u2013 defaults to 0.1 Probability that the direction of change is reversed. From 0.0 to 1.0. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Hyperplane ( seed = 42 , n_features = 2 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.7319 , 1 : 0.5986 } 1 { 0 : 0.8661 , 1 : 0.6011 } 1 { 0 : 0.8324 , 1 : 0.2123 } 0 { 0 : 0.5247 , 1 : 0.4319 } 0 { 0 : 0.2921 , 1 : 0.3663 } 0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The features are generated with the random number generator, initialized with the seed passed by the user. Then the classification function decides, as a function of the sum of the weighted features and the sum of the weights, whether the instance belongs to class 0 or class 1. The last step is to add noise and generate drift. References \u00b6 G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9","title":"Hyperplane"},{"location":"api/synth/Hyperplane/#hyperplane","text":"Hyperplane stream generator. Generates a problem of prediction class of a rotation hyperplane. It was used as testbed for CVFDT and VFDT in 1 . A hyperplane in d-dimensional space is the set of points \\(x\\) that satisfy \\[\\sum^{d}_{i=1} w_i x_i = w_0 = \\sum^{d}_{i=1} w_i\\] where \\(x_i\\) is the i-th coordinate of \\(x\\) . Examples for which \\(\\sum^{d}_{i=1} w_i x_i > w_0\\) , are labeled positive. Examples for which \\(\\sum^{d}_{i=1} w_i x_i \\leq w_0\\) , are labeled negative. Hyperplanes are useful for simulating time-changing concepts because we can change the orientation and position of the hyperplane in a smooth manner by changing the relative size of the weights. We introduce change to this dataset by adding drift to each weighted feature \\(w_i = w_i + d \\sigma\\) , where \\(\\sigma\\) is the probability that the direction of change is reversed and \\(d\\) is the change applied to each example.","title":"Hyperplane"},{"location":"api/synth/Hyperplane/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_features ( int ) \u2013 defaults to 10 The number of attributes to generate. Higher than 2. n_drift_features ( int ) \u2013 defaults to 2 The number of attributes with drift. Higher than 2. mag_change ( float ) \u2013 defaults to 0.0 Magnitude of the change for every example. From 0.0 to 1.0. noise_percentage ( float ) \u2013 defaults to 0.05 Percentage of noise to add to the data. From 0.0 to 1.0. sigma ( float ) \u2013 defaults to 0.1 Probability that the direction of change is reversed. From 0.0 to 1.0.","title":"Parameters"},{"location":"api/synth/Hyperplane/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Hyperplane/#examples","text":">>> from river import synth >>> dataset = synth . Hyperplane ( seed = 42 , n_features = 2 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.7319 , 1 : 0.5986 } 1 { 0 : 0.8661 , 1 : 0.6011 } 1 { 0 : 0.8324 , 1 : 0.2123 } 0 { 0 : 0.5247 , 1 : 0.4319 } 0 { 0 : 0.2921 , 1 : 0.3663 } 0","title":"Examples"},{"location":"api/synth/Hyperplane/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Hyperplane/#notes","text":"The sample generation works as follows: The features are generated with the random number generator, initialized with the seed passed by the user. Then the classification function decides, as a function of the sum of the weighted features and the sum of the weights, whether the instance belongs to class 0 or class 1. The last step is to add noise and generate drift.","title":"Notes"},{"location":"api/synth/Hyperplane/#references","text":"G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9","title":"References"},{"location":"api/synth/LED/","text":"LED \u00b6 LED stream generator. This data source originates from the CART book 1 . An implementation in C was donated to the UCI 2 machine learning repository by David Aha. The goal is to predict the digit displayed on a seven-segment LED display, where each attribute has a 10% chance of being inverted. It has an optimal Bayes classification rate of 74%. The particular configuration of the generator used for experiments (LED) produces 24 binary attributes, 17 of which are irrelevant. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . LED ( seed = 112 , noise_percentage = 0.28 , irrelevant_features = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 0 , 1 : 1 , 2 : 0 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 1 , 1 : 0 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 1 } 3 { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 0 , 4 : 0 , 5 : 1 , 6 : 1 } 0 { 0 : 1 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 1 , 6 : 0 } 4 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes. References \u00b6 Leo Breiman, Jerome Friedman, R. Olshen, and Charles J. Stone. Classification and Regression Trees. Wadsworth and Brooks, Monterey, CA,1984. \u21a9 A. Asuncion and D. J. Newman. UCI Machine Learning Repository [http://www.ics.uci.edu/\u223cmlearn/mlrepository.html]. University of California, Irvine, School of Information and Computer Sciences,2007. \u21a9","title":"LED"},{"location":"api/synth/LED/#led","text":"LED stream generator. This data source originates from the CART book 1 . An implementation in C was donated to the UCI 2 machine learning repository by David Aha. The goal is to predict the digit displayed on a seven-segment LED display, where each attribute has a 10% chance of being inverted. It has an optimal Bayes classification rate of 74%. The particular configuration of the generator used for experiments (LED) produces 24 binary attributes, 17 of which are irrelevant.","title":"LED"},{"location":"api/synth/LED/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream.","title":"Parameters"},{"location":"api/synth/LED/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/LED/#examples","text":">>> from river import synth >>> dataset = synth . LED ( seed = 112 , noise_percentage = 0.28 , irrelevant_features = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 0 , 1 : 1 , 2 : 0 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 1 , 1 : 0 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 1 } 3 { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 0 , 4 : 0 , 5 : 1 , 6 : 1 } 0 { 0 : 1 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 1 , 6 : 0 } 4","title":"Examples"},{"location":"api/synth/LED/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/LED/#notes","text":"An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes.","title":"Notes"},{"location":"api/synth/LED/#references","text":"Leo Breiman, Jerome Friedman, R. Olshen, and Charles J. Stone. Classification and Regression Trees. Wadsworth and Brooks, Monterey, CA,1984. \u21a9 A. Asuncion and D. J. Newman. UCI Machine Learning Repository [http://www.ics.uci.edu/\u223cmlearn/mlrepository.html]. University of California, Irvine, School of Information and Computer Sciences,2007. \u21a9","title":"References"},{"location":"api/synth/LEDDrift/","text":"LEDDrift \u00b6 LED stream generator with concept drift. This class is an extension of the LED generator whose purpose is to add concept drift to the stream. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream. n_drift_features ( int ) \u2013 defaults to 0 The number of attributes that have drift. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . LEDDrift ( seed = 112 , noise_percentage = 0.28 , ... irrelevant_features = True , n_drift_features = 4 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ] 8 [ 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 5 [ 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 ] 8 [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 ] 3 [ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 ] 5 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes.","title":"LEDDrift"},{"location":"api/synth/LEDDrift/#leddrift","text":"LED stream generator with concept drift. This class is an extension of the LED generator whose purpose is to add concept drift to the stream.","title":"LEDDrift"},{"location":"api/synth/LEDDrift/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream. n_drift_features ( int ) \u2013 defaults to 0 The number of attributes that have drift.","title":"Parameters"},{"location":"api/synth/LEDDrift/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/LEDDrift/#examples","text":">>> from river import synth >>> dataset = synth . LEDDrift ( seed = 112 , noise_percentage = 0.28 , ... irrelevant_features = True , n_drift_features = 4 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ] 8 [ 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 5 [ 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 ] 8 [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 ] 3 [ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 ] 5","title":"Examples"},{"location":"api/synth/LEDDrift/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/LEDDrift/#notes","text":"An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes.","title":"Notes"},{"location":"api/synth/Logical/","text":"Logical \u00b6 Logical functions stream generator. Make a toy dataset with three labels that represent the logical functions: OR , XOR , AND (functions of the 2D input). Data is generated in 'tiles' which contain the complete set of logical operations results. The tiles are repeated n_tiles times. Optionally, the generated data can be shuffled. Parameters \u00b6 n_tiles ( int ) \u2013 defaults to 1 Number of tiles to generate. shuffle ( bool ) \u2013 defaults to True If set, generated data will be shuffled. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Logical ( n_tiles = 2 , shuffle = True , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 0 } { 'OR' : 0 , 'XOR' : 0 , 'AND' : 0 } { 'A' : 1 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 0 , 'AND' : 1 } { 'A' : 1 , 'B' : 0 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"Logical"},{"location":"api/synth/Logical/#logical","text":"Logical functions stream generator. Make a toy dataset with three labels that represent the logical functions: OR , XOR , AND (functions of the 2D input). Data is generated in 'tiles' which contain the complete set of logical operations results. The tiles are repeated n_tiles times. Optionally, the generated data can be shuffled.","title":"Logical"},{"location":"api/synth/Logical/#parameters","text":"n_tiles ( int ) \u2013 defaults to 1 Number of tiles to generate. shuffle ( bool ) \u2013 defaults to True If set, generated data will be shuffled. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random .","title":"Parameters"},{"location":"api/synth/Logical/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Logical/#examples","text":">>> from river import synth >>> dataset = synth . Logical ( n_tiles = 2 , shuffle = True , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 0 } { 'OR' : 0 , 'XOR' : 0 , 'AND' : 0 } { 'A' : 1 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 0 , 'AND' : 1 } { 'A' : 1 , 'B' : 0 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 }","title":"Examples"},{"location":"api/synth/Logical/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Mixed/","text":"Mixed \u00b6 Mixed data stream generator. This generator is an implementation of a data stream with abrupt concept drift and boolean noise-free examples as described in 1 . It has four relevant attributes, two boolean attributes \\(v, w\\) and two numeric attributes \\(x, y\\) uniformly distributed from 0 to 1. The examples are labeled depending on the classification function chosen from below. function 0 : if \\(v\\) and \\(w\\) are true or \\(v\\) and \\(z\\) are true or \\(w\\) and \\(z\\) are true then 0 else 1, where \\(z\\) is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) function 1 : The opposite of function 0 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 Which of the two classification functions to use for the generation. Valid options are 0 or 1. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to a uniform distribution. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> >>> dataset = synth . Mixed ( seed = 42 , classification_function = 1 , balance_classes = True ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : False , 1 : True , 2 : 0.7319 , 3 : 0.5986 } 1 { 0 : False , 1 : False , 2 : 0.0580 , 3 : 0.8661 } 0 { 0 : True , 1 : True , 2 : 0.0205 , 3 : 0.9699 } 1 { 0 : False , 1 : True , 2 : 0.4319 , 3 : 0.2912 } 0 { 0 : True , 1 : False , 2 : 0.2921 , 3 : 0.3663 } 1 Methods \u00b6 generate_drift Generate drift by switching the classification function. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The two numeric attributes are generated with the random generator initialized with the seed passed by the user (optional). The boolean attributes are either 0 or 1 based on the comparison of the random number generator and 0.5 , the classification function decides whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. The generated sample will have 4 relevant features and 1 label (it is a binary-classification task). References \u00b6 Gama, Joao, et al. \"Learning with drift detection.\" Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295\" \u21a9","title":"Mixed"},{"location":"api/synth/Mixed/#mixed","text":"Mixed data stream generator. This generator is an implementation of a data stream with abrupt concept drift and boolean noise-free examples as described in 1 . It has four relevant attributes, two boolean attributes \\(v, w\\) and two numeric attributes \\(x, y\\) uniformly distributed from 0 to 1. The examples are labeled depending on the classification function chosen from below. function 0 : if \\(v\\) and \\(w\\) are true or \\(v\\) and \\(z\\) are true or \\(w\\) and \\(z\\) are true then 0 else 1, where \\(z\\) is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) function 1 : The opposite of function 0 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream .","title":"Mixed"},{"location":"api/synth/Mixed/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 Which of the two classification functions to use for the generation. Valid options are 0 or 1. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to a uniform distribution.","title":"Parameters"},{"location":"api/synth/Mixed/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Mixed/#examples","text":">>> from river import synth >>> >>> dataset = synth . Mixed ( seed = 42 , classification_function = 1 , balance_classes = True ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : False , 1 : True , 2 : 0.7319 , 3 : 0.5986 } 1 { 0 : False , 1 : False , 2 : 0.0580 , 3 : 0.8661 } 0 { 0 : True , 1 : True , 2 : 0.0205 , 3 : 0.9699 } 1 { 0 : False , 1 : True , 2 : 0.4319 , 3 : 0.2912 } 0 { 0 : True , 1 : False , 2 : 0.2921 , 3 : 0.3663 } 1","title":"Examples"},{"location":"api/synth/Mixed/#methods","text":"generate_drift Generate drift by switching the classification function. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Mixed/#notes","text":"The sample generation works as follows: The two numeric attributes are generated with the random generator initialized with the seed passed by the user (optional). The boolean attributes are either 0 or 1 based on the comparison of the random number generator and 0.5 , the classification function decides whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. The generated sample will have 4 relevant features and 1 label (it is a binary-classification task).","title":"Notes"},{"location":"api/synth/Mixed/#references","text":"Gama, Joao, et al. \"Learning with drift detection.\" Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295\" \u21a9","title":"References"},{"location":"api/synth/Mv/","text":"Mv \u00b6 Mv artificial dataset. Artificial dataset composed of both nominal and numeric features, whose features present co-dependencies. Originally described in 1 . The features are generated using the following expressions: \\(x_1\\) : uniformly distributed over [-5, 5] . \\(x_2\\) : uniformly distributed over [-15, -10] . \\(x_3\\) : if \\(x_1 > 0\\) , \\(x_3 \\leftarrow\\) 'green' else \\(x_3 \\leftarrow\\) 'red' with probability \\(0.4\\) and \\(x_3 \\leftarrow\\) 'brown' with probability \\(0.6\\) . \\(x_4\\) : if \\(x_3 =\\) 'green' , \\(x_4 \\leftarrow x_1 + 2 x_2\\) else \\(x_4 = \\frac{x_1}{2}\\) with probability \\(0.3\\) and \\(x_4 = \\frac{x_2}{2}\\) with probability \\(0.7\\) . \\(x_5\\) : uniformly distributed over [-1, 1] . \\(x_6 \\leftarrow x_4 \\times \\epsilon\\) , where \\(\\epsilon\\) is uniformly distributed over [0, 5] . \\(x_7\\) : 'yes' with probability \\(0.3\\) , and 'no' with probability \\(0.7\\) . \\(x_8\\) : 'normal' if \\(x_5 < 0.5\\) else 'large' . \\(x_9\\) : uniformly distributed over [100, 500] . \\(x_{10}\\) : uniformly distributed integer over the interval [1000, 1200] . The target value is generated using the following rules: if \\(x_2 > 2\\) , \\(y \\leftarrow 35 - 0.5 x_4\\) else if \\(-2 \\le x_4 \\le 2\\) , \\(y \\leftarrow 10 - 2 x_1\\) else if \\(x_7 =\\) 'yes' , \\(y \\leftarrow 3 - \\frac{x_1}{x_4}\\) else if \\(x_8 =\\) 'normal' , \\(y \\leftarrow x_6 + x_1\\) else \\(y \\leftarrow \\frac{x_1}{2}\\) . Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Mv ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1.39 , - 14.87 , 'green' , - 28.35 , - 0.44 , - 31.64 , 'no' , 'normal' , 370.67 , 1178.43 ] - 30.25 [ - 4.13 , - 12.89 , 'red' , - 2.06 , 0.01 , - 0.27 , 'yes' , 'normal' , 359.95 , 1108.98 ] 1.00 [ - 2.79 , - 12.05 , 'brown' , - 1.39 , 0.61 , - 4.87 , 'no' , 'large' , 162.19 , 1191.44 ] 15.59 [ - 1.63 , - 14.53 , 'red' , - 7.26 , 0.20 , - 29.33 , 'no' , 'normal' , 314.49 , 1194.62 ] - 30.96 [ - 1.21 , - 12.23 , 'brown' , - 6.11 , 0.72 , - 17.66 , 'no' , 'large' , 118.32 , 1045.57 ] - 0.60 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Mv in Lu\u00eds Torgo regression datasets \u21a9","title":"Mv"},{"location":"api/synth/Mv/#mv","text":"Mv artificial dataset. Artificial dataset composed of both nominal and numeric features, whose features present co-dependencies. Originally described in 1 . The features are generated using the following expressions: \\(x_1\\) : uniformly distributed over [-5, 5] . \\(x_2\\) : uniformly distributed over [-15, -10] . \\(x_3\\) : if \\(x_1 > 0\\) , \\(x_3 \\leftarrow\\) 'green' else \\(x_3 \\leftarrow\\) 'red' with probability \\(0.4\\) and \\(x_3 \\leftarrow\\) 'brown' with probability \\(0.6\\) . \\(x_4\\) : if \\(x_3 =\\) 'green' , \\(x_4 \\leftarrow x_1 + 2 x_2\\) else \\(x_4 = \\frac{x_1}{2}\\) with probability \\(0.3\\) and \\(x_4 = \\frac{x_2}{2}\\) with probability \\(0.7\\) . \\(x_5\\) : uniformly distributed over [-1, 1] . \\(x_6 \\leftarrow x_4 \\times \\epsilon\\) , where \\(\\epsilon\\) is uniformly distributed over [0, 5] . \\(x_7\\) : 'yes' with probability \\(0.3\\) , and 'no' with probability \\(0.7\\) . \\(x_8\\) : 'normal' if \\(x_5 < 0.5\\) else 'large' . \\(x_9\\) : uniformly distributed over [100, 500] . \\(x_{10}\\) : uniformly distributed integer over the interval [1000, 1200] . The target value is generated using the following rules: if \\(x_2 > 2\\) , \\(y \\leftarrow 35 - 0.5 x_4\\) else if \\(-2 \\le x_4 \\le 2\\) , \\(y \\leftarrow 10 - 2 x_1\\) else if \\(x_7 =\\) 'yes' , \\(y \\leftarrow 3 - \\frac{x_1}{x_4}\\) else if \\(x_8 =\\) 'normal' , \\(y \\leftarrow x_6 + x_1\\) else \\(y \\leftarrow \\frac{x_1}{2}\\) .","title":"Mv"},{"location":"api/synth/Mv/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/Mv/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Mv/#examples","text":">>> from river import synth >>> dataset = synth . Mv ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1.39 , - 14.87 , 'green' , - 28.35 , - 0.44 , - 31.64 , 'no' , 'normal' , 370.67 , 1178.43 ] - 30.25 [ - 4.13 , - 12.89 , 'red' , - 2.06 , 0.01 , - 0.27 , 'yes' , 'normal' , 359.95 , 1108.98 ] 1.00 [ - 2.79 , - 12.05 , 'brown' , - 1.39 , 0.61 , - 4.87 , 'no' , 'large' , 162.19 , 1191.44 ] 15.59 [ - 1.63 , - 14.53 , 'red' , - 7.26 , 0.20 , - 29.33 , 'no' , 'normal' , 314.49 , 1194.62 ] - 30.96 [ - 1.21 , - 12.23 , 'brown' , - 6.11 , 0.72 , - 17.66 , 'no' , 'large' , 118.32 , 1045.57 ] - 0.60","title":"Examples"},{"location":"api/synth/Mv/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Mv/#references","text":"Mv in Lu\u00eds Torgo regression datasets \u21a9","title":"References"},{"location":"api/synth/Planes2D/","text":"Planes2D \u00b6 2D Planes synthetic dataset. This dataset is described in 1 and was adapted from 2 . The features are generated using the following probabilities: \\[P(x_1 = -1) = P(x_1 = 1) = \\frac{1}{2}\\] \\[P(x_m = -1) = P(x_m = 0) = P(x_m = 1) = \\frac{1}{3}, m=2,\\ldots, 10\\] The target value is defined by the following rule: \\[\\text{if}~x_1 = 1, y \\leftarrow 3 + 3x_2 + 2x_3 + x_4 + \\epsilon\\] \\[\\text{if}~x_1 = -1, y \\leftarrow -3 + 3x_5 + 2x_6 + x_7 + \\epsilon\\] In the expressions, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise. Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Planes2D ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ - 1 , - 1 , 1 , 0 , - 1 , - 1 , - 1 , 1 , - 1 , 1 ] - 9.07 [ 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 1 , 1 , - 1 , 1 ] - 4.25 [ - 1 , 1 , 1 , 1 , 1 , 0 , - 1 , 0 , 1 , 0 ] - 0.95 [ - 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , 0 , - 1 , - 1 ] - 6.10 [ 1 , - 1 , 0 , 0 , 1 , 0 , - 1 , 1 , 0 , 1 ] 1.60 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 2DPlanes in Lu\u00eds Torgo regression datasets \u21a9 Breiman, L., Friedman, J., Stone, C.J. and Olshen, R.A., 1984. Classification and regression trees. CRC press. \u21a9","title":"Planes2D"},{"location":"api/synth/Planes2D/#planes2d","text":"2D Planes synthetic dataset. This dataset is described in 1 and was adapted from 2 . The features are generated using the following probabilities: \\[P(x_1 = -1) = P(x_1 = 1) = \\frac{1}{2}\\] \\[P(x_m = -1) = P(x_m = 0) = P(x_m = 1) = \\frac{1}{3}, m=2,\\ldots, 10\\] The target value is defined by the following rule: \\[\\text{if}~x_1 = 1, y \\leftarrow 3 + 3x_2 + 2x_3 + x_4 + \\epsilon\\] \\[\\text{if}~x_1 = -1, y \\leftarrow -3 + 3x_5 + 2x_6 + x_7 + \\epsilon\\] In the expressions, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise.","title":"Planes2D"},{"location":"api/synth/Planes2D/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/Planes2D/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Planes2D/#examples","text":">>> from river import synth >>> dataset = synth . Planes2D ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ - 1 , - 1 , 1 , 0 , - 1 , - 1 , - 1 , 1 , - 1 , 1 ] - 9.07 [ 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 1 , 1 , - 1 , 1 ] - 4.25 [ - 1 , 1 , 1 , 1 , 1 , 0 , - 1 , 0 , 1 , 0 ] - 0.95 [ - 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , 0 , - 1 , - 1 ] - 6.10 [ 1 , - 1 , 0 , 0 , 1 , 0 , - 1 , 1 , 0 , 1 ] 1.60","title":"Examples"},{"location":"api/synth/Planes2D/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Planes2D/#references","text":"2DPlanes in Lu\u00eds Torgo regression datasets \u21a9 Breiman, L., Friedman, J., Stone, C.J. and Olshen, R.A., 1984. Classification and regression trees. CRC press. \u21a9","title":"References"},{"location":"api/synth/RandomRBF/","text":"RandomRBF \u00b6 Random Radial Basis Function generator. Produces a radial basis function stream. A number of centroids, having a random central position, a standard deviation, a class label and weight are generated. A new sample is created by choosing one of the centroids at random, taking into account their weights, and offsetting the attributes in a random direction from the centroid's center. The offset length is drawn from a Gaussian distribution. This process will create a normally distributed hypersphere of samples on the surrounds of each centroid. Parameters \u00b6 seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> >>> dataset = synth . RandomRBF ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.9518 , 1 : 0.5263 , 2 : 0.2509 , 3 : 0.4177 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : - 0.2640 , 1 : 0.2275 , 2 : 0.6286 , 3 : - 0.0532 } 2 { 0 : 0.9050 , 1 : 0.6443 , 2 : 0.1270 , 3 : 0.4520 } 2 { 0 : 0.1874 , 1 : 0.4348 , 2 : 0.9819 , 3 : - 0.0459 } 2 Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"RandomRBF"},{"location":"api/synth/RandomRBF/#randomrbf","text":"Random Radial Basis Function generator. Produces a radial basis function stream. A number of centroids, having a random central position, a standard deviation, a class label and weight are generated. A new sample is created by choosing one of the centroids at random, taking into account their weights, and offsetting the attributes in a random direction from the centroid's center. The offset length is drawn from a Gaussian distribution. This process will create a normally distributed hypersphere of samples on the surrounds of each centroid.","title":"RandomRBF"},{"location":"api/synth/RandomRBF/#parameters","text":"seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate.","title":"Parameters"},{"location":"api/synth/RandomRBF/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/RandomRBF/#examples","text":">>> from river import synth >>> >>> dataset = synth . RandomRBF ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.9518 , 1 : 0.5263 , 2 : 0.2509 , 3 : 0.4177 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : - 0.2640 , 1 : 0.2275 , 2 : 0.6286 , 3 : - 0.0532 } 2 { 0 : 0.9050 , 1 : 0.6443 , 2 : 0.1270 , 3 : 0.4520 } 2 { 0 : 0.1874 , 1 : 0.4348 , 2 : 0.9819 , 3 : - 0.0459 } 2","title":"Examples"},{"location":"api/synth/RandomRBF/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/RandomRBFDrift/","text":"RandomRBFDrift \u00b6 Random Radial Basis Function generator with concept drift. This class is an extension from the RandomRBF generator. Concept drift can be introduced in instances of this class. The drift is created by adding a \"speed\" to certain centroids. As the samples are generated each of the moving centroids' centers is changed by an amount determined by its speed. Parameters \u00b6 seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate. change_speed ( float ) \u2013 defaults to 0.0 The concept drift speed. n_drift_centroids ( int ) \u2013 defaults to 50 The number of centroids that will drift. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> >>> dataset = synth . RandomRBFDrift ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 , ... change_speed = 0.87 , n_drift_centroids = 10 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 1.1965 , 1 : 0.5729 , 2 : 0.8607 , 3 : 0.5888 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : 0.5362 , 1 : - 0.2867 , 2 : 0.0962 , 3 : 0.8974 } 2 { 0 : 1.1875 , 1 : 1.0385 , 2 : 0.8323 , 3 : - 0.0553 } 2 { 0 : 0.3256 , 1 : 0.9206 , 2 : 0.8595 , 3 : 0.5907 } 2 Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"RandomRBFDrift"},{"location":"api/synth/RandomRBFDrift/#randomrbfdrift","text":"Random Radial Basis Function generator with concept drift. This class is an extension from the RandomRBF generator. Concept drift can be introduced in instances of this class. The drift is created by adding a \"speed\" to certain centroids. As the samples are generated each of the moving centroids' centers is changed by an amount determined by its speed.","title":"RandomRBFDrift"},{"location":"api/synth/RandomRBFDrift/#parameters","text":"seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate. change_speed ( float ) \u2013 defaults to 0.0 The concept drift speed. n_drift_centroids ( int ) \u2013 defaults to 50 The number of centroids that will drift.","title":"Parameters"},{"location":"api/synth/RandomRBFDrift/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/RandomRBFDrift/#examples","text":">>> from river import synth >>> >>> dataset = synth . RandomRBFDrift ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 , ... change_speed = 0.87 , n_drift_centroids = 10 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 1.1965 , 1 : 0.5729 , 2 : 0.8607 , 3 : 0.5888 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : 0.5362 , 1 : - 0.2867 , 2 : 0.0962 , 3 : 0.8974 } 2 { 0 : 1.1875 , 1 : 1.0385 , 2 : 0.8323 , 3 : - 0.0553 } 2 { 0 : 0.3256 , 1 : 0.9206 , 2 : 0.8595 , 3 : 0.5907 } 2","title":"Examples"},{"location":"api/synth/RandomRBFDrift/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/RandomTree/","text":"RandomTree \u00b6 Random Tree generator. This generator is based on 1 . The generator creates a random tree by splitting features at random and setting labels at its leaves. The tree structure is composed of node objects, which can be either inner nodes or leaf nodes. The choice comes as a function of the parameters passed to its initializer. Since the concepts are generated and classified according to a tree structure, in theory, it should favor decision tree learners. Parameters \u00b6 seed_tree ( int ) \u2013 defaults to None Seed for random generation of tree. seed_sample ( int ) \u2013 defaults to None Seed for random generation of instances. n_classes ( int ) \u2013 defaults to 2 The number of classes to generate. n_num_features ( int ) \u2013 defaults to 5 The number of numerical features to generate. n_cat_features ( int ) \u2013 defaults to 5 The number of categorical features to generate. n_categories_per_feature ( int ) \u2013 defaults to 5 The number of values to generate per categorical feature. max_tree_depth ( int ) \u2013 defaults to 5 The maximum depth of the tree concept. first_leaf_level ( int ) \u2013 defaults to 3 The first level of the tree above max_tree_depth that can have leaves. fraction_leaves_per_level ( float ) \u2013 defaults to 0.15 The fraction of leaves per level from first_leaf_level onwards. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . RandomTree ( seed_tree = 42 , seed_sample = 42 , n_classes = 2 , ... n_num_features = 2 , n_cat_features = 2 , ... n_categories_per_feature = 2 , max_tree_depth = 6 , ... first_leaf_level = 3 , fraction_leaves_per_level = 0.15 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'x_num_0' : 0.3745 , 'x_num_1' : 0.9507 , 'x_cat_0' : 0 , 'x_cat_1' : 1 } 1 { 'x_num_0' : 0.5986 , 'x_num_1' : 0.1560 , 'x_cat_0' : 0 , 'x_cat_1' : 0 } 1 { 'x_num_0' : 0.0580 , 'x_num_1' : 0.8661 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.7080 , 'x_num_1' : 0.0205 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.8324 , 'x_num_1' : 0.2123 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Domingos, Pedro, and Geoff Hulten. \"Mining high-speed data streams.\" In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining, pp. 71-80. 2000. \u21a9","title":"RandomTree"},{"location":"api/synth/RandomTree/#randomtree","text":"Random Tree generator. This generator is based on 1 . The generator creates a random tree by splitting features at random and setting labels at its leaves. The tree structure is composed of node objects, which can be either inner nodes or leaf nodes. The choice comes as a function of the parameters passed to its initializer. Since the concepts are generated and classified according to a tree structure, in theory, it should favor decision tree learners.","title":"RandomTree"},{"location":"api/synth/RandomTree/#parameters","text":"seed_tree ( int ) \u2013 defaults to None Seed for random generation of tree. seed_sample ( int ) \u2013 defaults to None Seed for random generation of instances. n_classes ( int ) \u2013 defaults to 2 The number of classes to generate. n_num_features ( int ) \u2013 defaults to 5 The number of numerical features to generate. n_cat_features ( int ) \u2013 defaults to 5 The number of categorical features to generate. n_categories_per_feature ( int ) \u2013 defaults to 5 The number of values to generate per categorical feature. max_tree_depth ( int ) \u2013 defaults to 5 The maximum depth of the tree concept. first_leaf_level ( int ) \u2013 defaults to 3 The first level of the tree above max_tree_depth that can have leaves. fraction_leaves_per_level ( float ) \u2013 defaults to 0.15 The fraction of leaves per level from first_leaf_level onwards.","title":"Parameters"},{"location":"api/synth/RandomTree/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/RandomTree/#examples","text":">>> from river import synth >>> dataset = synth . RandomTree ( seed_tree = 42 , seed_sample = 42 , n_classes = 2 , ... n_num_features = 2 , n_cat_features = 2 , ... n_categories_per_feature = 2 , max_tree_depth = 6 , ... first_leaf_level = 3 , fraction_leaves_per_level = 0.15 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'x_num_0' : 0.3745 , 'x_num_1' : 0.9507 , 'x_cat_0' : 0 , 'x_cat_1' : 1 } 1 { 'x_num_0' : 0.5986 , 'x_num_1' : 0.1560 , 'x_cat_0' : 0 , 'x_cat_1' : 0 } 1 { 'x_num_0' : 0.0580 , 'x_num_1' : 0.8661 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.7080 , 'x_num_1' : 0.0205 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.8324 , 'x_num_1' : 0.2123 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0","title":"Examples"},{"location":"api/synth/RandomTree/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/RandomTree/#references","text":"Domingos, Pedro, and Geoff Hulten. \"Mining high-speed data streams.\" In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining, pp. 71-80. 2000. \u21a9","title":"References"},{"location":"api/synth/SEA/","text":"SEA \u00b6 SEA synthetic dataset. Implementation of the data stream with abrupt drift described in 1 . Each observation is composed of 3 features. Only the first two features are relevant. The target is binary, and is positive if the sum of the features exceeds a certain threshold. There are 4 thresholds to choose from. Concept drift can be introduced by switching the threshold anytime during the stream. Variant 0 : True if \\(att1 + att2 > 8\\) Variant 1 : True if \\(att1 + att2 > 9\\) Variant 2 : True if \\(att1 + att2 > 7\\) Variant 3 : True if \\(att1 + att2 > 9.5\\) Parameters \u00b6 variant \u2013 defaults to 0 Determines the classification function to use. Possible choices are 0, 1, 2, 3. noise \u2013 defaults to 0.0 Determines the amount of observations for which the target sign will be flipped. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . SEA ( variant = 0 , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 6.39426 , 1 : 0.25010 , 2 : 2.75029 } False { 0 : 2.23210 , 1 : 7.36471 , 2 : 6.76699 } True { 0 : 8.92179 , 1 : 0.86938 , 2 : 4.21921 } True { 0 : 0.29797 , 1 : 2.18637 , 2 : 5.05355 } False { 0 : 0.26535 , 1 : 1.98837 , 2 : 6.49884 } False Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 A Streaming Ensemble Algorithm (SEA) for Large-Scale Classification \u21a9","title":"SEA"},{"location":"api/synth/SEA/#sea","text":"SEA synthetic dataset. Implementation of the data stream with abrupt drift described in 1 . Each observation is composed of 3 features. Only the first two features are relevant. The target is binary, and is positive if the sum of the features exceeds a certain threshold. There are 4 thresholds to choose from. Concept drift can be introduced by switching the threshold anytime during the stream. Variant 0 : True if \\(att1 + att2 > 8\\) Variant 1 : True if \\(att1 + att2 > 9\\) Variant 2 : True if \\(att1 + att2 > 7\\) Variant 3 : True if \\(att1 + att2 > 9.5\\)","title":"SEA"},{"location":"api/synth/SEA/#parameters","text":"variant \u2013 defaults to 0 Determines the classification function to use. Possible choices are 0, 1, 2, 3. noise \u2013 defaults to 0.0 Determines the amount of observations for which the target sign will be flipped. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/SEA/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/SEA/#examples","text":">>> from river import synth >>> dataset = synth . SEA ( variant = 0 , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 6.39426 , 1 : 0.25010 , 2 : 2.75029 } False { 0 : 2.23210 , 1 : 7.36471 , 2 : 6.76699 } True { 0 : 8.92179 , 1 : 0.86938 , 2 : 4.21921 } True { 0 : 0.29797 , 1 : 2.18637 , 2 : 5.05355 } False { 0 : 0.26535 , 1 : 1.98837 , 2 : 6.49884 } False","title":"Examples"},{"location":"api/synth/SEA/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/SEA/#references","text":"A Streaming Ensemble Algorithm (SEA) for Large-Scale Classification \u21a9","title":"References"},{"location":"api/synth/STAGGER/","text":"STAGGER \u00b6 STAGGER concepts stream generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in 1 . The STAGGER concepts are boolean functions f with three features describing objects: size (small, medium and large), shape (circle, square and triangle) and colour (red, blue and green). f options: True if the size is small and the color is red. True if the color is green or the shape is a circle. True if the size is medium or large Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . One important feature is the possibility to balance classes, which means the class distribution will tend to a uniform one. Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 2. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . STAGGER ( classification_function = 2 , seed = 112 , ... balance_classes = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'size' : 0 , 'color' : 0 , 'shape' : 2 } 0 { 'size' : 1 , 'color' : 0 , 'shape' : 1 } 1 { 'size' : 0 , 'color' : 0 , 'shape' : 0 } 0 { 'size' : 1 , 'color' : 2 , 'shape' : 0 } 1 { 'size' : 1 , 'color' : 0 , 'shape' : 2 } 1 Methods \u00b6 generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The 3 attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced, if this option is set by the user. References \u00b6 Schlimmer, J. C., & Granger, R. H. (1986). Incremental learning from noisy data. Machine learning, 1(3), 317-354. \u21a9","title":"STAGGER"},{"location":"api/synth/STAGGER/#stagger","text":"STAGGER concepts stream generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in 1 . The STAGGER concepts are boolean functions f with three features describing objects: size (small, medium and large), shape (circle, square and triangle) and colour (red, blue and green). f options: True if the size is small and the color is red. True if the color is green or the shape is a circle. True if the size is medium or large Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . One important feature is the possibility to balance classes, which means the class distribution will tend to a uniform one.","title":"STAGGER"},{"location":"api/synth/STAGGER/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 2. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution.","title":"Parameters"},{"location":"api/synth/STAGGER/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/STAGGER/#examples","text":">>> from river import synth >>> dataset = synth . STAGGER ( classification_function = 2 , seed = 112 , ... balance_classes = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'size' : 0 , 'color' : 0 , 'shape' : 2 } 0 { 'size' : 1 , 'color' : 0 , 'shape' : 1 } 1 { 'size' : 0 , 'color' : 0 , 'shape' : 0 } 0 { 'size' : 1 , 'color' : 2 , 'shape' : 0 } 1 { 'size' : 1 , 'color' : 0 , 'shape' : 2 } 1","title":"Examples"},{"location":"api/synth/STAGGER/#methods","text":"generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/STAGGER/#notes","text":"The sample generation works as follows: The 3 attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced, if this option is set by the user.","title":"Notes"},{"location":"api/synth/STAGGER/#references","text":"Schlimmer, J. C., & Granger, R. H. (1986). Incremental learning from noisy data. Machine learning, 1(3), 317-354. \u21a9","title":"References"},{"location":"api/synth/Sine/","text":"Sine \u00b6 Sine generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in Gama, Joao, et al. 1 . It generates up to 4 relevant numerical features, that vary from 0 to 1, where only 2 of them are relevant to the classification task and the other 2 are optionally added by as noise. A classification function is chosen among four options: SINE1 . Abrupt concept drift, noise-free examples. It has two relevant attributes. Each attributes has values uniformly distributed in [0, 1]. In the first context all points below the curve \\(y = sin(x)\\) are classified as positive. Reversed SINE1 . The reversed classification of SINE1 . SINE2 . The same two relevant attributes. The classification function is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) . Reversed SINE2 . The reversed classification of SINE2 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . Two important features are the possibility to balance classes, which means the class distribution will tend to a uniform one, and the possibility to add noise, which will, add two non relevant attributes. Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 3. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution. has_noise ( bool ) \u2013 defaults to False Adds 2 non relevant features to the stream. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Sine ( classification_function = 2 , seed = 112 , ... balance_classes = False , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.3750 , 1 : 0.6403 , 2 : 0.9500 , 3 : 0.0756 } 1 { 0 : 0.7769 , 1 : 0.8327 , 2 : 0.0548 , 3 : 0.8176 } 1 { 0 : 0.8853 , 1 : 0.7223 , 2 : 0.0025 , 3 : 0.9811 } 0 { 0 : 0.3434 , 1 : 0.0947 , 2 : 0.3946 , 3 : 0.0049 } 1 { 0 : 0.7367 , 1 : 0.9558 , 2 : 0.8206 , 3 : 0.3449 } 0 Methods \u00b6 generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The two attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced and noise is added, if these options are set by the user. The generated sample will have 2 relevant features, and an additional two noise features if has_noise is set. References \u00b6 Gama, Joao, et al.'s 'Learning with drift detection.' Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295.\" \u21a9","title":"Sine"},{"location":"api/synth/Sine/#sine","text":"Sine generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in Gama, Joao, et al. 1 . It generates up to 4 relevant numerical features, that vary from 0 to 1, where only 2 of them are relevant to the classification task and the other 2 are optionally added by as noise. A classification function is chosen among four options: SINE1 . Abrupt concept drift, noise-free examples. It has two relevant attributes. Each attributes has values uniformly distributed in [0, 1]. In the first context all points below the curve \\(y = sin(x)\\) are classified as positive. Reversed SINE1 . The reversed classification of SINE1 . SINE2 . The same two relevant attributes. The classification function is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) . Reversed SINE2 . The reversed classification of SINE2 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . Two important features are the possibility to balance classes, which means the class distribution will tend to a uniform one, and the possibility to add noise, which will, add two non relevant attributes.","title":"Sine"},{"location":"api/synth/Sine/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 3. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution. has_noise ( bool ) \u2013 defaults to False Adds 2 non relevant features to the stream.","title":"Parameters"},{"location":"api/synth/Sine/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Sine/#examples","text":">>> from river import synth >>> dataset = synth . Sine ( classification_function = 2 , seed = 112 , ... balance_classes = False , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.3750 , 1 : 0.6403 , 2 : 0.9500 , 3 : 0.0756 } 1 { 0 : 0.7769 , 1 : 0.8327 , 2 : 0.0548 , 3 : 0.8176 } 1 { 0 : 0.8853 , 1 : 0.7223 , 2 : 0.0025 , 3 : 0.9811 } 0 { 0 : 0.3434 , 1 : 0.0947 , 2 : 0.3946 , 3 : 0.0049 } 1 { 0 : 0.7367 , 1 : 0.9558 , 2 : 0.8206 , 3 : 0.3449 } 0","title":"Examples"},{"location":"api/synth/Sine/#methods","text":"generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Sine/#notes","text":"The sample generation works as follows: The two attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced and noise is added, if these options are set by the user. The generated sample will have 2 relevant features, and an additional two noise features if has_noise is set.","title":"Notes"},{"location":"api/synth/Sine/#references","text":"Gama, Joao, et al.'s 'Learning with drift detection.' Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295.\" \u21a9","title":"References"},{"location":"api/synth/Waveform/","text":"Waveform \u00b6 Waveform stream generator. Generates samples with 21 numeric features and 3 classes, based on a random differentiation of some base waveforms. Supports noise addition, in this case the samples will have 40 features. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . has_noise ( bool ) \u2013 defaults to False Adds 19 unrelated features to the stream. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Waveform ( seed = 42 , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.5437 , - 0.6154 , - 1.1978 , 2.1417 , - 0.0946 , - 0.7254 , - 0.4783 , 0.1982 , 0.3312 , 1.9780 , 3.0469 , 3.5249 , 5.4624 , 6.1318 , 2.7471 , 4.7896 , 2.9351 , 2.2258 , 0.1168 , 2.2835 , - 0.0245 , 0.3556 , 0.4170 , 0.8325 , - 0.2934 , - 0.0298 , 0.0951 , 0.6647 , - 0.1402 , - 0.0332 , - 0.7491 , - 0.7784 , 0.9488 , 1.5809 , - 0.3682 , 0.3756 , - 1.1932 , - 0.4091 , - 0.4467 , 1.5242 ] 2 [ 0.2186 , 1.4285 , 0.0843 , 0.0568 , 2.9605 , 2.6487 , 2.8402 , 3.2128 , 2.8694 , 4.0410 , 4.3953 , 3.7009 , 2.7075 , 2.1149 , 0.6994 , - 0.1702 , - 1.5082 , 1.0996 , - 0.1777 , - 0.4104 , 1.1797 , - 0.8982 , 0.8348 , 0.2966 , - 1.0378 , - 0.0758 , 0.9730 , 0.7956 , 1.4954 , 0.3382 , 3.3723 , - 0.9204 , - 0.3986 , - 0.0609 , - 1.4188 , 1.0425 , 0.9035 , 0.0190 , - 0.5344 , - 1.4951 ] 1 [ 0.1358 , 0.6081 , 0.7050 , 0.3609 , - 1.4670 , 1.6896 , 1.4886 , 1.4355 , 2.7730 , 2.7890 , 4.8437 , 5.3447 , 3.6724 , 2.5445 , 2.5541 , 2.2732 , - 0.5371 , - 0.4099 , 0.5331 , - 1.0464 , 1.9451 , - 0.1533 , - 0.9070 , - 0.8174 , - 0.4831 , - 0.5698 , - 2.0916 , 1.2637 , - 0.0155 , - 0.0274 , 0.8179 , - 1.0546 , - 0.7583 , 0.4574 , - 0.0644 , 0.3449 , - 0.0801 , - 0.2414 , 1.4335 , 1.0658 ] 2 [ 1.1428 , 1.2414 , 1.7699 , 0.5590 , 3.3606 , 1.0454 , 3.5236 , 4.6377 , 0.9673 , 1.4126 , 2.0997 , 1.5176 , 0.4915 , 2.6213 , 2.0010 , 3.0263 , 1.1228 , 3.0816 , 0.2378 , 0.1885 , 0.8135 , - 1.2309 , 0.2275 , 1.3071 , - 1.6075 , 0.1846 , 0.2599 , 0.7818 , - 1.2370 , - 1.3205 , 0.5219 , 0.2970 , 0.2505 , 0.3464 , - 0.6800 , 0.2323 , 0.2931 , - 0.7144 , 1.8658 , 0.4738 ] 0 [ - 0.9747 , 1.0114 , 1.6071 , - 0.1479 , 1.8605 , 1.5341 , 2.1677 , 3.0181 , 0.6517 , 0.6948 , 1.1105 , 1.7357 , 3.0258 , 4.2198 , 4.9311 , 4.7058 , 3.1159 , 3.7807 , 1.2868 , 3.4959 , 0.6257 , - 0.8572 , - 1.0709 , 0.4825 , - 0.2235 , 0.7140 , 0.4732 , - 0.0728 , - 0.8468 , - 1.5148 , - 0.4465 , 0.8564 , 0.2141 , - 1.2457 , 0.1732 , 0.3853 , - 0.8839 , 0.1537 , 0.0582 , - 1.1430 ] 0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An instance is generated based on the parameters passed. The generator will randomly choose one of the hard coded waveforms, as well as random multipliers. For each feature, the actual value generated will be a a combination of the hard coded functions, with the multipliers and a random value. If noise is added then the features 21 to 40 will be replaced with a random normal value.","title":"Waveform"},{"location":"api/synth/Waveform/#waveform","text":"Waveform stream generator. Generates samples with 21 numeric features and 3 classes, based on a random differentiation of some base waveforms. Supports noise addition, in this case the samples will have 40 features.","title":"Waveform"},{"location":"api/synth/Waveform/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . has_noise ( bool ) \u2013 defaults to False Adds 19 unrelated features to the stream.","title":"Parameters"},{"location":"api/synth/Waveform/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Waveform/#examples","text":">>> from river import synth >>> dataset = synth . Waveform ( seed = 42 , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.5437 , - 0.6154 , - 1.1978 , 2.1417 , - 0.0946 , - 0.7254 , - 0.4783 , 0.1982 , 0.3312 , 1.9780 , 3.0469 , 3.5249 , 5.4624 , 6.1318 , 2.7471 , 4.7896 , 2.9351 , 2.2258 , 0.1168 , 2.2835 , - 0.0245 , 0.3556 , 0.4170 , 0.8325 , - 0.2934 , - 0.0298 , 0.0951 , 0.6647 , - 0.1402 , - 0.0332 , - 0.7491 , - 0.7784 , 0.9488 , 1.5809 , - 0.3682 , 0.3756 , - 1.1932 , - 0.4091 , - 0.4467 , 1.5242 ] 2 [ 0.2186 , 1.4285 , 0.0843 , 0.0568 , 2.9605 , 2.6487 , 2.8402 , 3.2128 , 2.8694 , 4.0410 , 4.3953 , 3.7009 , 2.7075 , 2.1149 , 0.6994 , - 0.1702 , - 1.5082 , 1.0996 , - 0.1777 , - 0.4104 , 1.1797 , - 0.8982 , 0.8348 , 0.2966 , - 1.0378 , - 0.0758 , 0.9730 , 0.7956 , 1.4954 , 0.3382 , 3.3723 , - 0.9204 , - 0.3986 , - 0.0609 , - 1.4188 , 1.0425 , 0.9035 , 0.0190 , - 0.5344 , - 1.4951 ] 1 [ 0.1358 , 0.6081 , 0.7050 , 0.3609 , - 1.4670 , 1.6896 , 1.4886 , 1.4355 , 2.7730 , 2.7890 , 4.8437 , 5.3447 , 3.6724 , 2.5445 , 2.5541 , 2.2732 , - 0.5371 , - 0.4099 , 0.5331 , - 1.0464 , 1.9451 , - 0.1533 , - 0.9070 , - 0.8174 , - 0.4831 , - 0.5698 , - 2.0916 , 1.2637 , - 0.0155 , - 0.0274 , 0.8179 , - 1.0546 , - 0.7583 , 0.4574 , - 0.0644 , 0.3449 , - 0.0801 , - 0.2414 , 1.4335 , 1.0658 ] 2 [ 1.1428 , 1.2414 , 1.7699 , 0.5590 , 3.3606 , 1.0454 , 3.5236 , 4.6377 , 0.9673 , 1.4126 , 2.0997 , 1.5176 , 0.4915 , 2.6213 , 2.0010 , 3.0263 , 1.1228 , 3.0816 , 0.2378 , 0.1885 , 0.8135 , - 1.2309 , 0.2275 , 1.3071 , - 1.6075 , 0.1846 , 0.2599 , 0.7818 , - 1.2370 , - 1.3205 , 0.5219 , 0.2970 , 0.2505 , 0.3464 , - 0.6800 , 0.2323 , 0.2931 , - 0.7144 , 1.8658 , 0.4738 ] 0 [ - 0.9747 , 1.0114 , 1.6071 , - 0.1479 , 1.8605 , 1.5341 , 2.1677 , 3.0181 , 0.6517 , 0.6948 , 1.1105 , 1.7357 , 3.0258 , 4.2198 , 4.9311 , 4.7058 , 3.1159 , 3.7807 , 1.2868 , 3.4959 , 0.6257 , - 0.8572 , - 1.0709 , 0.4825 , - 0.2235 , 0.7140 , 0.4732 , - 0.0728 , - 0.8468 , - 1.5148 , - 0.4465 , 0.8564 , 0.2141 , - 1.2457 , 0.1732 , 0.3853 , - 0.8839 , 0.1537 , 0.0582 , - 1.1430 ] 0","title":"Examples"},{"location":"api/synth/Waveform/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Waveform/#notes","text":"An instance is generated based on the parameters passed. The generator will randomly choose one of the hard coded waveforms, as well as random multipliers. For each feature, the actual value generated will be a a combination of the hard coded functions, with the multipliers and a random value. If noise is added then the features 21 to 40 will be replaced with a random normal value.","title":"Notes"},{"location":"api/time-series/Detrender/","text":"Detrender \u00b6 A linear detrender which centers the target in zero. At each learn_one step, the current mean of y is subtracted from y before being fed to the provided regression model. During the predict_one step, the current mean is added to the prediction of the regression model. Parameters \u00b6 regressor ( base.Regressor ) window_size ( int ) \u2013 defaults to None Window size used for calculating the rolling mean. If None , then a mean over the whole target data will instead be used. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Detrender"},{"location":"api/time-series/Detrender/#detrender","text":"A linear detrender which centers the target in zero. At each learn_one step, the current mean of y is subtracted from y before being fed to the provided regression model. During the predict_one step, the current mean is added to the prediction of the regression model.","title":"Detrender"},{"location":"api/time-series/Detrender/#parameters","text":"regressor ( base.Regressor ) window_size ( int ) \u2013 defaults to None Window size used for calculating the rolling mean. If None , then a mean over the whole target data will instead be used.","title":"Parameters"},{"location":"api/time-series/Detrender/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/time-series/GroupDetrender/","text":"GroupDetrender \u00b6 Removes the trend of the target inside each group. Parameters \u00b6 regressor ( base.Regressor ) by ( str ) window_size ( int ) \u2013 defaults to None Window size used for calculating each rolling mean. If None , then a mean over the whole target data will instead be used. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"GroupDetrender"},{"location":"api/time-series/GroupDetrender/#groupdetrender","text":"Removes the trend of the target inside each group.","title":"GroupDetrender"},{"location":"api/time-series/GroupDetrender/#parameters","text":"regressor ( base.Regressor ) by ( str ) window_size ( int ) \u2013 defaults to None Window size used for calculating each rolling mean. If None , then a mean over the whole target data will instead be used.","title":"Parameters"},{"location":"api/time-series/GroupDetrender/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/time-series/SNARIMAX/","text":"SNARIMAX \u00b6 SNARIMAX model. SNARIMAX stands for (S)easonal (N)on-linear (A)uto(R)egressive (I)ntegrated (M)oving-(A)verage with e(X)ogenous inputs model. This model generalizes many established time series models in a single interface that can be trained online. It assumes that the provided training data is ordered in time and is uniformly spaced. It is made up of the following components: S (Seasonal) - N (Non-linear): Any online regression model can be used, not necessarily a linear regression as is done in textbooks. - AR (Autoregressive): Lags of the target variable are used as features. - I (Integrated): The model can be fitted on a differenced version of a time series. In this context, integration is the reverse of differencing. - MA (Moving average): Lags of the errors are used as features. - X (Exogenous): Users can provide additional features. Care has to be taken to include features that will be available both at training and prediction time. Each of these components can be switched on and off by specifying the appropriate parameters. Classical time series models such as AR, MA, ARMA, and ARIMA can thus be seen as special parametrizations of the SNARIMAX model. This model is tailored for time series that are homoskedastic. In other words, it might not work well if the variance of the time series varies widely along time. Parameters \u00b6 p ( int ) Order of the autoregressive part. This is the number of past target values that will be included as features. d ( int ) Differencing order. q ( int ) Order of the moving average part. This is the number of past error terms that will be included as features. m ( int ) \u2013 defaults to 1 Season length used for extracting seasonal features. If you believe your data has a seasonal pattern, then set this accordingly. For instance, if the data seems to exhibit a yearly seasonality, and that your data is spaced by month, then you should set this to 12. Note that for this parameter to have any impact you should also set at least one of the p , d , and q parameters. sp ( int ) \u2013 defaults to 0 Seasonal order of the autoregressive part. This is the number of past target values that will be included as features. sd ( int ) \u2013 defaults to 0 Seasonal differencing order. sq ( int ) \u2013 defaults to 0 Seasonal order of the moving average part. This is the number of past error terms that will be included as features. regressor ( base.Regressor ) \u2013 defaults to None The online regression model to use. By default, a preprocessing.StandardScaler piped with a linear_model.LinearRegression will be used. Attributes \u00b6 differencer ( Differencer ) y_trues ( collections.deque ) The p past target values. errors ( collections.deque ) The q past error values. Examples \u00b6 >>> import calendar >>> import datetime as dt >>> from river import compose >>> from river import datasets >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import time_series >>> def get_month_distances ( x ): ... return { ... calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) ... for month in range ( 1 , 13 ) ... } >>> def get_ordinal_date ( x ): ... return { 'ordinal_date' : x [ 'month' ] . toordinal ()} >>> extract_features = compose . TransformerUnion ( ... get_ordinal_date , ... get_month_distances ... ) >>> model = ( ... extract_features | ... time_series . SNARIMAX ( ... p = 0 , ... d = 0 , ... q = 0 , ... m = 12 , ... sp = 3 , ... sq = 6 , ... regressor = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... intercept_init = 110 , ... optimizer = optim . SGD ( 0.01 ), ... intercept_lr = 0.3 ... ) ... ) ... ) ... ) >>> metric = metrics . Rolling ( metrics . MAE (), 12 ) >>> for x , y in datasets . AirlinePassengers (): ... y_pred = model . forecast ( horizon = 1 , xs = [ x ]) ... model = model . learn_one ( x , y ) ... metric = metric . update ( y , y_pred [ 0 ]) >>> metric Rolling of size 12 MAE : 11.636563 >>> horizon = 12 >>> future = [ ... { 'month' : dt . date ( year = 1961 , month = m , day = 1 )} ... for m in range ( 1 , horizon + 1 ) ... ] >>> forecast = model . forecast ( horizon = horizon , xs = future ) >>> for x , y_pred in zip ( future , forecast ): ... print ( x [ 'month' ], f ' { y_pred : .3f } ' ) 1961 - 01 - 01 442.554 1961 - 02 - 01 427.305 1961 - 03 - 01 471.861 1961 - 04 - 01 483.978 1961 - 05 - 01 489.995 1961 - 06 - 01 544.270 1961 - 07 - 01 632.882 1961 - 08 - 01 633.229 1961 - 09 - 01 531.349 1961 - 10 - 01 457.258 1961 - 11 - 01 405.978 1961 - 12 - 01 439.674 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None References \u00b6 Wikipedia page on ARMA \u21a9 Wikipedia page on NARX \u21a9 ARIMA models \u21a9 Anava, O., Hazan, E., Mannor, S. and Shamir, O., 2013, June. Online learning for time series prediction. In Conference on learning theory (pp. 172-184) \u21a9","title":"SNARIMAX"},{"location":"api/time-series/SNARIMAX/#snarimax","text":"SNARIMAX model. SNARIMAX stands for (S)easonal (N)on-linear (A)uto(R)egressive (I)ntegrated (M)oving-(A)verage with e(X)ogenous inputs model. This model generalizes many established time series models in a single interface that can be trained online. It assumes that the provided training data is ordered in time and is uniformly spaced. It is made up of the following components: S (Seasonal) - N (Non-linear): Any online regression model can be used, not necessarily a linear regression as is done in textbooks. - AR (Autoregressive): Lags of the target variable are used as features. - I (Integrated): The model can be fitted on a differenced version of a time series. In this context, integration is the reverse of differencing. - MA (Moving average): Lags of the errors are used as features. - X (Exogenous): Users can provide additional features. Care has to be taken to include features that will be available both at training and prediction time. Each of these components can be switched on and off by specifying the appropriate parameters. Classical time series models such as AR, MA, ARMA, and ARIMA can thus be seen as special parametrizations of the SNARIMAX model. This model is tailored for time series that are homoskedastic. In other words, it might not work well if the variance of the time series varies widely along time.","title":"SNARIMAX"},{"location":"api/time-series/SNARIMAX/#parameters","text":"p ( int ) Order of the autoregressive part. This is the number of past target values that will be included as features. d ( int ) Differencing order. q ( int ) Order of the moving average part. This is the number of past error terms that will be included as features. m ( int ) \u2013 defaults to 1 Season length used for extracting seasonal features. If you believe your data has a seasonal pattern, then set this accordingly. For instance, if the data seems to exhibit a yearly seasonality, and that your data is spaced by month, then you should set this to 12. Note that for this parameter to have any impact you should also set at least one of the p , d , and q parameters. sp ( int ) \u2013 defaults to 0 Seasonal order of the autoregressive part. This is the number of past target values that will be included as features. sd ( int ) \u2013 defaults to 0 Seasonal differencing order. sq ( int ) \u2013 defaults to 0 Seasonal order of the moving average part. This is the number of past error terms that will be included as features. regressor ( base.Regressor ) \u2013 defaults to None The online regression model to use. By default, a preprocessing.StandardScaler piped with a linear_model.LinearRegression will be used.","title":"Parameters"},{"location":"api/time-series/SNARIMAX/#attributes","text":"differencer ( Differencer ) y_trues ( collections.deque ) The p past target values. errors ( collections.deque ) The q past error values.","title":"Attributes"},{"location":"api/time-series/SNARIMAX/#examples","text":">>> import calendar >>> import datetime as dt >>> from river import compose >>> from river import datasets >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import time_series >>> def get_month_distances ( x ): ... return { ... calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) ... for month in range ( 1 , 13 ) ... } >>> def get_ordinal_date ( x ): ... return { 'ordinal_date' : x [ 'month' ] . toordinal ()} >>> extract_features = compose . TransformerUnion ( ... get_ordinal_date , ... get_month_distances ... ) >>> model = ( ... extract_features | ... time_series . SNARIMAX ( ... p = 0 , ... d = 0 , ... q = 0 , ... m = 12 , ... sp = 3 , ... sq = 6 , ... regressor = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... intercept_init = 110 , ... optimizer = optim . SGD ( 0.01 ), ... intercept_lr = 0.3 ... ) ... ) ... ) ... ) >>> metric = metrics . Rolling ( metrics . MAE (), 12 ) >>> for x , y in datasets . AirlinePassengers (): ... y_pred = model . forecast ( horizon = 1 , xs = [ x ]) ... model = model . learn_one ( x , y ) ... metric = metric . update ( y , y_pred [ 0 ]) >>> metric Rolling of size 12 MAE : 11.636563 >>> horizon = 12 >>> future = [ ... { 'month' : dt . date ( year = 1961 , month = m , day = 1 )} ... for m in range ( 1 , horizon + 1 ) ... ] >>> forecast = model . forecast ( horizon = horizon , xs = future ) >>> for x , y_pred in zip ( future , forecast ): ... print ( x [ 'month' ], f ' { y_pred : .3f } ' ) 1961 - 01 - 01 442.554 1961 - 02 - 01 427.305 1961 - 03 - 01 471.861 1961 - 04 - 01 483.978 1961 - 05 - 01 489.995 1961 - 06 - 01 544.270 1961 - 07 - 01 632.882 1961 - 08 - 01 633.229 1961 - 09 - 01 531.349 1961 - 10 - 01 457.258 1961 - 11 - 01 405.978 1961 - 12 - 01 439.674","title":"Examples"},{"location":"api/time-series/SNARIMAX/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/time-series/SNARIMAX/#references","text":"Wikipedia page on ARMA \u21a9 Wikipedia page on NARX \u21a9 ARIMA models \u21a9 Anava, O., Hazan, E., Mannor, S. and Shamir, O., 2013, June. Online learning for time series prediction. In Conference on learning theory (pp. 172-184) \u21a9","title":"References"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/","text":"ExtremelyFastDecisionTreeClassifier \u00b6 Extremely Fast Decision Tree classifier. Also referred to as Hoeffding AnyTime Tree (HATT) classifier. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. min_samples_reevaluate ( int ) \u2013 defaults to 20 Number of instances a node should observe before reevaluating the best split. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree. Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . ExtremelyFastDecisionTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ], ... min_samples_reevaluate = 100 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 89.09 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. Notes \u00b6 The Extremely Fast Decision Tree (EFDT) 1 constructs a tree incrementally. The EFDT seeks to select and deploy a split as soon as it is confident the split is useful, and then revisits that decision, replacing the split if it subsequently becomes evident that a better split is available. The EFDT learns rapidly from a stationary distribution and eventually it learns the asymptotic batch tree if the distribution from which the data are drawn is stationary. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used. References \u00b6 C. Manapragada, G. Webb, and M. Salehi. Extremely Fast Decision Tree. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD '18). ACM, New York, NY, USA, 1953-1962. DOI: https://doi.org/10.1145/3219819.3220005 \u21a9","title":"ExtremelyFastDecisionTreeClassifier"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#extremelyfastdecisiontreeclassifier","text":"Extremely Fast Decision Tree classifier. Also referred to as Hoeffding AnyTime Tree (HATT) classifier.","title":"ExtremelyFastDecisionTreeClassifier"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. min_samples_reevaluate ( int ) \u2013 defaults to 20 Number of instances a node should observe before reevaluating the best split. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#attributes","text":"depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree.","title":"Attributes"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . ExtremelyFastDecisionTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ], ... min_samples_reevaluate = 100 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 89.09 %","title":"Examples"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#notes","text":"The Extremely Fast Decision Tree (EFDT) 1 constructs a tree incrementally. The EFDT seeks to select and deploy a split as soon as it is confident the split is useful, and then revisits that decision, replacing the split if it subsequently becomes evident that a better split is available. The EFDT learns rapidly from a stationary distribution and eventually it learns the asymptotic batch tree if the distribution from which the data are drawn is stationary. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used.","title":"Notes"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#references","text":"C. Manapragada, G. Webb, and M. Salehi. Extremely Fast Decision Tree. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD '18). ACM, New York, NY, USA, 1953-1962. DOI: https://doi.org/10.1145/3219819.3220005 \u21a9","title":"References"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/","text":"HoeffdingAdaptiveTreeClassifier \u00b6 Hoeffding Adaptive Tree classifier. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. seed \u2013 defaults to None If int, seed is the seed used by the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Only used when bootstrap_sampling=True to direct the bootstrap sampling. kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree. Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 500 , width = 50 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingAdaptiveTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... leaf_prediction = 'nb' , ... nb_threshold = 10 , ... seed = 0 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 91.09 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. Notes \u00b6 The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used. References \u00b6 Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"HoeffdingAdaptiveTreeClassifier"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#hoeffdingadaptivetreeclassifier","text":"Hoeffding Adaptive Tree classifier.","title":"HoeffdingAdaptiveTreeClassifier"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. seed \u2013 defaults to None If int, seed is the seed used by the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Only used when bootstrap_sampling=True to direct the bootstrap sampling. kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#attributes","text":"depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree.","title":"Attributes"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 500 , width = 50 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingAdaptiveTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... leaf_prediction = 'nb' , ... nb_threshold = 10 , ... seed = 0 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 91.09 %","title":"Examples"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#notes","text":"The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used.","title":"Notes"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#references","text":"Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"References"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/","text":"HoeffdingAdaptiveTreeRegressor \u00b6 Hoeffding Adaptive Tree regressor (HATR). This class implements a regression version of the Hoeffding Adaptive Tree Classifier. Hence, it also uses an ADWIN concept-drift detector instance at each decision node to monitor possible changes in the data distribution. If a drift is detected in a node, an alternate tree begins to be induced in the background. When enough information is gathered, HATR swaps the node where the change was detected by its alternate tree. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to e-bst The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. seed \u2013 defaults to None If int, seed is the seed used by the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Only used when bootstrap_sampling=True to direct the bootstrap sampling. kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingAdaptiveTreeRegressor ( ... grace_period = 50 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.3 , ... seed = 0 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.78838 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value. Notes \u00b6 The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance. To cope with ADWIN's requirements of bounded input data, HATR uses a novel error normalization strategy based on the empiral rule of Gaussian distributions. We assume the deviations of the predictions from the expected values follow a normal distribution. Hence, we subject these errors to a min-max normalization assuming that most of the data lies in the \\(\\left[-3\\sigma, 3\\sigma\\right]\\) range. These normalized errors are passed to the ADWIN instances. This is the same strategy used by Adaptive Random Forest Regressor. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, only one AO is supported in river for regression trees: The Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. However, E-BST automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage. References \u00b6 Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"HoeffdingAdaptiveTreeRegressor"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#hoeffdingadaptivetreeregressor","text":"Hoeffding Adaptive Tree regressor (HATR). This class implements a regression version of the Hoeffding Adaptive Tree Classifier. Hence, it also uses an ADWIN concept-drift detector instance at each decision node to monitor possible changes in the data distribution. If a drift is detected in a node, an alternate tree begins to be induced in the background. When enough information is gathered, HATR swaps the node where the change was detected by its alternate tree.","title":"HoeffdingAdaptiveTreeRegressor"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to e-bst The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. seed \u2013 defaults to None If int, seed is the seed used by the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Only used when bootstrap_sampling=True to direct the bootstrap sampling. kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#attributes","text":"depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree.","title":"Attributes"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingAdaptiveTreeRegressor ( ... grace_period = 50 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.3 , ... seed = 0 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.78838","title":"Examples"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value.","title":"Methods"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#notes","text":"The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance. To cope with ADWIN's requirements of bounded input data, HATR uses a novel error normalization strategy based on the empiral rule of Gaussian distributions. We assume the deviations of the predictions from the expected values follow a normal distribution. Hence, we subject these errors to a min-max normalization assuming that most of the data lies in the \\(\\left[-3\\sigma, 3\\sigma\\right]\\) range. These normalized errors are passed to the ADWIN instances. This is the same strategy used by Adaptive Random Forest Regressor. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, only one AO is supported in river for regression trees: The Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. However, E-BST automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage.","title":"Notes"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#references","text":"Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"References"},{"location":"api/tree/HoeffdingTreeClassifier/","text":"HoeffdingTreeClassifier \u00b6 Hoeffding Tree or Very Fast Decision Tree classifier. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree. Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ] ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 86.09 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. Notes \u00b6 A Hoeffding Tree 1 is an incremental, anytime decision tree induction algorithm that is capable of learning from massive data streams, assuming that the distribution generating examples does not change over time. Hoeffding trees exploit the fact that a small sample can often be enough to choose an optimal splitting attribute. This idea is supported mathematically by the Hoeffding bound, which quantifies the number of observations (in our case, examples) needed to estimate some statistics within a prescribed precision (in our case, the goodness of an attribute). A theoretically appealing feature of Hoeffding Trees not shared by other incremental decision tree learners is that it has sound guarantees of performance. Using the Hoeffding bound one can show that its output is asymptotically nearly identical to that of a non-incremental learner using infinitely many examples. Implementation based on MOA 2 . Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used. References \u00b6 G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"HoeffdingTreeClassifier"},{"location":"api/tree/HoeffdingTreeClassifier/#hoeffdingtreeclassifier","text":"Hoeffding Tree or Very Fast Decision Tree classifier.","title":"HoeffdingTreeClassifier"},{"location":"api/tree/HoeffdingTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/tree/HoeffdingTreeClassifier/#attributes","text":"depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree.","title":"Attributes"},{"location":"api/tree/HoeffdingTreeClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ] ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 86.09 %","title":"Examples"},{"location":"api/tree/HoeffdingTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/tree/HoeffdingTreeClassifier/#notes","text":"A Hoeffding Tree 1 is an incremental, anytime decision tree induction algorithm that is capable of learning from massive data streams, assuming that the distribution generating examples does not change over time. Hoeffding trees exploit the fact that a small sample can often be enough to choose an optimal splitting attribute. This idea is supported mathematically by the Hoeffding bound, which quantifies the number of observations (in our case, examples) needed to estimate some statistics within a prescribed precision (in our case, the goodness of an attribute). A theoretically appealing feature of Hoeffding Trees not shared by other incremental decision tree learners is that it has sound guarantees of performance. Using the Hoeffding bound one can show that its output is asymptotically nearly identical to that of a non-incremental learner using infinitely many examples. Implementation based on MOA 2 . Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used.","title":"Notes"},{"location":"api/tree/HoeffdingTreeClassifier/#references","text":"G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"References"},{"location":"api/tree/HoeffdingTreeRegressor/","text":"HoeffdingTreeRegressor \u00b6 Hoeffding Tree regressor. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to e-bst The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. - 'qo' : Quantizer Observer. This AO uses radius (defaults to 0.01 ) to define a cold-start for the quantization radius. As new leaves are created, new QO instances will use the standard deviation of the input features divided by std_div (defaults to 3 ) as radius values. If std_div is None , the initially passed radius value will be replicated to all QO instances. - 'te-bst' : Truncated E-BST. This extension of E-BST first truncates the input values before passing them to the binary search tree. The number of decimal places to consider is given by digits (defaults to 3 digits). See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.9 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.852902 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value. Notes \u00b6 The Hoeffding Tree Regressor (HTR) is an adaptation of the incremental tree algorithm of the same name for classification. Similarly to its classification counterpart, HTR uses the Hoeffding bound to control its split decisions. Differently from the classification algorithm, HTR relies on calculating the reduction of variance in the target space to decide among the split candidates. The smallest the variance at its leaf nodes, the more homogeneous the partitions are. At its leaf nodes, HTR fits either linear models or uses the target average as the predictor. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AO algorithms are supported in river for regression trees: Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. It has a \\(O(\\log n)\\) cost per insertion in average, where \\(n\\) is the number of observations. In the worst case, i.e., when input features values are passed in an ordered fashion, the insertion cost becomes \\(O(n)\\) . A naive E-BST implementation has a \\(O(n)\\) cost to evaluate split candidates since all stored points must be evaluated. However, the implementation of E-BST in river automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage. Quantizer Observer (QO) uses a dynamical hash-based algorithm to discretize the numerical input features and perform split attempts. QO has \\(O(1)\\) , \\(O(H)\\) , and \\(O(H\\log H)\\) costs of insertion, memory, and split candidate query, respectively, where \\(H\\) is the number of slots in QO's hash structure. Typically, \\(H \\ll n\\) . Truncated E-BST extends E-BST by rouding the input feature values before inserting them in the binary search tree (BST). Hence, similar inputs will be mapped to the nodes in the BST structure. This strategy might result in memory and processing time savings when compared to the vanilla E-BST.","title":"HoeffdingTreeRegressor"},{"location":"api/tree/HoeffdingTreeRegressor/#hoeffdingtreeregressor","text":"Hoeffding Tree regressor.","title":"HoeffdingTreeRegressor"},{"location":"api/tree/HoeffdingTreeRegressor/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to e-bst The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. - 'qo' : Quantizer Observer. This AO uses radius (defaults to 0.01 ) to define a cold-start for the quantization radius. As new leaves are created, new QO instances will use the standard deviation of the input features divided by std_div (defaults to 3 ) as radius values. If std_div is None , the initially passed radius value will be replicated to all QO instances. - 'te-bst' : Truncated E-BST. This extension of E-BST first truncates the input values before passing them to the binary search tree. The number of decimal places to consider is given by digits (defaults to 3 digits). See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/tree/HoeffdingTreeRegressor/#attributes","text":"depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree.","title":"Attributes"},{"location":"api/tree/HoeffdingTreeRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.9 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.852902","title":"Examples"},{"location":"api/tree/HoeffdingTreeRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value.","title":"Methods"},{"location":"api/tree/HoeffdingTreeRegressor/#notes","text":"The Hoeffding Tree Regressor (HTR) is an adaptation of the incremental tree algorithm of the same name for classification. Similarly to its classification counterpart, HTR uses the Hoeffding bound to control its split decisions. Differently from the classification algorithm, HTR relies on calculating the reduction of variance in the target space to decide among the split candidates. The smallest the variance at its leaf nodes, the more homogeneous the partitions are. At its leaf nodes, HTR fits either linear models or uses the target average as the predictor. Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AO algorithms are supported in river for regression trees: Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. It has a \\(O(\\log n)\\) cost per insertion in average, where \\(n\\) is the number of observations. In the worst case, i.e., when input features values are passed in an ordered fashion, the insertion cost becomes \\(O(n)\\) . A naive E-BST implementation has a \\(O(n)\\) cost to evaluate split candidates since all stored points must be evaluated. However, the implementation of E-BST in river automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage. Quantizer Observer (QO) uses a dynamical hash-based algorithm to discretize the numerical input features and perform split attempts. QO has \\(O(1)\\) , \\(O(H)\\) , and \\(O(H\\log H)\\) costs of insertion, memory, and split candidate query, respectively, where \\(H\\) is the number of slots in QO's hash structure. Typically, \\(H \\ll n\\) . Truncated E-BST extends E-BST by rouding the input feature values before inserting them in the binary search tree (BST). Hence, similar inputs will be mapped to the nodes in the BST structure. This strategy might result in memory and processing time savings when compared to the vanilla E-BST.","title":"Notes"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/","text":"LabelCombinationHoeffdingTreeClassifier \u00b6 Label Combination Hoeffding Tree for multi-label classification. Label combination transforms the problem from multi-label to multi-class. For each unique combination of labels it assigns a class and proceeds with training the hoeffding tree normally. The transformation is done by changing the label set which could be seen as a binary number to an int which will represent the class, and after the prediction the int is converted back to a binary number which is the predicted label-set. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = iter ( datasets . Music () . take ( 200 )) >>> model = tree . LabelCombinationHoeffdingTreeClassifier ( ... split_confidence = 1e-5 , ... grace_period = 50 ... ) >>> metric = metrics . Hamming () >>> evaluate . progressive_val_score ( dataset , model , metric ) Hamming : 0.154104 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Update the Multi-label Hoeffding Tree Classifier. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the labels of an instance. Parameters x ( dict ) Returns typing.Union[bool, str, int] : Predicted labels. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. Notes \u00b6 Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used.","title":"LabelCombinationHoeffdingTreeClassifier"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#labelcombinationhoeffdingtreeclassifier","text":"Label Combination Hoeffding Tree for multi-label classification. Label combination transforms the problem from multi-label to multi-class. For each unique combination of labels it assigns a class and proceeds with training the hoeffding tree normally. The transformation is done by changing the label set which could be seen as a binary number to an int which will represent the class, and after the prediction the int is converted back to a binary number which is the predicted label-set.","title":"LabelCombinationHoeffdingTreeClassifier"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to gaussian The Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'bst' : Binary Search Tree. - 'gaussian' : Gaussian observer. The n_splits used to query for split candidates can be adjusted (defaults to 10 ). - 'histogram' : Histogram-based class frequency estimation. The number of histogram bins ( n_bins -- defaults to 256 ) and the number of split point candidates to evaluate ( n_splits -- defaults to 32 ) can be adjusted. See 'Notes' for more information about the AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#attributes","text":"depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree.","title":"Attributes"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = iter ( datasets . Music () . take ( 200 )) >>> model = tree . LabelCombinationHoeffdingTreeClassifier ( ... split_confidence = 1e-5 , ... grace_period = 50 ... ) >>> metric = metrics . Hamming () >>> evaluate . progressive_val_score ( dataset , model , metric ) Hamming : 0.154104","title":"Examples"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Update the Multi-label Hoeffding Tree Classifier. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns Series : Series of predicted labels. predict_one Predict the labels of an instance. Parameters x ( dict ) Returns typing.Union[bool, str, int] : Predicted labels. predict_proba_many Predict the labels of a DataFrame X . Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : DataFrame that associate probabilities which each label as columns. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#notes","text":"Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, three AOs are supported in river for classification trees: Binary Search Tree (BST) : uses an exhaustive algorithm to find split candidates, similarly to batch decision trees. It ends up storing all observations between split attempts. This AO is the most costly one in terms of memory and processing time; however, it tends to yield the most accurate results when using leaf_prediction=mc . It cannot be used to calculate the Probability Density Function (PDF) of the monitored feature due to its binary tree nature. Hence, leaf prediction strategies other than the majority class will end up effectively mimicing the majority class classifier. This AO has no parameters. Gaussian Estimator : Approximates the numeric feature distribution by using a Gaussian distribution per class. The Cumulative Distribution Function (CDF) necessary to calculate the entropy (and, consequently, the information gain), the gini index, and other split criteria is then calculated using the fit feature's distribution. Histogram : approximates the numeric feature distribution using an incrementally maintained histogram per class. It represents a compromise between the intensive resource usage of BST and the strong assumptions about the feature's distribution used in the Gaussian Estimator. Besides that, this AO sits in the middle between the previous two in terms of memory usage and running time. Note that the number of bins affects the probability density approximation required to use leaves with (adaptive) naive bayes models. Hence, Histogram tends to be less accurate than the Gaussian estimator when adaptive or naive bayes leaves are used.","title":"Notes"},{"location":"api/tree/iSOUPTreeRegressor/","text":"iSOUPTreeRegressor \u00b6 Incremental Structured Output Prediction Tree (iSOUP-Tree) for multi-target regression. This is an implementation of the iSOUP-Tree proposed by A. Osojnik, P. Panov, and S. D\u017eeroski 1 . Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( Union[ base.Regressor , Dict] ) \u2013 defaults to None The regression model(s) used to provide responses if leaf_prediction='model' . It can be either a regressor (in which case it is going to be replicated to all the targets) or a dictionary whose keys are target identifiers, and the values are instances of river.base.Regressor. If not provided, instances of river.linear_model.LinearRegression with the default hyperparameters are used for all the targets. If a dictionary is passed and not all target models are specified, copies from the first model match in the dictionary will be used to the remaining targets. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to e-bst The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. kwargs Other parameters passed to river.tree.BaseHoeffdingTree . Attributes \u00b6 depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree. Examples \u00b6 >>> import numbers >>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> from river import tree >>> dataset = datasets . SolarFlare () >>> num = compose . SelectType ( numbers . Number ) | preprocessing . MinMaxScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder ( sparse = False ) >>> model = tree . iSOUPTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'model' , ... leaf_model = { ... 'c-class-flares' : linear_model . LinearRegression ( l2 = 0.02 ), ... 'm-class-flares' : linear_model . PARegressor (), ... 'x-class-flares' : linear_model . LinearRegression ( l2 = 0.1 ) ... } ... ) >>> pipeline = ( num + cat ) | model >>> metric = metrics . RegressionMultiOutput ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , pipeline , metric ) MAE : 0.425929 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model with one sample. Training tasks: * If the tree is empty, create a leaf node as the root. * If the tree is already initialized, find the corresponding leaf for the instance and update the leaf node statistics. * If growth is allowed and the number of instances that the leaf has observed between split attempts exceed the grace period then attempt to split. Parameters x ( dict ) y ( Dict[Hashable, numbers.Number] ) sample_weight ( float ) \u2013 defaults to 1.0 model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_one Predict the target values for a given instance. Parameters x ( dict ) Returns typing.Dict[typing.Hashable, numbers.Number] : dict Notes \u00b6 Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, only one AO is supported in river for regression trees: The Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. However, E-BST automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage. References \u00b6 Alja\u017e Osojnik, Pan\u010de Panov, and Sa\u0161o D\u017eeroski. \"Tree-based methods for online multi-target regression.\" Journal of Intelligent Information Systems 50.2 (2018): 315-339. \u21a9","title":"iSOUPTreeRegressor"},{"location":"api/tree/iSOUPTreeRegressor/#isouptreeregressor","text":"Incremental Structured Output Prediction Tree (iSOUP-Tree) for multi-target regression. This is an implementation of the iSOUP-Tree proposed by A. Osojnik, P. Panov, and S. D\u017eeroski 1 .","title":"iSOUPTreeRegressor"},{"location":"api/tree/iSOUPTreeRegressor/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( Union[ base.Regressor , Dict] ) \u2013 defaults to None The regression model(s) used to provide responses if leaf_prediction='model' . It can be either a regressor (in which case it is going to be replicated to all the targets) or a dictionary whose keys are target identifiers, and the values are instances of river.base.Regressor. If not provided, instances of river.linear_model.LinearRegression with the default hyperparameters are used for all the targets. If a dictionary is passed and not all target models are specified, copies from the first model match in the dictionary will be used to the remaining targets. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. attr_obs ( str ) \u2013 defaults to e-bst The attribute observer (AO) used to monitor the target statistics of numeric features and perform splits. Parameters can be passed to the AOs (when supported) by using attr_obs_params . Valid options are: - 'e-bst' : Extended Binary Search Tree (E-BST). This AO has no parameters. See notes for more information about the supported AOs. attr_obs_params ( dict ) \u2013 defaults to None Parameters passed to the numeric AOs. See attr_obs for more information. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. kwargs Other parameters passed to river.tree.BaseHoeffdingTree .","title":"Parameters"},{"location":"api/tree/iSOUPTreeRegressor/#attributes","text":"depth The depth of the tree. leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). model_measurements Collect metrics corresponding to the current status of the tree in a string buffer. split_criterion Return a string with the name of the split criterion being used by the tree.","title":"Attributes"},{"location":"api/tree/iSOUPTreeRegressor/#examples","text":">>> import numbers >>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> from river import tree >>> dataset = datasets . SolarFlare () >>> num = compose . SelectType ( numbers . Number ) | preprocessing . MinMaxScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder ( sparse = False ) >>> model = tree . iSOUPTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'model' , ... leaf_model = { ... 'c-class-flares' : linear_model . LinearRegression ( l2 = 0.02 ), ... 'm-class-flares' : linear_model . PARegressor (), ... 'x-class-flares' : linear_model . LinearRegression ( l2 = 0.1 ) ... } ... ) >>> pipeline = ( num + cat ) | model >>> metric = metrics . RegressionMultiOutput ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , pipeline , metric ) MAE : 0.425929","title":"Examples"},{"location":"api/tree/iSOUPTreeRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model with one sample. Training tasks: * If the tree is empty, create a leaf node as the root. * If the tree is already initialized, find the corresponding leaf for the instance and update the leaf node statistics. * If growth is allowed and the number of instances that the leaf has observed between split attempts exceed the grace period then attempt to split. Parameters x ( dict ) y ( Dict[Hashable, numbers.Number] ) sample_weight ( float ) \u2013 defaults to 1.0 model_description Walk the tree and return its structure in a buffer. Returns The description of the model. predict_one Predict the target values for a given instance. Parameters x ( dict ) Returns typing.Dict[typing.Hashable, numbers.Number] : dict","title":"Methods"},{"location":"api/tree/iSOUPTreeRegressor/#notes","text":"Hoeffding trees rely on Attribute Observer (AO) algorithms to monitor input features and perform splits. Nominal features can be easily dealt with, since the partitions are well-defined. Numerical features, however, require more sophisticated solutions. Currently, only one AO is supported in river for regression trees: The Extended Binary Search Tree (E-BST) uses an exhaustive algorithm to find split candidates, similarly to batch decision tree algorithms. It ends up storing all observations between split attempts. However, E-BST automatically removes bad split points periodically from its structure and, thus, alleviates the memory and time costs involved in its usage.","title":"Notes"},{"location":"api/tree/iSOUPTreeRegressor/#references","text":"Alja\u017e Osojnik, Pan\u010de Panov, and Sa\u0161o D\u017eeroski. \"Tree-based methods for online multi-target regression.\" Journal of Intelligent Information Systems 50.2 (2018): 315-339. \u21a9","title":"References"},{"location":"api/utils/Histogram/","text":"Histogram \u00b6 Streaming histogram. Parameters \u00b6 max_bins \u2013 defaults to 256 Maximal number of bins. Attributes \u00b6 n Total number of seen values. Examples \u00b6 >>> from river import utils >>> import matplotlib.pyplot as plt >>> import numpy as np >>> np . random . seed ( 42 ) >>> values = np . hstack (( ... np . random . normal ( - 3 , 1 , 1000 ), ... np . random . normal ( 3 , 1 , 1000 ), ... )) >>> hist = utils . Histogram ( max_bins = 60 ) >>> for x in values : ... hist = hist . update ( x ) >>> ax = plt . bar ( ... x = [( b . left + b . right ) / 2 for b in hist ], ... height = [ b . count for b in hist ], ... width = [( b . right - b . left ) / 2 for b in hist ] ... ) .. image:: ../../docs/img/histogram_docstring.svg :align: center Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item cdf Cumulative distribution function. Example: >>> from river import utils >>> hist = utils.Histogram() >>> for x in range(4): ... hist = hist.update(x) >>> print(hist) [0.00000, 0.00000]: 1 [1.00000, 1.00000]: 1 [2.00000, 2.00000]: 1 [3.00000, 3.00000]: 1 >>> hist.cdf(-1) 0.0 >>> hist.cdf(0) 0.25 >>> hist.cdf(.5) 0.25 >>> hist.cdf(1) 0.5 >>> hist.cdf(2.5) 0.75 >>> hist.cdf(3.5) 1.0 Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item iter_cdf Yields CDF values for a sorted iterable of values. This is faster than calling cdf with many values. Example: >>> from river import utils >>> hist = utils.Histogram() >>> for x in range(4): ... hist = hist.update(x) >>> print(hist) [0.00000, 0.00000]: 1 [1.00000, 1.00000]: 1 [2.00000, 2.00000]: 1 [3.00000, 3.00000]: 1 >>> X = [-1, 0, .5, 1, 2.5, 3.5] >>> for x, cdf in zip(X, hist.iter_cdf(X)): ... print(x, cdf) -1 0.0 0 0.25 0.5 0.25 1 0.5 2.5 0.75 3.5 1.0 Parameters X verbose \u2013 defaults to False pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update References \u00b6 Ben-Haim, Y. and Tom-Tov, E., 2010. A streaming parallel decision tree algorithm. Journal of Machine Learning Research, 11(Feb), pp.849-872. \u21a9 Go implementation \u21a9","title":"Histogram"},{"location":"api/utils/Histogram/#histogram","text":"Streaming histogram.","title":"Histogram"},{"location":"api/utils/Histogram/#parameters","text":"max_bins \u2013 defaults to 256 Maximal number of bins.","title":"Parameters"},{"location":"api/utils/Histogram/#attributes","text":"n Total number of seen values.","title":"Attributes"},{"location":"api/utils/Histogram/#examples","text":">>> from river import utils >>> import matplotlib.pyplot as plt >>> import numpy as np >>> np . random . seed ( 42 ) >>> values = np . hstack (( ... np . random . normal ( - 3 , 1 , 1000 ), ... np . random . normal ( 3 , 1 , 1000 ), ... )) >>> hist = utils . Histogram ( max_bins = 60 ) >>> for x in values : ... hist = hist . update ( x ) >>> ax = plt . bar ( ... x = [( b . left + b . right ) / 2 for b in hist ], ... height = [ b . count for b in hist ], ... width = [( b . right - b . left ) / 2 for b in hist ] ... ) .. image:: ../../docs/img/histogram_docstring.svg :align: center","title":"Examples"},{"location":"api/utils/Histogram/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item cdf Cumulative distribution function. Example: >>> from river import utils >>> hist = utils.Histogram() >>> for x in range(4): ... hist = hist.update(x) >>> print(hist) [0.00000, 0.00000]: 1 [1.00000, 1.00000]: 1 [2.00000, 2.00000]: 1 [3.00000, 3.00000]: 1 >>> hist.cdf(-1) 0.0 >>> hist.cdf(0) 0.25 >>> hist.cdf(.5) 0.25 >>> hist.cdf(1) 0.5 >>> hist.cdf(2.5) 0.75 >>> hist.cdf(3.5) 1.0 Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item iter_cdf Yields CDF values for a sorted iterable of values. This is faster than calling cdf with many values. Example: >>> from river import utils >>> hist = utils.Histogram() >>> for x in range(4): ... hist = hist.update(x) >>> print(hist) [0.00000, 0.00000]: 1 [1.00000, 1.00000]: 1 [2.00000, 2.00000]: 1 [3.00000, 3.00000]: 1 >>> X = [-1, 0, .5, 1, 2.5, 3.5] >>> for x, cdf in zip(X, hist.iter_cdf(X)): ... print(x, cdf) -1 0.0 0 0.25 0.5 0.25 1 0.5 2.5 0.75 3.5 1.0 Parameters X verbose \u2013 defaults to False pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update","title":"Methods"},{"location":"api/utils/Histogram/#references","text":"Ben-Haim, Y. and Tom-Tov, E., 2010. A streaming parallel decision tree algorithm. Journal of Machine Learning Research, 11(Feb), pp.849-872. \u21a9 Go implementation \u21a9","title":"References"},{"location":"api/utils/SDFT/","text":"SDFT \u00b6 Sliding Discrete Fourier Transform (SDFT). Initially, the coefficients are all equal to 0, up until enough values have been seen. A call to numpy.fft.fft is triggered once window_size values have been seen. Subsequent values will update the coefficients online. This is much faster than recomputing an FFT from scratch for every new value. Parameters \u00b6 window_size The size of the window. Attributes \u00b6 window ( utils.Window ) The window of values. Examples \u00b6 >>> from river import utils >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> window_size = 5 >>> sdft = utils . SDFT ( window_size ) >>> for i , x in enumerate ( X ): ... sdft = sdft . update ( x ) ... ... if i + 1 >= window_size : ... assert np . allclose ( sdft , np . fft . fft ( X [ i + 1 - window_size : i + 1 ])) Methods \u00b6 append extend popleft update References \u00b6 Jacobsen, E. and Lyons, R., 2003. The sliding DFT. IEEE Signal Processing Magazine, 20(2), pp.74-80. <https://www.comm.utoronto.ca/~dimitris/ece431/slidingdft.pdf> _ \u21a9 Understanding and Implementing the Sliding DFT <https://www.dsprelated.com/showarticle/776.php> _ \u21a9","title":"SDFT"},{"location":"api/utils/SDFT/#sdft","text":"Sliding Discrete Fourier Transform (SDFT). Initially, the coefficients are all equal to 0, up until enough values have been seen. A call to numpy.fft.fft is triggered once window_size values have been seen. Subsequent values will update the coefficients online. This is much faster than recomputing an FFT from scratch for every new value.","title":"SDFT"},{"location":"api/utils/SDFT/#parameters","text":"window_size The size of the window.","title":"Parameters"},{"location":"api/utils/SDFT/#attributes","text":"window ( utils.Window ) The window of values.","title":"Attributes"},{"location":"api/utils/SDFT/#examples","text":">>> from river import utils >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> window_size = 5 >>> sdft = utils . SDFT ( window_size ) >>> for i , x in enumerate ( X ): ... sdft = sdft . update ( x ) ... ... if i + 1 >= window_size : ... assert np . allclose ( sdft , np . fft . fft ( X [ i + 1 - window_size : i + 1 ]))","title":"Examples"},{"location":"api/utils/SDFT/#methods","text":"append extend popleft update","title":"Methods"},{"location":"api/utils/SDFT/#references","text":"Jacobsen, E. and Lyons, R., 2003. The sliding DFT. IEEE Signal Processing Magazine, 20(2), pp.74-80. <https://www.comm.utoronto.ca/~dimitris/ece431/slidingdft.pdf> _ \u21a9 Understanding and Implementing the Sliding DFT <https://www.dsprelated.com/showarticle/776.php> _ \u21a9","title":"References"},{"location":"api/utils/Skyline/","text":"Skyline \u00b6 A skyline is set of points which is not dominated by any other point. This implementation uses a block nested loop. Identical observations are all part of the skyline if applicable. Parameters \u00b6 minimize ( list ) \u2013 defaults to None A list of features for which the values need to be minimized. Can be omitted as long as maximize is specified. maximize ( list ) \u2013 defaults to None A list of features for which the values need to be maximized. Can be omitted as long as minimize is specified. Examples \u00b6 Here is an example taken from this blog post. >>> import random >>> from river import utils >>> import matplotlib.pyplot as plt >>> city_prices = { ... 'Bordeaux' : 4045 , ... 'Lyon' : 4547 , ... 'Toulouse' : 3278 ... } >>> def random_house (): ... city = random . choice ([ 'Bordeaux' , 'Lyon' , 'Toulouse' ]) ... size = round ( random . gauss ( 200 , 50 )) ... price = round ( random . uniform ( 0.8 , 1.2 ) * city_prices [ city ] * size ) ... return { 'city' : city , 'size' : size , 'price' : price } >>> skyline = utils . Skyline ( minimize = [ 'price' ], maximize = [ 'size' ]) >>> random . seed ( 42 ) >>> for _ in range ( 100 ): ... house = random_house () ... skyline = skyline . update ( house ) >>> print ( len ( skyline )) 13 >>> print ( skyline [ 0 ]) { 'city' : 'Toulouse' , 'size' : 280 , 'price' : 763202 } >>> fig , ax = plt . subplots () >>> scatter = ax . scatter ( ... x = [ h [ 'size' ] for h in skyline ], ... y = [ h [ 'price' ] for h in skyline ] ... ) >>> grid = ax . grid () >>> title = ax . set_title ( 'Houses skyline' ) >>> xlabel = ax . set_xlabel ( 'Size' ) >>> ylabel = ax . set_ylabel ( 'Price' ) .. image:: ../../docs/img/skyline_docstring.svg :align: center Here is another example using the kart data from Mario Kart: Double Dash!! . >>> import collections >>> from river import utils >>> Kart = collections . namedtuple ( ... 'Kart' , ... 'name speed off_road acceleration weight turbo' ... ) >>> karts = [ ... Kart ( 'Red Fire' , 5 , 4 , 4 , 5 , 2 ), ... Kart ( 'Green Fire' , 7 , 3 , 3 , 4 , 2 ), ... Kart ( 'Heart Coach' , 4 , 6 , 6 , 5 , 2 ), ... Kart ( 'Bloom Coach' , 6 , 4 , 5 , 3 , 2 ), ... Kart ( 'Turbo Yoshi' , 4 , 5 , 6 , 6 , 2 ), ... Kart ( 'Turbo Birdo' , 6 , 4 , 4 , 7 , 2 ), ... Kart ( 'Goo-Goo Buggy' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Rattle Buggy' , 2 , 9 , 8 , 2 , 3 ), ... Kart ( 'Toad Kart' , 3 , 9 , 7 , 2 , 3 ), ... Kart ( 'Toadette Kart' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Koopa Dasher' , 2 , 8 , 8 , 3 , 3 ), ... Kart ( 'Para-Wing' , 1 , 8 , 9 , 3 , 3 ), ... Kart ( 'DK Jumbo' , 8 , 2 , 2 , 8 , 1 ), ... Kart ( 'Barrel Train' , 8 , 7 , 3 , 5 , 3 ), ... Kart ( 'Koopa King' , 9 , 1 , 1 , 9 , 1 ), ... Kart ( 'Bullet Blaster' , 8 , 1 , 4 , 1 , 3 ), ... Kart ( 'Wario Car' , 7 , 3 , 3 , 7 , 1 ), ... Kart ( 'Waluigi Racer' , 5 , 9 , 5 , 6 , 2 ), ... Kart ( 'Piranha Pipes' , 8 , 7 , 2 , 9 , 1 ), ... Kart ( 'Boo Pipes' , 2 , 9 , 8 , 9 , 1 ), ... Kart ( 'Parade Kart' , 7 , 3 , 4 , 7 , 3 ) ... ] >>> skyline = utils . Skyline ( ... maximize = [ 'speed' , 'off_road' , 'acceleration' , 'turbo' ], ... minimize = [ 'weight' ] ... ) >>> for kart in karts : ... skyline = skyline . update ( kart . _asdict ()) >>> best_cart_names = [ kart [ 'name' ] for kart in skyline ] >>> for name in best_cart_names : ... print ( f '- { name } ' ) - Green Fire - Heart Coach - Bloom Coach - Goo - Goo Buggy - Rattle Buggy - Toad Kart - Toadette Kart - Barrel Train - Koopa King - Bullet Blaster - Waluigi Racer - Parade Kart >>> for name in sorted ( set ( kart . name for kart in karts ) - set ( best_cart_names )): ... print ( f '- { name } ' ) - Boo Pipes - DK Jumbo - Koopa Dasher - Para - Wing - Piranha Pipes - Red Fire - Turbo Birdo - Turbo Yoshi - Wario Car Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update References \u00b6 Skyline queries in Python \u21a9 Borzsony, S., Kossmann, D. and Stocker, K., 2001, April. The skyline operator. In Proceedings 17th international conference on data engineering (pp. 421-430). IEEE. \u21a9 Tao, Y. and Papadias, D., 2006. Maintaining sliding window skylines on data streams. IEEE Transactions on Knowledge and Data Engineering, 18(3), pp.377-391. \u21a9","title":"Skyline"},{"location":"api/utils/Skyline/#skyline","text":"A skyline is set of points which is not dominated by any other point. This implementation uses a block nested loop. Identical observations are all part of the skyline if applicable.","title":"Skyline"},{"location":"api/utils/Skyline/#parameters","text":"minimize ( list ) \u2013 defaults to None A list of features for which the values need to be minimized. Can be omitted as long as maximize is specified. maximize ( list ) \u2013 defaults to None A list of features for which the values need to be maximized. Can be omitted as long as minimize is specified.","title":"Parameters"},{"location":"api/utils/Skyline/#examples","text":"Here is an example taken from this blog post. >>> import random >>> from river import utils >>> import matplotlib.pyplot as plt >>> city_prices = { ... 'Bordeaux' : 4045 , ... 'Lyon' : 4547 , ... 'Toulouse' : 3278 ... } >>> def random_house (): ... city = random . choice ([ 'Bordeaux' , 'Lyon' , 'Toulouse' ]) ... size = round ( random . gauss ( 200 , 50 )) ... price = round ( random . uniform ( 0.8 , 1.2 ) * city_prices [ city ] * size ) ... return { 'city' : city , 'size' : size , 'price' : price } >>> skyline = utils . Skyline ( minimize = [ 'price' ], maximize = [ 'size' ]) >>> random . seed ( 42 ) >>> for _ in range ( 100 ): ... house = random_house () ... skyline = skyline . update ( house ) >>> print ( len ( skyline )) 13 >>> print ( skyline [ 0 ]) { 'city' : 'Toulouse' , 'size' : 280 , 'price' : 763202 } >>> fig , ax = plt . subplots () >>> scatter = ax . scatter ( ... x = [ h [ 'size' ] for h in skyline ], ... y = [ h [ 'price' ] for h in skyline ] ... ) >>> grid = ax . grid () >>> title = ax . set_title ( 'Houses skyline' ) >>> xlabel = ax . set_xlabel ( 'Size' ) >>> ylabel = ax . set_ylabel ( 'Price' ) .. image:: ../../docs/img/skyline_docstring.svg :align: center Here is another example using the kart data from Mario Kart: Double Dash!! . >>> import collections >>> from river import utils >>> Kart = collections . namedtuple ( ... 'Kart' , ... 'name speed off_road acceleration weight turbo' ... ) >>> karts = [ ... Kart ( 'Red Fire' , 5 , 4 , 4 , 5 , 2 ), ... Kart ( 'Green Fire' , 7 , 3 , 3 , 4 , 2 ), ... Kart ( 'Heart Coach' , 4 , 6 , 6 , 5 , 2 ), ... Kart ( 'Bloom Coach' , 6 , 4 , 5 , 3 , 2 ), ... Kart ( 'Turbo Yoshi' , 4 , 5 , 6 , 6 , 2 ), ... Kart ( 'Turbo Birdo' , 6 , 4 , 4 , 7 , 2 ), ... Kart ( 'Goo-Goo Buggy' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Rattle Buggy' , 2 , 9 , 8 , 2 , 3 ), ... Kart ( 'Toad Kart' , 3 , 9 , 7 , 2 , 3 ), ... Kart ( 'Toadette Kart' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Koopa Dasher' , 2 , 8 , 8 , 3 , 3 ), ... Kart ( 'Para-Wing' , 1 , 8 , 9 , 3 , 3 ), ... Kart ( 'DK Jumbo' , 8 , 2 , 2 , 8 , 1 ), ... Kart ( 'Barrel Train' , 8 , 7 , 3 , 5 , 3 ), ... Kart ( 'Koopa King' , 9 , 1 , 1 , 9 , 1 ), ... Kart ( 'Bullet Blaster' , 8 , 1 , 4 , 1 , 3 ), ... Kart ( 'Wario Car' , 7 , 3 , 3 , 7 , 1 ), ... Kart ( 'Waluigi Racer' , 5 , 9 , 5 , 6 , 2 ), ... Kart ( 'Piranha Pipes' , 8 , 7 , 2 , 9 , 1 ), ... Kart ( 'Boo Pipes' , 2 , 9 , 8 , 9 , 1 ), ... Kart ( 'Parade Kart' , 7 , 3 , 4 , 7 , 3 ) ... ] >>> skyline = utils . Skyline ( ... maximize = [ 'speed' , 'off_road' , 'acceleration' , 'turbo' ], ... minimize = [ 'weight' ] ... ) >>> for kart in karts : ... skyline = skyline . update ( kart . _asdict ()) >>> best_cart_names = [ kart [ 'name' ] for kart in skyline ] >>> for name in best_cart_names : ... print ( f '- { name } ' ) - Green Fire - Heart Coach - Bloom Coach - Goo - Goo Buggy - Rattle Buggy - Toad Kart - Toadette Kart - Barrel Train - Koopa King - Bullet Blaster - Waluigi Racer - Parade Kart >>> for name in sorted ( set ( kart . name for kart in karts ) - set ( best_cart_names )): ... print ( f '- { name } ' ) - Boo Pipes - DK Jumbo - Koopa Dasher - Para - Wing - Piranha Pipes - Red Fire - Turbo Birdo - Turbo Yoshi - Wario Car","title":"Examples"},{"location":"api/utils/Skyline/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update","title":"Methods"},{"location":"api/utils/Skyline/#references","text":"Skyline queries in Python \u21a9 Borzsony, S., Kossmann, D. and Stocker, K., 2001, April. The skyline operator. In Proceedings 17th international conference on data engineering (pp. 421-430). IEEE. \u21a9 Tao, Y. and Papadias, D., 2006. Maintaining sliding window skylines on data streams. IEEE Transactions on Knowledge and Data Engineering, 18(3), pp.377-391. \u21a9","title":"References"},{"location":"api/utils/SortedWindow/","text":"SortedWindow \u00b6 Sorted running window data structure. Parameters \u00b6 size ( int ) Size of the window to compute the rolling quantile. Attributes \u00b6 size Examples \u00b6 >>> from river import utils >>> window = utils . SortedWindow ( size = 3 ) >>> for i in reversed ( range ( 9 )): ... print ( window . append ( i )) [ 8 ] [ 7 , 8 ] [ 6 , 7 , 8 ] [ 5 , 6 , 7 ] [ 4 , 5 , 6 ] [ 3 , 4 , 5 ] [ 2 , 3 , 4 ] [ 1 , 2 , 3 ] [ 0 , 1 , 2 ] Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Left sorted inserts in Python \u21a9","title":"SortedWindow"},{"location":"api/utils/SortedWindow/#sortedwindow","text":"Sorted running window data structure.","title":"SortedWindow"},{"location":"api/utils/SortedWindow/#parameters","text":"size ( int ) Size of the window to compute the rolling quantile.","title":"Parameters"},{"location":"api/utils/SortedWindow/#attributes","text":"size","title":"Attributes"},{"location":"api/utils/SortedWindow/#examples","text":">>> from river import utils >>> window = utils . SortedWindow ( size = 3 ) >>> for i in reversed ( range ( 9 )): ... print ( window . append ( i )) [ 8 ] [ 7 , 8 ] [ 6 , 7 , 8 ] [ 5 , 6 , 7 ] [ 4 , 5 , 6 ] [ 3 , 4 , 5 ] [ 2 , 3 , 4 ] [ 1 , 2 , 3 ] [ 0 , 1 , 2 ]","title":"Examples"},{"location":"api/utils/SortedWindow/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/utils/SortedWindow/#references","text":"Left sorted inserts in Python \u21a9","title":"References"},{"location":"api/utils/VectorDict/","text":"VectorDict \u00b6 Methods \u00b6 abs clear get Parameters key args kwargs items keys max maximum Parameters other min minimum Parameters other pop Parameters args kwargs popitem setdefault Parameters key args kwargs to_dict to_numpy Parameters fields update Parameters args kwargs values with_mask Parameters mask copy","title":"VectorDict"},{"location":"api/utils/VectorDict/#vectordict","text":"","title":"VectorDict"},{"location":"api/utils/VectorDict/#methods","text":"abs clear get Parameters key args kwargs items keys max maximum Parameters other min minimum Parameters other pop Parameters args kwargs popitem setdefault Parameters key args kwargs to_dict to_numpy Parameters fields update Parameters args kwargs values with_mask Parameters mask copy","title":"Methods"},{"location":"api/utils/Window/","text":"Window \u00b6 Running window data structure. This is just a convenience layer on top of a collections.deque . The only reason this exists is that deepcopying a class which inherits from collections.deque seems to bug out when the class has a parameter with no default value. Parameters \u00b6 size ( int ) Size of the rolling window. Attributes \u00b6 size Examples \u00b6 >>> from river import utils >>> window = utils . Window ( size = 2 ) >>> for x in [ 1 , 2 , 3 , 4 , 5 , 6 ]: ... print ( window . append ( x )) [ 1 ] [ 1 , 2 ] [ 2 , 3 ] [ 3 , 4 ] [ 4 , 5 ] [ 5 , 6 ] Methods \u00b6 append extend popleft","title":"Window"},{"location":"api/utils/Window/#window","text":"Running window data structure. This is just a convenience layer on top of a collections.deque . The only reason this exists is that deepcopying a class which inherits from collections.deque seems to bug out when the class has a parameter with no default value.","title":"Window"},{"location":"api/utils/Window/#parameters","text":"size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/utils/Window/#attributes","text":"size","title":"Attributes"},{"location":"api/utils/Window/#examples","text":">>> from river import utils >>> window = utils . Window ( size = 2 ) >>> for x in [ 1 , 2 , 3 , 4 , 5 , 6 ]: ... print ( window . append ( x )) [ 1 ] [ 1 , 2 ] [ 2 , 3 ] [ 3 , 4 ] [ 4 , 5 ] [ 5 , 6 ]","title":"Examples"},{"location":"api/utils/Window/#methods","text":"append extend popleft","title":"Methods"},{"location":"api/utils/check-estimator/","text":"check_estimator \u00b6 Check if a model adheres to river 's conventions. This will run a series of unit tests. The nature of the unit tests depends on the type of model. Parameters \u00b6 model","title":"check_estimator"},{"location":"api/utils/check-estimator/#check_estimator","text":"Check if a model adheres to river 's conventions. This will run a series of unit tests. The nature of the unit tests depends on the type of model.","title":"check_estimator"},{"location":"api/utils/check-estimator/#parameters","text":"model","title":"Parameters"},{"location":"api/utils/dict2numpy/","text":"dict2numpy \u00b6 Convert a dictionary containing data to a numpy array. There is not restriction to the type of keys in data , but values must be strictly numeric. To make sure random permutations of the features do not impact on the learning algorithms, keys are first converted to strings and then sorted prior to the conversion. Parameters \u00b6 data A dictionary whose keys represent input attributes and the values represent their observed contents. Examples \u00b6 >>> from river.utils import dict2numpy >>> dict2numpy ({ 'a' : 1 , 'b' : 2 , 3 : 3 }) array ([ 3 , 1 , 2 ])","title":"dict2numpy"},{"location":"api/utils/dict2numpy/#dict2numpy","text":"Convert a dictionary containing data to a numpy array. There is not restriction to the type of keys in data , but values must be strictly numeric. To make sure random permutations of the features do not impact on the learning algorithms, keys are first converted to strings and then sorted prior to the conversion.","title":"dict2numpy"},{"location":"api/utils/dict2numpy/#parameters","text":"data A dictionary whose keys represent input attributes and the values represent their observed contents.","title":"Parameters"},{"location":"api/utils/dict2numpy/#examples","text":">>> from river.utils import dict2numpy >>> dict2numpy ({ 'a' : 1 , 'b' : 2 , 3 : 3 }) array ([ 3 , 1 , 2 ])","title":"Examples"},{"location":"api/utils/expand-param-grid/","text":"expand_param_grid \u00b6 Expands a grid of parameters. This method can be used to generate a list of model parametrizations from a dictionary where each parameter is associated with a list of possible parameters. In other words, it expands a grid of parameters. Typically, this method can be used to create copies of a given model with different parameter choices. The models can then be used as part of a model selection process, such as a expert.SuccessiveHalvingClassifier or a expert.EWARegressor . The syntax for the parameter grid is quite flexible. It allows nesting parameters and can therefore be used to generate parameters for a pipeline. Parameters \u00b6 model ( base.Estimator ) grid ( dict ) The grid of parameters to expand. The provided dictionary can be nested. The only requirement is that the values at the leaves need to be lists. Examples \u00b6 As an initial example, we can expand a grid of parameters for a single model. >>> from river import linear_model >>> from river import optim >>> from river import utils >>> model = linear_model . LinearRegression () >>> grid = { 'optimizer' : [ optim . SGD ( . 1 ), optim . SGD ( . 01 ), optim . SGD ( . 001 )]} >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 3 >>> models [ 0 ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.1 ) ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) You can expand parameters for multiple choices like so: >>> grid = { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 , . 001 ]}), ... ( optim . Adam , { 'lr' : [ . 1 , . 01 , . 01 ]}) ... ] ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 6 You may specify a grid of parameters for a pipeline via nesting: >>> from river import feature_extraction >>> model = ( ... feature_extraction . BagOfWords () | ... linear_model . LinearRegression () ... ) >>> grid = { ... 'BagOfWords' : { ... 'strip_accents' : [ False , True ] ... }, ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 ]}), ... ( optim . Adam , { 'lr' : [ . 1 , . 01 ]}) ... ] ... } ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 8","title":"expand_param_grid"},{"location":"api/utils/expand-param-grid/#expand_param_grid","text":"Expands a grid of parameters. This method can be used to generate a list of model parametrizations from a dictionary where each parameter is associated with a list of possible parameters. In other words, it expands a grid of parameters. Typically, this method can be used to create copies of a given model with different parameter choices. The models can then be used as part of a model selection process, such as a expert.SuccessiveHalvingClassifier or a expert.EWARegressor . The syntax for the parameter grid is quite flexible. It allows nesting parameters and can therefore be used to generate parameters for a pipeline.","title":"expand_param_grid"},{"location":"api/utils/expand-param-grid/#parameters","text":"model ( base.Estimator ) grid ( dict ) The grid of parameters to expand. The provided dictionary can be nested. The only requirement is that the values at the leaves need to be lists.","title":"Parameters"},{"location":"api/utils/expand-param-grid/#examples","text":"As an initial example, we can expand a grid of parameters for a single model. >>> from river import linear_model >>> from river import optim >>> from river import utils >>> model = linear_model . LinearRegression () >>> grid = { 'optimizer' : [ optim . SGD ( . 1 ), optim . SGD ( . 01 ), optim . SGD ( . 001 )]} >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 3 >>> models [ 0 ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.1 ) ) loss = Squared () l2 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) You can expand parameters for multiple choices like so: >>> grid = { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 , . 001 ]}), ... ( optim . Adam , { 'lr' : [ . 1 , . 01 , . 01 ]}) ... ] ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 6 You may specify a grid of parameters for a pipeline via nesting: >>> from river import feature_extraction >>> model = ( ... feature_extraction . BagOfWords () | ... linear_model . LinearRegression () ... ) >>> grid = { ... 'BagOfWords' : { ... 'strip_accents' : [ False , True ] ... }, ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ . 1 , . 01 ]}), ... ( optim . Adam , { 'lr' : [ . 1 , . 01 ]}) ... ] ... } ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 8","title":"Examples"},{"location":"api/utils/numpy2dict/","text":"numpy2dict \u00b6 Convert a numpy array to a dictionary. Parameters \u00b6 data ( numpy.ndarray ) An one-dimensional numpy.array. Examples \u00b6 >>> import numpy as np >>> from river.utils import numpy2dict >>> numpy2dict ( np . array ([ 1.0 , 2.0 , 3.0 ])) { 0 : 1.0 , 1 : 2.0 , 2 : 3.0 }","title":"numpy2dict"},{"location":"api/utils/numpy2dict/#numpy2dict","text":"Convert a numpy array to a dictionary.","title":"numpy2dict"},{"location":"api/utils/numpy2dict/#parameters","text":"data ( numpy.ndarray ) An one-dimensional numpy.array.","title":"Parameters"},{"location":"api/utils/numpy2dict/#examples","text":">>> import numpy as np >>> from river.utils import numpy2dict >>> numpy2dict ( np . array ([ 1.0 , 2.0 , 3.0 ])) { 0 : 1.0 , 1 : 2.0 , 2 : 3.0 }","title":"Examples"},{"location":"api/utils/math/argmax/","text":"argmax \u00b6 Argmax function. Parameters \u00b6 lst ( list )","title":"argmax"},{"location":"api/utils/math/argmax/#argmax","text":"Argmax function.","title":"argmax"},{"location":"api/utils/math/argmax/#parameters","text":"lst ( list )","title":"Parameters"},{"location":"api/utils/math/chain-dot/","text":"chain_dot \u00b6 Returns the dot product of multiple vectors represented as dicts. Parameters \u00b6 xs Examples \u00b6 >>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 , 'x2' : 1 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> z = { 'x1' : 2 , 'x2' : 1 / 3 } >>> utils . math . chain_dot ( x , y , z ) 85.0","title":"chain_dot"},{"location":"api/utils/math/chain-dot/#chain_dot","text":"Returns the dot product of multiple vectors represented as dicts.","title":"chain_dot"},{"location":"api/utils/math/chain-dot/#parameters","text":"xs","title":"Parameters"},{"location":"api/utils/math/chain-dot/#examples","text":">>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 , 'x2' : 1 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> z = { 'x1' : 2 , 'x2' : 1 / 3 } >>> utils . math . chain_dot ( x , y , z ) 85.0","title":"Examples"},{"location":"api/utils/math/clamp/","text":"clamp \u00b6 Clamp a number. This is a synonym of clipping. Parameters \u00b6 x ( float ) minimum \u2013 defaults to 0.0 maximum \u2013 defaults to 1.0","title":"clamp"},{"location":"api/utils/math/clamp/#clamp","text":"Clamp a number. This is a synonym of clipping.","title":"clamp"},{"location":"api/utils/math/clamp/#parameters","text":"x ( float ) minimum \u2013 defaults to 0.0 maximum \u2013 defaults to 1.0","title":"Parameters"},{"location":"api/utils/math/dot/","text":"dot \u00b6 Returns the dot product of two vectors represented as dicts. Parameters \u00b6 x ( dict ) y ( dict ) Examples \u00b6 >>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> utils . math . dot ( x , y ) 42","title":"dot"},{"location":"api/utils/math/dot/#dot","text":"Returns the dot product of two vectors represented as dicts.","title":"dot"},{"location":"api/utils/math/dot/#parameters","text":"x ( dict ) y ( dict )","title":"Parameters"},{"location":"api/utils/math/dot/#examples","text":">>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> utils . math . dot ( x , y ) 42","title":"Examples"},{"location":"api/utils/math/dotvecmat/","text":"dotvecmat \u00b6 Vectors times matrix. Parameters \u00b6 x A","title":"dotvecmat"},{"location":"api/utils/math/dotvecmat/#dotvecmat","text":"Vectors times matrix.","title":"dotvecmat"},{"location":"api/utils/math/dotvecmat/#parameters","text":"x A","title":"Parameters"},{"location":"api/utils/math/matmul2d/","text":"matmul2d \u00b6 Multiplication for 2D matrices. Parameters \u00b6 A B Examples \u00b6 >>> import pprint >>> from river import utils >>> A = { ... ( 0 , 0 ): 2 , ( 0 , 1 ): 0 , ( 0 , 2 ): 4 , ... ( 1 , 0 ): 5 , ( 1 , 1 ): 6 , ( 1 , 2 ): 0 ... } >>> B = { ... ( 0 , 0 ): 1 , ( 0 , 1 ): 1 , ( 0 , 2 ): 0 , ( 0 , 3 ): 0 , ... ( 1 , 0 ): 2 , ( 1 , 1 ): 0 , ( 1 , 2 ): 1 , ( 1 , 3 ): 3 , ... ( 2 , 0 ): 4 , ( 2 , 1 ): 0 , ( 2 , 2 ): 0 , ( 2 , 3 ): 0 ... } >>> C = matmul2d ( A , B ) >>> pprint . pprint ( C ) {( 0 , 0 ): 18.0 , ( 0 , 1 ): 2.0 , ( 0 , 2 ): 0.0 , ( 0 , 3 ): 0.0 , ( 1 , 0 ): 17.0 , ( 1 , 1 ): 5.0 , ( 1 , 2 ): 6.0 , ( 1 , 3 ): 18.0 }","title":"matmul2d"},{"location":"api/utils/math/matmul2d/#matmul2d","text":"Multiplication for 2D matrices.","title":"matmul2d"},{"location":"api/utils/math/matmul2d/#parameters","text":"A B","title":"Parameters"},{"location":"api/utils/math/matmul2d/#examples","text":">>> import pprint >>> from river import utils >>> A = { ... ( 0 , 0 ): 2 , ( 0 , 1 ): 0 , ( 0 , 2 ): 4 , ... ( 1 , 0 ): 5 , ( 1 , 1 ): 6 , ( 1 , 2 ): 0 ... } >>> B = { ... ( 0 , 0 ): 1 , ( 0 , 1 ): 1 , ( 0 , 2 ): 0 , ( 0 , 3 ): 0 , ... ( 1 , 0 ): 2 , ( 1 , 1 ): 0 , ( 1 , 2 ): 1 , ( 1 , 3 ): 3 , ... ( 2 , 0 ): 4 , ( 2 , 1 ): 0 , ( 2 , 2 ): 0 , ( 2 , 3 ): 0 ... } >>> C = matmul2d ( A , B ) >>> pprint . pprint ( C ) {( 0 , 0 ): 18.0 , ( 0 , 1 ): 2.0 , ( 0 , 2 ): 0.0 , ( 0 , 3 ): 0.0 , ( 1 , 0 ): 17.0 , ( 1 , 1 ): 5.0 , ( 1 , 2 ): 6.0 , ( 1 , 3 ): 18.0 }","title":"Examples"},{"location":"api/utils/math/minkowski-distance/","text":"minkowski_distance \u00b6 Minkowski distance. Parameters \u00b6 a ( dict ) b ( dict ) p ( int ) Parameter for the Minkowski distance. When p=1 , this is equivalent to using the Manhattan distance. When p=2 , this is equivalent to using the Euclidean distance.","title":"minkowski_distance"},{"location":"api/utils/math/minkowski-distance/#minkowski_distance","text":"Minkowski distance.","title":"minkowski_distance"},{"location":"api/utils/math/minkowski-distance/#parameters","text":"a ( dict ) b ( dict ) p ( int ) Parameter for the Minkowski distance. When p=1 , this is equivalent to using the Manhattan distance. When p=2 , this is equivalent to using the Euclidean distance.","title":"Parameters"},{"location":"api/utils/math/norm/","text":"norm \u00b6 Compute the norm of a dictionaries values. Parameters \u00b6 x ( dict ) order \u2013 defaults to None","title":"norm"},{"location":"api/utils/math/norm/#norm","text":"Compute the norm of a dictionaries values.","title":"norm"},{"location":"api/utils/math/norm/#parameters","text":"x ( dict ) order \u2013 defaults to None","title":"Parameters"},{"location":"api/utils/math/outer/","text":"outer \u00b6 Outer-product between two vectors. Parameters \u00b6 u ( dict ) v ( dict ) Examples \u00b6 >>> import pprint >>> from river import utils >>> u = dict ( enumerate (( 1 , 2 , 3 ))) >>> v = dict ( enumerate (( 2 , 4 , 8 ))) >>> uTv = utils . math . outer ( u , v ) >>> pprint . pprint ( uTv ) {( 0 , 0 ): 2 , ( 0 , 1 ): 4 , ( 0 , 2 ): 8 , ( 1 , 0 ): 4 , ( 1 , 1 ): 8 , ( 1 , 2 ): 16 , ( 2 , 0 ): 6 , ( 2 , 1 ): 12 , ( 2 , 2 ): 24 }","title":"outer"},{"location":"api/utils/math/outer/#outer","text":"Outer-product between two vectors.","title":"outer"},{"location":"api/utils/math/outer/#parameters","text":"u ( dict ) v ( dict )","title":"Parameters"},{"location":"api/utils/math/outer/#examples","text":">>> import pprint >>> from river import utils >>> u = dict ( enumerate (( 1 , 2 , 3 ))) >>> v = dict ( enumerate (( 2 , 4 , 8 ))) >>> uTv = utils . math . outer ( u , v ) >>> pprint . pprint ( uTv ) {( 0 , 0 ): 2 , ( 0 , 1 ): 4 , ( 0 , 2 ): 8 , ( 1 , 0 ): 4 , ( 1 , 1 ): 8 , ( 1 , 2 ): 16 , ( 2 , 0 ): 6 , ( 2 , 1 ): 12 , ( 2 , 2 ): 24 }","title":"Examples"},{"location":"api/utils/math/prod/","text":"prod \u00b6 Product function. Parameters \u00b6 iterable","title":"prod"},{"location":"api/utils/math/prod/#prod","text":"Product function.","title":"prod"},{"location":"api/utils/math/prod/#parameters","text":"iterable","title":"Parameters"},{"location":"api/utils/math/sherman-morrison/","text":"sherman_morrison \u00b6 Sherman\u2013Morrison formula. This modifies A_inv inplace. Parameters \u00b6 A_inv ( dict ) u ( dict ) v ( dict ) Examples \u00b6 >>> import pprint >>> from river import utils >>> A_inv = { ... ( 0 , 0 ): 0.2 , ... ( 1 , 1 ): 1 , ... ( 2 , 2 ): 1 ... } >>> u = { 0 : 1 , 1 : 2 , 2 : 3 } >>> v = { 0 : 4 } >>> inv = sherman_morrison ( A_inv , u , v ) >>> pprint . pprint ( inv ) {( 0 , 0 ): 0.111111 , ( 1 , 0 ): - 0.888888 , ( 1 , 1 ): 1 , ( 2 , 0 ): - 1.333333 , ( 2 , 2 ): 1 } References \u00b6 Wikipedia article on the Sherman-Morrison formula s \u21a9","title":"sherman_morrison"},{"location":"api/utils/math/sherman-morrison/#sherman_morrison","text":"Sherman\u2013Morrison formula. This modifies A_inv inplace.","title":"sherman_morrison"},{"location":"api/utils/math/sherman-morrison/#parameters","text":"A_inv ( dict ) u ( dict ) v ( dict )","title":"Parameters"},{"location":"api/utils/math/sherman-morrison/#examples","text":">>> import pprint >>> from river import utils >>> A_inv = { ... ( 0 , 0 ): 0.2 , ... ( 1 , 1 ): 1 , ... ( 2 , 2 ): 1 ... } >>> u = { 0 : 1 , 1 : 2 , 2 : 3 } >>> v = { 0 : 4 } >>> inv = sherman_morrison ( A_inv , u , v ) >>> pprint . pprint ( inv ) {( 0 , 0 ): 0.111111 , ( 1 , 0 ): - 0.888888 , ( 1 , 1 ): 1 , ( 2 , 0 ): - 1.333333 , ( 2 , 2 ): 1 }","title":"Examples"},{"location":"api/utils/math/sherman-morrison/#references","text":"Wikipedia article on the Sherman-Morrison formula s \u21a9","title":"References"},{"location":"api/utils/math/sigmoid/","text":"sigmoid \u00b6 Sigmoid function. Parameters \u00b6 x ( float )","title":"sigmoid"},{"location":"api/utils/math/sigmoid/#sigmoid","text":"Sigmoid function.","title":"sigmoid"},{"location":"api/utils/math/sigmoid/#parameters","text":"x ( float )","title":"Parameters"},{"location":"api/utils/math/sign/","text":"sign \u00b6 Sign function. Parameters \u00b6 x ( float )","title":"sign"},{"location":"api/utils/math/sign/#sign","text":"Sign function.","title":"sign"},{"location":"api/utils/math/sign/#parameters","text":"x ( float )","title":"Parameters"},{"location":"api/utils/math/softmax/","text":"softmax \u00b6 Normalizes a dictionary of predicted probabilities, in-place. Parameters \u00b6 y_pred ( dict )","title":"softmax"},{"location":"api/utils/math/softmax/#softmax","text":"Normalizes a dictionary of predicted probabilities, in-place.","title":"softmax"},{"location":"api/utils/math/softmax/#parameters","text":"y_pred ( dict )","title":"Parameters"},{"location":"api/utils/pretty/humanize-bytes/","text":"humanize_bytes \u00b6 Returns a human-friendly byte size. Parameters \u00b6 n_bytes ( int )","title":"humanize_bytes"},{"location":"api/utils/pretty/humanize-bytes/#humanize_bytes","text":"Returns a human-friendly byte size.","title":"humanize_bytes"},{"location":"api/utils/pretty/humanize-bytes/#parameters","text":"n_bytes ( int )","title":"Parameters"},{"location":"api/utils/pretty/print-table/","text":"print_table \u00b6 Pretty-prints a table. Parameters \u00b6 headers ( List[str] ) The column names. columns ( List[List[str]] ) The column values. order ( List[int] ) \u2013 defaults to None Order in which to print the column the values. Defaults to the order in which the values are given.","title":"print_table"},{"location":"api/utils/pretty/print-table/#print_table","text":"Pretty-prints a table.","title":"print_table"},{"location":"api/utils/pretty/print-table/#parameters","text":"headers ( List[str] ) The column names. columns ( List[List[str]] ) The column values. order ( List[int] ) \u2013 defaults to None Order in which to print the column the values. Defaults to the order in which the values are given.","title":"Parameters"},{"location":"examples/batch-to-online/","text":"From batch to online/stream \u00b6 A quick overview of batch learning \u00b6 If you've already delved into machine learning, then you shouldn't have any difficulty in getting to use incremental learning. If you are somewhat new to machine learning, then do not worry! The point of this notebook in particular is to introduce simple notions. We'll also start to show how river fits in and explain how to use it. The whole point of machine learning is to learn from data . In supervised learning you want to learn how to predict a target \\(y\\) given a set of features \\(X\\) . Meanwhile in an unsupervised learning there is no target, and the goal is rather to identify patterns and trends in the features \\(X\\) . At this point most people tend to imagine \\(X\\) as a somewhat big table where each row is an observation and each column is a feature, and they would be quite right. Learning from tabular data is part of what's called batch learning , which basically that all of the data is available to our learning algorithm at once. Multiple libraries have been created to handle the batch learning regime, with one of the most prominent being Python's scikit-learn . As a simple example of batch learning let's say we want to learn to predict if a women has breast cancer or not. We'll use the breast cancer dataset available with scikit-learn . We'll learn to map a set of features to a binary decision using a logistic regression . Like many other models based on numerical weights, logisitc regression is sensitive to the scale of the features. Rescaling the data so that each feature has mean 0 and variance 1 is generally considered good practice. We can apply the rescaling and fit the logistic regression sequentially in an elegant manner using a Pipeline . To measure the performance of the model we'll evaluate the average ROC AUC score using a 5 fold cross-validation . from sklearn import datasets from sklearn import linear_model from sklearn import metrics from sklearn import model_selection from sklearn import pipeline from sklearn import preprocessing # Load the data dataset = datasets . load_breast_cancer () X , y = dataset . data , dataset . target # Define the steps of the model model = pipeline . Pipeline ([ ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LogisticRegression ( solver = 'lbfgs' )) ]) # Define a determistic cross-validation procedure cv = model_selection . KFold ( n_splits = 5 , shuffle = True , random_state = 42 ) # Compute the MSE values scorer = metrics . make_scorer ( metrics . roc_auc_score ) scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.975 (\u00b1 0.011) This might be a lot to take in if you're not accustomed to scikit-learn, but it probably isn't if you are. Batch learning basically boils down to: Loading (and preprocessing) the data Fitting a model to the data Computing the performance of the model on unseen data This is pretty standard and is maybe how most people imagine a machine learning pipeline. However, this way of proceeding has certain downsides. First of all your laptop would crash if the load_boston function returned a dataset who's size exceeds your available amount of RAM. Sometimes you can use some tricks to get around this. For example by optimizing the data types and by using sparse representations when applicable you can potentially save precious gigabytes of RAM. However, like many tricks this only goes so far. If your dataset weighs hundreds of gigabytes then you won't go far without some special hardware. One solution is to do out-of-core learning; that is, algorithms that can learn by being presented the data in chunks or mini-batches. If you want to go down this road then take a look at Dask and Spark's MLlib . Another issue with the batch learning regime is that it can't elegantly learn from new data. Indeed if new data is made available, then the model has to learn from scratch with a new dataset composed of the old data and the new data. This is particularly annoying in a real situation where you might have new incoming data every week, day, hour, minute, or even setting. For example if you're building a recommendation engine for an e-commerce app, then you're probably training your model from 0 every week or so. As your app grows in popularity, so does the dataset you're training on. This will lead to longer and longer training times and might require a hardware upgrade. A final downside that isn't very easy to grasp concerns the manner in which features are extracted. Every time you want to train your model you first have to extract features. The trick is that some features might not be accessible at the particular point in time you are at. For example maybe that some attributes in your data warehouse get overwritten with time. In other words maybe that all the features pertaining to a particular observations are not available, whereas they were a week ago. This happens more often than not in real scenarios, and apart if you have a sophisticated data engineering pipeline then you will encounter these issues at some point. A hands-on introduction to incremental learning \u00b6 Incremental learning is also often called online learning or stream learning , but if you google online learning a lot of the results will point to educational websites. Hence, the terms \"incremental learning\" and \"stream learning\" (from which river derives it's name) are prefered. The point of incremental learning is to fit a model to a stream of data. In other words, the data isn't available in it's entirety, but rather the observations are provided one by one. As an example let's stream through the dataset used previously. for xi , yi in zip ( X , y ): # This is where the model learns pass In this case we're iterating over a dataset that is already in memory, but we could just as well stream from a CSV file, a Kafka stream, an SQL query, etc. If we look at xi we can notice that it is a numpy.ndarray . xi array([7.760e+00, 2.454e+01, 4.792e+01, 1.810e+02, 5.263e-02, 4.362e-02, 0.000e+00, 0.000e+00, 1.587e-01, 5.884e-02, 3.857e-01, 1.428e+00, 2.548e+00, 1.915e+01, 7.189e-03, 4.660e-03, 0.000e+00, 0.000e+00, 2.676e-02, 2.783e-03, 9.456e+00, 3.037e+01, 5.916e+01, 2.686e+02, 8.996e-02, 6.444e-02, 0.000e+00, 0.000e+00, 2.871e-01, 7.039e-02]) river by design works with dict s. We believe that dict s are more enjoyable to program with than numpy.ndarray s, at least for when single observations are concerned. dict 's bring the added benefit that each feature can be accessed by name rather than by position. for xi , yi in zip ( X , y ): xi = dict ( zip ( dataset . feature_names , xi )) pass xi {'mean radius': 7.76, 'mean texture': 24.54, 'mean perimeter': 47.92, 'mean area': 181.0, 'mean smoothness': 0.05263, 'mean compactness': 0.04362, 'mean concavity': 0.0, 'mean concave points': 0.0, 'mean symmetry': 0.1587, 'mean fractal dimension': 0.05884, 'radius error': 0.3857, 'texture error': 1.428, 'perimeter error': 2.548, 'area error': 19.15, 'smoothness error': 0.007189, 'compactness error': 0.00466, 'concavity error': 0.0, 'concave points error': 0.0, 'symmetry error': 0.02676, 'fractal dimension error': 0.002783, 'worst radius': 9.456, 'worst texture': 30.37, 'worst perimeter': 59.16, 'worst area': 268.6, 'worst smoothness': 0.08996, 'worst compactness': 0.06444, 'worst concavity': 0.0, 'worst concave points': 0.0, 'worst symmetry': 0.2871, 'worst fractal dimension': 0.07039} Conveniently, river 's stream module has an iter_sklearn_dataset method that we can use instead. from river import stream for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): pass The simple fact that we are getting the data as a stream means that we can't do a lot of things the same way as in a batch setting. For example let's say we want to scale the data so that it has mean 0 and variance 1, as we did earlier. To do so we simply have to subtract the mean of each feature to each value and then divide the result by the standard deviation of the feature. The problem is that we can't possible known the values of the mean and the standard deviation before actually going through all the data! One way to proceed would be to do a first pass over the data to compute the necessary values and then scale the values during a second pass. The problem is that this defeats our purpose, which is to learn by only looking at the data once. Although this might seem rather restrictive, it reaps sizable benefits down the road. The way we do feature scaling in river involves computing running statistics (also know as moving statistics ). The idea is that we use a data structure that estimates the mean and updates itself when it is provided with a value. The same goes for the variance (and thus the standard deviation). For example, if we denote \\(\\mu_t\\) the mean and \\(n_t\\) the count at any moment \\(t\\) , then updating the mean can be done as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\end{cases} \\] Likewise, the running variance can be computed as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\\\ s_{t+1} = s_t + (x - \\mu_t) \\times (x - \\mu_{t+1}) \\\\ \\sigma_{t+1} = \\frac{s_{t+1}}{n_{t+1}} \\end{cases} \\] where \\(s_t\\) is a running sum of squares and \\(\\sigma_t\\) is the running variance at time \\(t\\) . This might seem a tad more involved than the batch algorithms you learn in school, but it is rather elegant. Implementing this in Python is not too difficult. For example let's compute the running mean and variance of the 'mean area' variable. n , mean , sum_of_squares , variance = 0 , 0 , 0 , 0 for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): n += 1 old_mean = mean mean += ( xi [ 'mean area' ] - mean ) / n sum_of_squares += ( xi [ 'mean area' ] - old_mean ) * ( xi [ 'mean area' ] - mean ) variance = sum_of_squares / n print ( f 'Running mean: { mean : .3f } ' ) print ( f 'Running variance: { variance : .3f } ' ) Running mean: 654.889 Running variance: 123625.903 Let's compare this with numpy . But remember, numpy requires access to \"all\" the data. import numpy as np i = list ( dataset . feature_names ) . index ( 'mean area' ) print ( f 'True mean: { np . mean ( X [:, i ]) : .3f } ' ) print ( f 'True variance: { np . var ( X [:, i ]) : .3f } ' ) True mean: 654.889 True variance: 123625.903 The results seem to be exactly the same! The twist is that the running statistics won't be very accurate for the first few observations. In general though this doesn't matter too much. Some would even go as far as to say that this descrepancy is beneficial and acts as some sort of regularization... Now the idea is that we can compute the running statistics of each feature and scale them as they come along. The way to do this with river is to use the StandardScaler class from the preprocessing module, as so: from river import preprocessing scaler = preprocessing . StandardScaler () for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): scaler = scaler . learn_one ( xi ) Now that we are scaling the data, we can start doing some actual machine learning. We're going to implement an online linear regression task. Because all the data isn't available at once, we are obliged to do what is called stochastic gradient descent , which is a popular research topic and has a lot of variants. SGD is commonly used to train neural networks. The idea is that at each step we compute the loss between the target prediction and the truth. We then calculate the gradient, which is simply a set of derivatives with respect to each weight from the linear regression. Once we have obtained the gradient, we can update the weights by moving them in the opposite direction of the gradient. The amount by which the weights are moved typically depends on a learning rate , which is typically set by the user. Different optimizers have different ways of managing the weight update, and some handle the learning rate implicitly. Online linear regression can be done in river with the LinearRegression class from the linear_model module. We'll be using plain and simple SGD using the SGD optimizer from the optim module. During training we'll measure the squared error between the truth and the predictions. from river import linear_model from river import optim scaler = preprocessing . StandardScaler () optimizer = optim . SGD ( lr = 0.01 ) log_reg = linear_model . LogisticRegression ( optimizer ) y_true = [] y_pred = [] for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer (), shuffle = True , seed = 42 ): # Scale the features xi_scaled = scaler . learn_one ( xi ) . transform_one ( xi ) # Test the current model on the new \"unobserved\" sample yi_pred = log_reg . predict_proba_one ( xi_scaled ) # Train the model with the new sample log_reg . learn_one ( xi_scaled , yi ) # Store the truth and the prediction y_true . append ( yi ) y_pred . append ( yi_pred [ True ]) print ( f 'ROC AUC: { metrics . roc_auc_score ( y_true , y_pred ) : .3f } ' ) ROC AUC: 0.990 The ROC AUC is significantly better than the one obtained from the cross-validation of scikit-learn's logisitic regression. However to make things really comparable it would be nice to compare with the same cross-validation procedure. river has a compat module that contains utilities for making river compatible with other Python libraries. Because we're doing regression we'll be using the SKLRegressorWrapper . We'll also be using Pipeline to encapsulate the logic of the StandardScaler and the LogisticRegression in one single object. from river import compat from river import compose # We define a Pipeline, exactly like we did earlier for sklearn model = compose . Pipeline ( ( 'scale' , preprocessing . StandardScaler ()), ( 'log_reg' , linear_model . LogisticRegression ()) ) # We make the Pipeline compatible with sklearn model = compat . convert_river_to_sklearn ( model ) # We compute the CV scores using the same CV scheme and the same scoring scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.964 (\u00b1 0.016) This time the ROC AUC score is lower, which is what we would expect. Indeed online learning isn't as accurate as batch learning. However it all depends in what you're interested in. If you're only interested in predicting the next observation then the online learning regime would be better. That's why it's a bit hard to compare both approaches: they're both suited to different scenarios. Going further \u00b6 Here a few resources if you want to do some reading: Online learning -- Wikipedia What is online machine learning? -- Max Pagels Introduction to Online Learning -- USC course Online Methods in Machine Learning -- MIT course Online Learning: A Comprehensive Survey Streaming 101: The world beyond batch Machine learning for data streams Data Stream Mining: A Practical Approach","title":"From batch to online/stream"},{"location":"examples/batch-to-online/#from-batch-to-onlinestream","text":"","title":"From batch to online/stream"},{"location":"examples/batch-to-online/#a-quick-overview-of-batch-learning","text":"If you've already delved into machine learning, then you shouldn't have any difficulty in getting to use incremental learning. If you are somewhat new to machine learning, then do not worry! The point of this notebook in particular is to introduce simple notions. We'll also start to show how river fits in and explain how to use it. The whole point of machine learning is to learn from data . In supervised learning you want to learn how to predict a target \\(y\\) given a set of features \\(X\\) . Meanwhile in an unsupervised learning there is no target, and the goal is rather to identify patterns and trends in the features \\(X\\) . At this point most people tend to imagine \\(X\\) as a somewhat big table where each row is an observation and each column is a feature, and they would be quite right. Learning from tabular data is part of what's called batch learning , which basically that all of the data is available to our learning algorithm at once. Multiple libraries have been created to handle the batch learning regime, with one of the most prominent being Python's scikit-learn . As a simple example of batch learning let's say we want to learn to predict if a women has breast cancer or not. We'll use the breast cancer dataset available with scikit-learn . We'll learn to map a set of features to a binary decision using a logistic regression . Like many other models based on numerical weights, logisitc regression is sensitive to the scale of the features. Rescaling the data so that each feature has mean 0 and variance 1 is generally considered good practice. We can apply the rescaling and fit the logistic regression sequentially in an elegant manner using a Pipeline . To measure the performance of the model we'll evaluate the average ROC AUC score using a 5 fold cross-validation . from sklearn import datasets from sklearn import linear_model from sklearn import metrics from sklearn import model_selection from sklearn import pipeline from sklearn import preprocessing # Load the data dataset = datasets . load_breast_cancer () X , y = dataset . data , dataset . target # Define the steps of the model model = pipeline . Pipeline ([ ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LogisticRegression ( solver = 'lbfgs' )) ]) # Define a determistic cross-validation procedure cv = model_selection . KFold ( n_splits = 5 , shuffle = True , random_state = 42 ) # Compute the MSE values scorer = metrics . make_scorer ( metrics . roc_auc_score ) scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.975 (\u00b1 0.011) This might be a lot to take in if you're not accustomed to scikit-learn, but it probably isn't if you are. Batch learning basically boils down to: Loading (and preprocessing) the data Fitting a model to the data Computing the performance of the model on unseen data This is pretty standard and is maybe how most people imagine a machine learning pipeline. However, this way of proceeding has certain downsides. First of all your laptop would crash if the load_boston function returned a dataset who's size exceeds your available amount of RAM. Sometimes you can use some tricks to get around this. For example by optimizing the data types and by using sparse representations when applicable you can potentially save precious gigabytes of RAM. However, like many tricks this only goes so far. If your dataset weighs hundreds of gigabytes then you won't go far without some special hardware. One solution is to do out-of-core learning; that is, algorithms that can learn by being presented the data in chunks or mini-batches. If you want to go down this road then take a look at Dask and Spark's MLlib . Another issue with the batch learning regime is that it can't elegantly learn from new data. Indeed if new data is made available, then the model has to learn from scratch with a new dataset composed of the old data and the new data. This is particularly annoying in a real situation where you might have new incoming data every week, day, hour, minute, or even setting. For example if you're building a recommendation engine for an e-commerce app, then you're probably training your model from 0 every week or so. As your app grows in popularity, so does the dataset you're training on. This will lead to longer and longer training times and might require a hardware upgrade. A final downside that isn't very easy to grasp concerns the manner in which features are extracted. Every time you want to train your model you first have to extract features. The trick is that some features might not be accessible at the particular point in time you are at. For example maybe that some attributes in your data warehouse get overwritten with time. In other words maybe that all the features pertaining to a particular observations are not available, whereas they were a week ago. This happens more often than not in real scenarios, and apart if you have a sophisticated data engineering pipeline then you will encounter these issues at some point.","title":"A quick overview of batch learning"},{"location":"examples/batch-to-online/#a-hands-on-introduction-to-incremental-learning","text":"Incremental learning is also often called online learning or stream learning , but if you google online learning a lot of the results will point to educational websites. Hence, the terms \"incremental learning\" and \"stream learning\" (from which river derives it's name) are prefered. The point of incremental learning is to fit a model to a stream of data. In other words, the data isn't available in it's entirety, but rather the observations are provided one by one. As an example let's stream through the dataset used previously. for xi , yi in zip ( X , y ): # This is where the model learns pass In this case we're iterating over a dataset that is already in memory, but we could just as well stream from a CSV file, a Kafka stream, an SQL query, etc. If we look at xi we can notice that it is a numpy.ndarray . xi array([7.760e+00, 2.454e+01, 4.792e+01, 1.810e+02, 5.263e-02, 4.362e-02, 0.000e+00, 0.000e+00, 1.587e-01, 5.884e-02, 3.857e-01, 1.428e+00, 2.548e+00, 1.915e+01, 7.189e-03, 4.660e-03, 0.000e+00, 0.000e+00, 2.676e-02, 2.783e-03, 9.456e+00, 3.037e+01, 5.916e+01, 2.686e+02, 8.996e-02, 6.444e-02, 0.000e+00, 0.000e+00, 2.871e-01, 7.039e-02]) river by design works with dict s. We believe that dict s are more enjoyable to program with than numpy.ndarray s, at least for when single observations are concerned. dict 's bring the added benefit that each feature can be accessed by name rather than by position. for xi , yi in zip ( X , y ): xi = dict ( zip ( dataset . feature_names , xi )) pass xi {'mean radius': 7.76, 'mean texture': 24.54, 'mean perimeter': 47.92, 'mean area': 181.0, 'mean smoothness': 0.05263, 'mean compactness': 0.04362, 'mean concavity': 0.0, 'mean concave points': 0.0, 'mean symmetry': 0.1587, 'mean fractal dimension': 0.05884, 'radius error': 0.3857, 'texture error': 1.428, 'perimeter error': 2.548, 'area error': 19.15, 'smoothness error': 0.007189, 'compactness error': 0.00466, 'concavity error': 0.0, 'concave points error': 0.0, 'symmetry error': 0.02676, 'fractal dimension error': 0.002783, 'worst radius': 9.456, 'worst texture': 30.37, 'worst perimeter': 59.16, 'worst area': 268.6, 'worst smoothness': 0.08996, 'worst compactness': 0.06444, 'worst concavity': 0.0, 'worst concave points': 0.0, 'worst symmetry': 0.2871, 'worst fractal dimension': 0.07039} Conveniently, river 's stream module has an iter_sklearn_dataset method that we can use instead. from river import stream for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): pass The simple fact that we are getting the data as a stream means that we can't do a lot of things the same way as in a batch setting. For example let's say we want to scale the data so that it has mean 0 and variance 1, as we did earlier. To do so we simply have to subtract the mean of each feature to each value and then divide the result by the standard deviation of the feature. The problem is that we can't possible known the values of the mean and the standard deviation before actually going through all the data! One way to proceed would be to do a first pass over the data to compute the necessary values and then scale the values during a second pass. The problem is that this defeats our purpose, which is to learn by only looking at the data once. Although this might seem rather restrictive, it reaps sizable benefits down the road. The way we do feature scaling in river involves computing running statistics (also know as moving statistics ). The idea is that we use a data structure that estimates the mean and updates itself when it is provided with a value. The same goes for the variance (and thus the standard deviation). For example, if we denote \\(\\mu_t\\) the mean and \\(n_t\\) the count at any moment \\(t\\) , then updating the mean can be done as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\end{cases} \\] Likewise, the running variance can be computed as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\\\ s_{t+1} = s_t + (x - \\mu_t) \\times (x - \\mu_{t+1}) \\\\ \\sigma_{t+1} = \\frac{s_{t+1}}{n_{t+1}} \\end{cases} \\] where \\(s_t\\) is a running sum of squares and \\(\\sigma_t\\) is the running variance at time \\(t\\) . This might seem a tad more involved than the batch algorithms you learn in school, but it is rather elegant. Implementing this in Python is not too difficult. For example let's compute the running mean and variance of the 'mean area' variable. n , mean , sum_of_squares , variance = 0 , 0 , 0 , 0 for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): n += 1 old_mean = mean mean += ( xi [ 'mean area' ] - mean ) / n sum_of_squares += ( xi [ 'mean area' ] - old_mean ) * ( xi [ 'mean area' ] - mean ) variance = sum_of_squares / n print ( f 'Running mean: { mean : .3f } ' ) print ( f 'Running variance: { variance : .3f } ' ) Running mean: 654.889 Running variance: 123625.903 Let's compare this with numpy . But remember, numpy requires access to \"all\" the data. import numpy as np i = list ( dataset . feature_names ) . index ( 'mean area' ) print ( f 'True mean: { np . mean ( X [:, i ]) : .3f } ' ) print ( f 'True variance: { np . var ( X [:, i ]) : .3f } ' ) True mean: 654.889 True variance: 123625.903 The results seem to be exactly the same! The twist is that the running statistics won't be very accurate for the first few observations. In general though this doesn't matter too much. Some would even go as far as to say that this descrepancy is beneficial and acts as some sort of regularization... Now the idea is that we can compute the running statistics of each feature and scale them as they come along. The way to do this with river is to use the StandardScaler class from the preprocessing module, as so: from river import preprocessing scaler = preprocessing . StandardScaler () for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): scaler = scaler . learn_one ( xi ) Now that we are scaling the data, we can start doing some actual machine learning. We're going to implement an online linear regression task. Because all the data isn't available at once, we are obliged to do what is called stochastic gradient descent , which is a popular research topic and has a lot of variants. SGD is commonly used to train neural networks. The idea is that at each step we compute the loss between the target prediction and the truth. We then calculate the gradient, which is simply a set of derivatives with respect to each weight from the linear regression. Once we have obtained the gradient, we can update the weights by moving them in the opposite direction of the gradient. The amount by which the weights are moved typically depends on a learning rate , which is typically set by the user. Different optimizers have different ways of managing the weight update, and some handle the learning rate implicitly. Online linear regression can be done in river with the LinearRegression class from the linear_model module. We'll be using plain and simple SGD using the SGD optimizer from the optim module. During training we'll measure the squared error between the truth and the predictions. from river import linear_model from river import optim scaler = preprocessing . StandardScaler () optimizer = optim . SGD ( lr = 0.01 ) log_reg = linear_model . LogisticRegression ( optimizer ) y_true = [] y_pred = [] for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer (), shuffle = True , seed = 42 ): # Scale the features xi_scaled = scaler . learn_one ( xi ) . transform_one ( xi ) # Test the current model on the new \"unobserved\" sample yi_pred = log_reg . predict_proba_one ( xi_scaled ) # Train the model with the new sample log_reg . learn_one ( xi_scaled , yi ) # Store the truth and the prediction y_true . append ( yi ) y_pred . append ( yi_pred [ True ]) print ( f 'ROC AUC: { metrics . roc_auc_score ( y_true , y_pred ) : .3f } ' ) ROC AUC: 0.990 The ROC AUC is significantly better than the one obtained from the cross-validation of scikit-learn's logisitic regression. However to make things really comparable it would be nice to compare with the same cross-validation procedure. river has a compat module that contains utilities for making river compatible with other Python libraries. Because we're doing regression we'll be using the SKLRegressorWrapper . We'll also be using Pipeline to encapsulate the logic of the StandardScaler and the LogisticRegression in one single object. from river import compat from river import compose # We define a Pipeline, exactly like we did earlier for sklearn model = compose . Pipeline ( ( 'scale' , preprocessing . StandardScaler ()), ( 'log_reg' , linear_model . LogisticRegression ()) ) # We make the Pipeline compatible with sklearn model = compat . convert_river_to_sklearn ( model ) # We compute the CV scores using the same CV scheme and the same scoring scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.964 (\u00b1 0.016) This time the ROC AUC score is lower, which is what we would expect. Indeed online learning isn't as accurate as batch learning. However it all depends in what you're interested in. If you're only interested in predicting the next observation then the online learning regime would be better. That's why it's a bit hard to compare both approaches: they're both suited to different scenarios.","title":"A hands-on introduction to incremental learning"},{"location":"examples/batch-to-online/#going-further","text":"Here a few resources if you want to do some reading: Online learning -- Wikipedia What is online machine learning? -- Max Pagels Introduction to Online Learning -- USC course Online Methods in Machine Learning -- MIT course Online Learning: A Comprehensive Survey Streaming 101: The world beyond batch Machine learning for data streams Data Stream Mining: A Practical Approach","title":"Going further"},{"location":"examples/bike-sharing-forecasting/","text":"Bike-sharing forecasting \u00b6 In this tutorial we're going to forecast the number of bikes in 5 bike stations from the city of Toulouse. We'll do so by building a simple model step by step. The dataset contains 182,470 observations. Let's first take a peak at the data. from pprint import pprint from river import datasets X_y = datasets . Bikes () for x , y in X_y : pprint ( x ) print ( f 'Number of available bikes: { y } ' ) break Downloading https://maxhalford.github.io/files/datasets/toulouse_bikes.zip (1.12 MB) Uncompressing into /home/runner/river_data/Bikes {'clouds': 75, 'description': 'light rain', 'humidity': 81, 'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'pressure': 1017.0, 'station': 'metro-canal-du-midi', 'temperature': 6.54, 'wind': 9.3} Number of available bikes: 1 Let's start by using a simple linear regression on the numeric features. We can select the numeric features and discard the rest of the features using a Select . Linear regression is very likely to go haywire if we don't scale the data, so we'll use a StandardScaler to do just that. We'll evaluate the model by measuring the mean absolute error. Finally we'll print the score every 20,000 observations. from river import compose from river import linear_model from river import metrics from river import evaluate from river import preprocessing from river import optim X_y = datasets . Bikes () model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( X_y , model , metric , print_every = 20_000 ) [20,000] MAE: 4.912727 [40,000] MAE: 5.333554 [60,000] MAE: 5.330948 [80,000] MAE: 5.392313 [100,000] MAE: 5.423059 [120,000] MAE: 5.541223 [140,000] MAE: 5.613023 [160,000] MAE: 5.622428 [180,000] MAE: 5.567824 MAE: 5.563893 The model doesn't seem to be doing that well, but then again we didn't provide a lot of features. Generally, a good idea for this kind of problem is to look at an average of the previous values. For example, for each station we can look at the average number of bikes per hour. To do so we first have to extract the hour from the moment field. We can then use a TargetAgg to aggregate the values of the target. from river import feature_extraction from river import stats X_y = iter ( datasets . Bikes ()) def get_hour ( x ): x [ 'hour' ] = x [ 'moment' ] . hour return x model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( X_y , model , metric , print_every = 20_000 ) [20,000] MAE: 3.721246 [40,000] MAE: 3.829972 [60,000] MAE: 3.845068 [80,000] MAE: 3.910259 [100,000] MAE: 3.888652 [120,000] MAE: 3.923727 [140,000] MAE: 3.980953 [160,000] MAE: 3.950034 [180,000] MAE: 3.934545 MAE: 3.933498 By adding a single feature, we've managed to significantly reduce the mean absolute error. At this point you might think that the model is getting slightly complex, and is difficult to understand and test. Pipelines have the advantage of being terse, but they aren't always to debug. Thankfully river has some ways to relieve the pain. The first thing we can do it to draw the pipeline, to get an idea of how the data flows through it. model . draw () We can also use the debug_one method to see what happens to one particular instance. Let's train the model on the first 10,000 observations and then call debug_one on the next one. To do this, we will turn the Bike object into a Python generator with iter() function. The Pythonic way to read the first 10,000 elements of a generator is to use itertools.islice . import itertools X_y = iter ( datasets . Bikes ()) model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () for x , y in itertools . islice ( X_y , 10000 ): y_pred = model . predict_one ( x ) model . learn_one ( x , y ) x , y = next ( X_y ) print ( model . debug_one ( x )) 0. Input -------- clouds: 0 (int) description: clear sky (str) humidity: 52 (int) moment: 2016-04-10 19:03:27 (datetime) pressure: 1,001.00000 (float) station: place-esquirol (str) temperature: 19.00000 (float) wind: 7.70000 (float) 1. Transformer union -------------------- 1.0 Select ---------- clouds: 0 (int) humidity: 52 (int) pressure: 1,001.00000 (float) temperature: 19.00000 (float) wind: 7.70000 (float) 1.1 get_hour | target_mean_by_station_and_hour ---------------------------------------------- target_mean_by_station_and_hour: 7.97175 (float) clouds: 0 (int) humidity: 52 (int) pressure: 1,001.00000 (float) target_mean_by_station_and_hour: 7.97175 (float) temperature: 19.00000 (float) wind: 7.70000 (float) 2. StandardScaler ----------------- clouds: -1.36138 (float) humidity: -1.73083 (float) pressure: -1.26076 (float) target_mean_by_station_and_hour: 0.05496 (float) temperature: 1.76232 (float) wind: 1.45841 (float) 3. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 6.58252 6.58252 temperature 1.76232 2.47030 4.35345 clouds -1.36138 -1.92255 2.61732 target_mean_by_station_and_hour 0.05496 0.54167 0.02977 wind 1.45841 -0.77720 -1.13348 humidity -1.73083 1.44921 -2.50833 pressure -1.26076 3.78529 -4.77234 Prediction: 5.16889 The debug_one method shows what happens to an input set of features, step by step. And now comes the catch. Up until now we've been using the progressive_val_score method from the evaluate module. What this does it that it sequentially predicts the output of an observation and updates the model immediately afterwards. This way of doing is often used for evaluating online learning models, but in some cases it is the wrong approach. The following paragraph is extremely important. When evaluating a machine learning model, the goal is to simulate production conditions in order to get a trust-worthy assessment of the performance of the model. In our case, we typically want to forecast the number of bikes available in a station, say, 30 minutes ahead. Then, once the 30 minutes have passed, the true number of available bikes will be available and we will be able to update the model using the features available 30 minutes ago. If you think about, this is exactly how a real-time machine learning system should work. The problem is that this isn't what the progressive_val_score method is emulating, indeed it is simply asking the model to predict the next observation, which is only a few minutes ahead, and then updates the model immediately. We can prove that this is flawed by adding a feature that measures a running average of the very recent values. X_y = datasets . Bikes () model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ( 0.5 )) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () metric = metrics . MAE () evaluate . progressive_val_score ( X_y , model , metric , print_every = 20_000 ) [20,000] MAE: 20.159286 [40,000] MAE: 10.458898 [60,000] MAE: 7.2759 [80,000] MAE: 5.715397 [100,000] MAE: 4.775094 [120,000] MAE: 4.138421 [140,000] MAE: 3.682591 [160,000] MAE: 3.35015 [180,000] MAE: 3.091398 MAE: 3.06414 The score we got is too good to be true. This is simply because the problem is too easy. What we really want is to evaluate the model by forecasting 30 minutes ahead and only updating the model once the true values are available. This can be done using the moment and delay parameters in the progressive_val_score method. The idea is that each observation of the stream of the data is shown twice to the model: once for making a prediction, and once for updating the model when the true value is revealed. The moment parameter determines which variable should be used as a timestamp, while the delay parameter controls the duration to wait before revealing the true values to the model. import datetime as dt model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ( 0.5 )) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( dataset = datasets . Bikes (), model = model , metric = metrics . MAE (), moment = 'moment' , delay = dt . timedelta ( minutes = 30 ), print_every = 20_000 ) [20,000] MAE: 2.24812 [40,000] MAE: 2.240287 [60,000] MAE: 2.270287 [80,000] MAE: 2.28649 [100,000] MAE: 2.294264 [120,000] MAE: 2.275891 [140,000] MAE: 2.261411 [160,000] MAE: 2.285978 [180,000] MAE: 2.289353 MAE: 2.29304 The score we now have is much more realistic, as it is comparable with the related data science competition . Moreover, we can see that the model gets better with time, which feels better than the previous situations. The point is that progressive_val_score method can be used to simulate a production scenario, and is thus extremely valuable. Now that we have a working pipeline in place, we can attempt to make it more accurate. As a simple example, we'll using a EWARegressor from the expert module to combine 3 linear regression model trained with different optimizers. The EWARegressor will run the 3 models in parallel and assign weights to each model based on their individual performance. from river import expert from river import optim model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model += feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ( 0.5 )) model |= preprocessing . StandardScaler () model |= expert . EWARegressor ([ linear_model . LinearRegression ( optim . SGD ()), linear_model . LinearRegression ( optim . RMSProp ()), linear_model . LinearRegression ( optim . Adam ()) ]) evaluate . progressive_val_score ( dataset = datasets . Bikes (), model = model , metric = metrics . MAE (), moment = 'moment' , delay = dt . timedelta ( minutes = 30 ), print_every = 20_000 ) [20,000] MAE: 2.253263 [40,000] MAE: 2.242859 [60,000] MAE: 2.272001 [80,000] MAE: 2.287776 [100,000] MAE: 2.295292 [120,000] MAE: 2.276748 [140,000] MAE: 2.262146 [160,000] MAE: 2.286621 [180,000] MAE: 2.289925 MAE: 2.293604","title":"Bike-sharing forecasting"},{"location":"examples/bike-sharing-forecasting/#bike-sharing-forecasting","text":"In this tutorial we're going to forecast the number of bikes in 5 bike stations from the city of Toulouse. We'll do so by building a simple model step by step. The dataset contains 182,470 observations. Let's first take a peak at the data. from pprint import pprint from river import datasets X_y = datasets . Bikes () for x , y in X_y : pprint ( x ) print ( f 'Number of available bikes: { y } ' ) break Downloading https://maxhalford.github.io/files/datasets/toulouse_bikes.zip (1.12 MB) Uncompressing into /home/runner/river_data/Bikes {'clouds': 75, 'description': 'light rain', 'humidity': 81, 'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'pressure': 1017.0, 'station': 'metro-canal-du-midi', 'temperature': 6.54, 'wind': 9.3} Number of available bikes: 1 Let's start by using a simple linear regression on the numeric features. We can select the numeric features and discard the rest of the features using a Select . Linear regression is very likely to go haywire if we don't scale the data, so we'll use a StandardScaler to do just that. We'll evaluate the model by measuring the mean absolute error. Finally we'll print the score every 20,000 observations. from river import compose from river import linear_model from river import metrics from river import evaluate from river import preprocessing from river import optim X_y = datasets . Bikes () model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( X_y , model , metric , print_every = 20_000 ) [20,000] MAE: 4.912727 [40,000] MAE: 5.333554 [60,000] MAE: 5.330948 [80,000] MAE: 5.392313 [100,000] MAE: 5.423059 [120,000] MAE: 5.541223 [140,000] MAE: 5.613023 [160,000] MAE: 5.622428 [180,000] MAE: 5.567824 MAE: 5.563893 The model doesn't seem to be doing that well, but then again we didn't provide a lot of features. Generally, a good idea for this kind of problem is to look at an average of the previous values. For example, for each station we can look at the average number of bikes per hour. To do so we first have to extract the hour from the moment field. We can then use a TargetAgg to aggregate the values of the target. from river import feature_extraction from river import stats X_y = iter ( datasets . Bikes ()) def get_hour ( x ): x [ 'hour' ] = x [ 'moment' ] . hour return x model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( X_y , model , metric , print_every = 20_000 ) [20,000] MAE: 3.721246 [40,000] MAE: 3.829972 [60,000] MAE: 3.845068 [80,000] MAE: 3.910259 [100,000] MAE: 3.888652 [120,000] MAE: 3.923727 [140,000] MAE: 3.980953 [160,000] MAE: 3.950034 [180,000] MAE: 3.934545 MAE: 3.933498 By adding a single feature, we've managed to significantly reduce the mean absolute error. At this point you might think that the model is getting slightly complex, and is difficult to understand and test. Pipelines have the advantage of being terse, but they aren't always to debug. Thankfully river has some ways to relieve the pain. The first thing we can do it to draw the pipeline, to get an idea of how the data flows through it. model . draw () We can also use the debug_one method to see what happens to one particular instance. Let's train the model on the first 10,000 observations and then call debug_one on the next one. To do this, we will turn the Bike object into a Python generator with iter() function. The Pythonic way to read the first 10,000 elements of a generator is to use itertools.islice . import itertools X_y = iter ( datasets . Bikes ()) model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () for x , y in itertools . islice ( X_y , 10000 ): y_pred = model . predict_one ( x ) model . learn_one ( x , y ) x , y = next ( X_y ) print ( model . debug_one ( x )) 0. Input -------- clouds: 0 (int) description: clear sky (str) humidity: 52 (int) moment: 2016-04-10 19:03:27 (datetime) pressure: 1,001.00000 (float) station: place-esquirol (str) temperature: 19.00000 (float) wind: 7.70000 (float) 1. Transformer union -------------------- 1.0 Select ---------- clouds: 0 (int) humidity: 52 (int) pressure: 1,001.00000 (float) temperature: 19.00000 (float) wind: 7.70000 (float) 1.1 get_hour | target_mean_by_station_and_hour ---------------------------------------------- target_mean_by_station_and_hour: 7.97175 (float) clouds: 0 (int) humidity: 52 (int) pressure: 1,001.00000 (float) target_mean_by_station_and_hour: 7.97175 (float) temperature: 19.00000 (float) wind: 7.70000 (float) 2. StandardScaler ----------------- clouds: -1.36138 (float) humidity: -1.73083 (float) pressure: -1.26076 (float) target_mean_by_station_and_hour: 0.05496 (float) temperature: 1.76232 (float) wind: 1.45841 (float) 3. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 6.58252 6.58252 temperature 1.76232 2.47030 4.35345 clouds -1.36138 -1.92255 2.61732 target_mean_by_station_and_hour 0.05496 0.54167 0.02977 wind 1.45841 -0.77720 -1.13348 humidity -1.73083 1.44921 -2.50833 pressure -1.26076 3.78529 -4.77234 Prediction: 5.16889 The debug_one method shows what happens to an input set of features, step by step. And now comes the catch. Up until now we've been using the progressive_val_score method from the evaluate module. What this does it that it sequentially predicts the output of an observation and updates the model immediately afterwards. This way of doing is often used for evaluating online learning models, but in some cases it is the wrong approach. The following paragraph is extremely important. When evaluating a machine learning model, the goal is to simulate production conditions in order to get a trust-worthy assessment of the performance of the model. In our case, we typically want to forecast the number of bikes available in a station, say, 30 minutes ahead. Then, once the 30 minutes have passed, the true number of available bikes will be available and we will be able to update the model using the features available 30 minutes ago. If you think about, this is exactly how a real-time machine learning system should work. The problem is that this isn't what the progressive_val_score method is emulating, indeed it is simply asking the model to predict the next observation, which is only a few minutes ahead, and then updates the model immediately. We can prove that this is flawed by adding a feature that measures a running average of the very recent values. X_y = datasets . Bikes () model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ( 0.5 )) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () metric = metrics . MAE () evaluate . progressive_val_score ( X_y , model , metric , print_every = 20_000 ) [20,000] MAE: 20.159286 [40,000] MAE: 10.458898 [60,000] MAE: 7.2759 [80,000] MAE: 5.715397 [100,000] MAE: 4.775094 [120,000] MAE: 4.138421 [140,000] MAE: 3.682591 [160,000] MAE: 3.35015 [180,000] MAE: 3.091398 MAE: 3.06414 The score we got is too good to be true. This is simply because the problem is too easy. What we really want is to evaluate the model by forecasting 30 minutes ahead and only updating the model once the true values are available. This can be done using the moment and delay parameters in the progressive_val_score method. The idea is that each observation of the stream of the data is shown twice to the model: once for making a prediction, and once for updating the model when the true value is revealed. The moment parameter determines which variable should be used as a timestamp, while the delay parameter controls the duration to wait before revealing the true values to the model. import datetime as dt model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ( 0.5 )) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( dataset = datasets . Bikes (), model = model , metric = metrics . MAE (), moment = 'moment' , delay = dt . timedelta ( minutes = 30 ), print_every = 20_000 ) [20,000] MAE: 2.24812 [40,000] MAE: 2.240287 [60,000] MAE: 2.270287 [80,000] MAE: 2.28649 [100,000] MAE: 2.294264 [120,000] MAE: 2.275891 [140,000] MAE: 2.261411 [160,000] MAE: 2.285978 [180,000] MAE: 2.289353 MAE: 2.29304 The score we now have is much more realistic, as it is comparable with the related data science competition . Moreover, we can see that the model gets better with time, which feels better than the previous situations. The point is that progressive_val_score method can be used to simulate a production scenario, and is thus extremely valuable. Now that we have a working pipeline in place, we can attempt to make it more accurate. As a simple example, we'll using a EWARegressor from the expert module to combine 3 linear regression model trained with different optimizers. The EWARegressor will run the 3 models in parallel and assign weights to each model based on their individual performance. from river import expert from river import optim model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model += feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ( 0.5 )) model |= preprocessing . StandardScaler () model |= expert . EWARegressor ([ linear_model . LinearRegression ( optim . SGD ()), linear_model . LinearRegression ( optim . RMSProp ()), linear_model . LinearRegression ( optim . Adam ()) ]) evaluate . progressive_val_score ( dataset = datasets . Bikes (), model = model , metric = metrics . MAE (), moment = 'moment' , delay = dt . timedelta ( minutes = 30 ), print_every = 20_000 ) [20,000] MAE: 2.253263 [40,000] MAE: 2.242859 [60,000] MAE: 2.272001 [80,000] MAE: 2.287776 [100,000] MAE: 2.295292 [120,000] MAE: 2.276748 [140,000] MAE: 2.262146 [160,000] MAE: 2.286621 [180,000] MAE: 2.289925 MAE: 2.293604","title":"Bike-sharing forecasting"},{"location":"examples/building-a-simple-time-series-model/","text":"Building a simple time series model \u00b6 % matplotlib inline We'll be using the international airline passenger data available from here . This particular dataset is included with river in the datasets module. from river import datasets for x , y in datasets . AirlinePassengers (): print ( x , y ) break {'month': datetime.datetime(1949, 1, 1, 0, 0)} 112 The data is as simple as can be: it consists of a sequence of months and values representing the total number of international airline passengers per month. Our goal is going to be to predict the number of passengers for the next month at each step. Notice that because the dataset is small -- which is usually the case for time series -- we could just fit a model from scratch each month. However for the sake of example we're going to train a single model online. Although the overall performance might be potentially weaker, training a time series model online has the benefit of being scalable if, say, you have have thousands of time series to manage . We'll start with a very simple model where the only feature will be the ordinal date of each month. This should be able to capture some of the underlying trend. from river import compose from river import linear_model from river import preprocessing def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) We'll write down a function to evaluate the model. This will go through each observation in the dataset and update the model as it goes on. The prior predictions will be stored along with the true values and will be plotted together. from river import metrics import matplotlib.pyplot as plt def evaluate_model ( model ): metric = metrics . Rolling ( metrics . MAE (), 12 ) dates = [] y_trues = [] y_preds = [] for x , y in datasets . AirlinePassengers (): # Obtain the prior prediction and update the model in one go y_pred = model . predict_one ( x ) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_pred ) # Store the true value and the prediction dates . append ( x [ 'month' ]) y_trues . append ( y ) y_preds . append ( y_pred ) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Ground truth' ) ax . plot ( dates , y_preds , lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . legend () ax . set_title ( metric ) Let's evaluate our first model. evaluate_model ( model ) The model has captured a trend but not the right one. Indeed it thinks the trend is linear whereas we can visually see that the growth of the data increases with time. In other words the second derivative of the series is positive. This is a well know problem in time series forecasting and there are thus many ways to handle it; for example by using a Box-Cox transform . However we are going to do something a bit different, and instead linearly detrend the series using a Detrender . We'll set window_size to 12 in order to use a rolling mean of size 12 for detrending. The Detrender will center the target in 0, which means that we don't need an intercept in our linear regression. We can thus set intercept_lr to 0. from river import stats from river import time_series model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )), ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) Now let's try and capture the monthly trend by one-hot encoding the month name. import calendar def get_month ( x ): return { calendar . month_name [ month ]: month == x [ 'month' ] . month for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )) ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) This seems pretty decent. We can take a look at the weights of the linear regression to get an idea of the importance of each feature. model . regressor [ 'lin_reg' ] . weights {'January': -9.469216150196292, 'February': -14.616539494085554, 'March': -3.543831579749453, 'April': -2.766323821459067, 'May': -0.6224556651312263, 'June': 13.478341968972643, 'July': 28.772701948655836, 'August': 26.88560005378563, 'September': 4.707302312777268, 'October': -8.705184336916485, 'November': -22.48440069047625, 'December': -13.372426538578132, 'ordinal_date': 13.829969822169433} As could be expected the months of July and August have the highest weights because these are the months where people typically go on holiday abroad. The month of December has a low weight because this is a month of festivities in most of the Western world where people usually stay at home. Our model seems to understand which months are important, but it fails to see that the importance of each month grows multiplicatively as the years go on. In other words our model is too shy. We can fix this by increasing the learning rate of the LinearRegression 's optimizer. from river import optim model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) This is starting to look good! Naturally in production we would tune the learning rate, ideally in real-time. Before finishing, we're going to introduce a cool feature extraction trick based on radial basis function kernels . The one-hot encoding we did on the month is a good idea but if you think about it is a bit rigid. Indeed the value of each feature is going to be 0 or 1, depending on the month of each observation. We're basically saying that the month of September is as distant to the month of August as it is to the month of March. Of course this isn't true, and it would be nice if our features would reflect this. To do so we can simply calculate the distance between the month of each observation and all the months in the calendar. Instead of simply computing the distance linearly, we're going to use a so-called Gaussian radial basic function kernel . This is a bit of a mouthful but for us it boils down to a simple formula, which is: \\[d(i, j) = exp(-\\frac{(i - j)^2}{2\\sigma^2})\\] Intuitively this computes a similarity between two months -- denoted by \\(i\\) and \\(j\\) -- which decreases the further apart they are from each other. The \\(sigma\\) parameter can be seen as a hyperparameter than can be tuned -- in the following snippet we'll simply ignore it. The thing to take away is that this results in smoother predictions than when using a one-hot encoding scheme, which is often a desirable property. You can also see trick in action in this nice presentation . import math def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month_distances' , compose . FuncTransformer ( get_month_distances )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) We've managed to get a good looking prediction curve with a reasonably simple model. What's more our model has the advantage of being interpretable and easy to debug. There surely are more rocks to squeeze (e.g. tune the hyperparameters, use an ensemble model, etc.) but we'll leave that as an exercice to the reader. As a finishing touch we'll rewrite our pipeline using the | operator, which is called a \"pipe\". extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) ) model = extract_features | scale | learn model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model )","title":"Building a simple time series model"},{"location":"examples/building-a-simple-time-series-model/#building-a-simple-time-series-model","text":"% matplotlib inline We'll be using the international airline passenger data available from here . This particular dataset is included with river in the datasets module. from river import datasets for x , y in datasets . AirlinePassengers (): print ( x , y ) break {'month': datetime.datetime(1949, 1, 1, 0, 0)} 112 The data is as simple as can be: it consists of a sequence of months and values representing the total number of international airline passengers per month. Our goal is going to be to predict the number of passengers for the next month at each step. Notice that because the dataset is small -- which is usually the case for time series -- we could just fit a model from scratch each month. However for the sake of example we're going to train a single model online. Although the overall performance might be potentially weaker, training a time series model online has the benefit of being scalable if, say, you have have thousands of time series to manage . We'll start with a very simple model where the only feature will be the ordinal date of each month. This should be able to capture some of the underlying trend. from river import compose from river import linear_model from river import preprocessing def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) We'll write down a function to evaluate the model. This will go through each observation in the dataset and update the model as it goes on. The prior predictions will be stored along with the true values and will be plotted together. from river import metrics import matplotlib.pyplot as plt def evaluate_model ( model ): metric = metrics . Rolling ( metrics . MAE (), 12 ) dates = [] y_trues = [] y_preds = [] for x , y in datasets . AirlinePassengers (): # Obtain the prior prediction and update the model in one go y_pred = model . predict_one ( x ) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_pred ) # Store the true value and the prediction dates . append ( x [ 'month' ]) y_trues . append ( y ) y_preds . append ( y_pred ) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Ground truth' ) ax . plot ( dates , y_preds , lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . legend () ax . set_title ( metric ) Let's evaluate our first model. evaluate_model ( model ) The model has captured a trend but not the right one. Indeed it thinks the trend is linear whereas we can visually see that the growth of the data increases with time. In other words the second derivative of the series is positive. This is a well know problem in time series forecasting and there are thus many ways to handle it; for example by using a Box-Cox transform . However we are going to do something a bit different, and instead linearly detrend the series using a Detrender . We'll set window_size to 12 in order to use a rolling mean of size 12 for detrending. The Detrender will center the target in 0, which means that we don't need an intercept in our linear regression. We can thus set intercept_lr to 0. from river import stats from river import time_series model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )), ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) Now let's try and capture the monthly trend by one-hot encoding the month name. import calendar def get_month ( x ): return { calendar . month_name [ month ]: month == x [ 'month' ] . month for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )) ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) This seems pretty decent. We can take a look at the weights of the linear regression to get an idea of the importance of each feature. model . regressor [ 'lin_reg' ] . weights {'January': -9.469216150196292, 'February': -14.616539494085554, 'March': -3.543831579749453, 'April': -2.766323821459067, 'May': -0.6224556651312263, 'June': 13.478341968972643, 'July': 28.772701948655836, 'August': 26.88560005378563, 'September': 4.707302312777268, 'October': -8.705184336916485, 'November': -22.48440069047625, 'December': -13.372426538578132, 'ordinal_date': 13.829969822169433} As could be expected the months of July and August have the highest weights because these are the months where people typically go on holiday abroad. The month of December has a low weight because this is a month of festivities in most of the Western world where people usually stay at home. Our model seems to understand which months are important, but it fails to see that the importance of each month grows multiplicatively as the years go on. In other words our model is too shy. We can fix this by increasing the learning rate of the LinearRegression 's optimizer. from river import optim model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) This is starting to look good! Naturally in production we would tune the learning rate, ideally in real-time. Before finishing, we're going to introduce a cool feature extraction trick based on radial basis function kernels . The one-hot encoding we did on the month is a good idea but if you think about it is a bit rigid. Indeed the value of each feature is going to be 0 or 1, depending on the month of each observation. We're basically saying that the month of September is as distant to the month of August as it is to the month of March. Of course this isn't true, and it would be nice if our features would reflect this. To do so we can simply calculate the distance between the month of each observation and all the months in the calendar. Instead of simply computing the distance linearly, we're going to use a so-called Gaussian radial basic function kernel . This is a bit of a mouthful but for us it boils down to a simple formula, which is: \\[d(i, j) = exp(-\\frac{(i - j)^2}{2\\sigma^2})\\] Intuitively this computes a similarity between two months -- denoted by \\(i\\) and \\(j\\) -- which decreases the further apart they are from each other. The \\(sigma\\) parameter can be seen as a hyperparameter than can be tuned -- in the following snippet we'll simply ignore it. The thing to take away is that this results in smoother predictions than when using a one-hot encoding scheme, which is often a desirable property. You can also see trick in action in this nice presentation . import math def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month_distances' , compose . FuncTransformer ( get_month_distances )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model ) We've managed to get a good looking prediction curve with a reasonably simple model. What's more our model has the advantage of being interpretable and easy to debug. There surely are more rocks to squeeze (e.g. tune the hyperparameters, use an ensemble model, etc.) but we'll leave that as an exercice to the reader. As a finishing touch we'll rewrite our pipeline using the | operator, which is called a \"pipe\". extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) ) model = extract_features | scale | learn model = time_series . Detrender ( regressor = model , window_size = 12 ) evaluate_model ( model )","title":"Building a simple time series model"},{"location":"examples/concept-drift-detection/","text":"Concept Drift \u00b6 In the context of data streams, it is assumed that data can change over time. The change in the relationship between the data (features) and the target to learn is known as Concept Drift . As examples we can mention, the electricity demand across the year, the stock market, and the likelihood of a new movie to be successful. Let's consider the movie example: Two movies can have similar features such as popular actors/directors, storyline, production budget, marketing campaigns, etc. yet it is not certain that both will be similarly successful. What the target audience considers worth watching (and their money) is constantly changing and production companies must adapt accordingly to avoid \"box office flops\". Impact of drift on learning \u00b6 Concept drift can have a significant impact on predictive performance if not handled properly. Most batch learning models will fail in the presence of concept drift as they are essentially trained on different data. On the other hand, stream learning methods continuously update themselves and adapt to new concepts. Furthermore, drift-aware methods use change detection methods (a.k.a. drift detectors) to trigger mitigation mechanisms if a change in performance is detected. Detecting concept drift \u00b6 Multiple drift detection methods have been proposed. The goal of a drift detector is to signal an alarm in the presence of drift. A good drift detector maximizes the number of true positives while keeping the number of false positives to a minimum. It must also be resource-wise efficient to work in the context of infinite data streams. For this example, we will generate a synthetic data stream by concatenating 3 distributions of 1000 samples each: \\(dist_a\\) : \\(\\mu=0.8\\) , \\(\\sigma=0.05\\) \\(dist_b\\) : \\(\\mu=0.4\\) , \\(\\sigma=0.02\\) \\(dist_c\\) : \\(\\mu=0.6\\) , \\(\\sigma=0.1\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib import gridspec # Generate data for 3 distributions random_state = np . random . RandomState ( seed = 42 ) dist_a = random_state . normal ( 0.8 , 0.05 , 1000 ) dist_b = random_state . normal ( 0.4 , 0.02 , 1000 ) dist_c = random_state . normal ( 0.6 , 0.1 , 1000 ) # Concatenate data to simulate a data stream with 2 drifts stream = np . concatenate (( dist_a , dist_b , dist_c )) # Auxiliary function to plot the data def plot_data ( dist_a , dist_b , dist_c , drifts = None ): fig = plt . figure ( figsize = ( 7 , 3 ), tight_layout = True ) gs = gridspec . GridSpec ( 1 , 2 , width_ratios = [ 3 , 1 ]) ax1 , ax2 = plt . subplot ( gs [ 0 ]), plt . subplot ( gs [ 1 ]) ax1 . grid () ax1 . plot ( stream , label = 'Stream' ) ax2 . grid ( axis = 'y' ) ax2 . hist ( dist_a , label = r '$dist_a$' ) ax2 . hist ( dist_b , label = r '$dist_b$' ) ax2 . hist ( dist_c , label = r '$dist_c$' ) if drifts is not None : for drift_detected in drifts : ax1 . axvline ( drift_detected , color = 'red' ) plt . show () plot_data ( dist_a , dist_b , dist_c ) Drift detection test \u00b6 We will use the ADaptive WINdowing ( ADWIN ) drift detection method. Remember that the goal is to indicate that drift has occurred after samples 1000 and 2000 in the synthetic data stream. from river import drift drift_detector = drift . ADWIN () drifts = [] for i , val in enumerate ( stream ): drift_detector . update ( val ) # Data is processed one sample at a time if drift_detector . change_detected : # The drift detector indicates after each sample if there is a drift in the data print ( f 'Change detected at index { i } ' ) drifts . append ( i ) drift_detector . reset () # As a best practice, we reset the detector plot_data ( dist_a , dist_b , dist_c , drifts ) Change detected at index 1055 Change detected at index 2079 We see that ADWIN successfully indicates the presence of drift (red vertical lines) close to the begining of a new data distribution. We conclude this example with some remarks regarding concept drift detectors and their usage: In practice, drift detectors provide stream learning methods with robustness against concept drift. Drift detectors monitor the model usually through a performance metric. Drift detectors work on univariate data. This is why they are used to monitor a model's performance and not the data itself. Remember that concept drift is defined as a change in the relationship between data and the target to learn (in supervised learning). Drift detectors define their expectations regarding input data. It is important to know these expectations to feed a given drift detector with the correct data.","title":"Concept Drift"},{"location":"examples/concept-drift-detection/#concept-drift","text":"In the context of data streams, it is assumed that data can change over time. The change in the relationship between the data (features) and the target to learn is known as Concept Drift . As examples we can mention, the electricity demand across the year, the stock market, and the likelihood of a new movie to be successful. Let's consider the movie example: Two movies can have similar features such as popular actors/directors, storyline, production budget, marketing campaigns, etc. yet it is not certain that both will be similarly successful. What the target audience considers worth watching (and their money) is constantly changing and production companies must adapt accordingly to avoid \"box office flops\".","title":"Concept Drift"},{"location":"examples/concept-drift-detection/#impact-of-drift-on-learning","text":"Concept drift can have a significant impact on predictive performance if not handled properly. Most batch learning models will fail in the presence of concept drift as they are essentially trained on different data. On the other hand, stream learning methods continuously update themselves and adapt to new concepts. Furthermore, drift-aware methods use change detection methods (a.k.a. drift detectors) to trigger mitigation mechanisms if a change in performance is detected.","title":"Impact of drift on learning"},{"location":"examples/concept-drift-detection/#detecting-concept-drift","text":"Multiple drift detection methods have been proposed. The goal of a drift detector is to signal an alarm in the presence of drift. A good drift detector maximizes the number of true positives while keeping the number of false positives to a minimum. It must also be resource-wise efficient to work in the context of infinite data streams. For this example, we will generate a synthetic data stream by concatenating 3 distributions of 1000 samples each: \\(dist_a\\) : \\(\\mu=0.8\\) , \\(\\sigma=0.05\\) \\(dist_b\\) : \\(\\mu=0.4\\) , \\(\\sigma=0.02\\) \\(dist_c\\) : \\(\\mu=0.6\\) , \\(\\sigma=0.1\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib import gridspec # Generate data for 3 distributions random_state = np . random . RandomState ( seed = 42 ) dist_a = random_state . normal ( 0.8 , 0.05 , 1000 ) dist_b = random_state . normal ( 0.4 , 0.02 , 1000 ) dist_c = random_state . normal ( 0.6 , 0.1 , 1000 ) # Concatenate data to simulate a data stream with 2 drifts stream = np . concatenate (( dist_a , dist_b , dist_c )) # Auxiliary function to plot the data def plot_data ( dist_a , dist_b , dist_c , drifts = None ): fig = plt . figure ( figsize = ( 7 , 3 ), tight_layout = True ) gs = gridspec . GridSpec ( 1 , 2 , width_ratios = [ 3 , 1 ]) ax1 , ax2 = plt . subplot ( gs [ 0 ]), plt . subplot ( gs [ 1 ]) ax1 . grid () ax1 . plot ( stream , label = 'Stream' ) ax2 . grid ( axis = 'y' ) ax2 . hist ( dist_a , label = r '$dist_a$' ) ax2 . hist ( dist_b , label = r '$dist_b$' ) ax2 . hist ( dist_c , label = r '$dist_c$' ) if drifts is not None : for drift_detected in drifts : ax1 . axvline ( drift_detected , color = 'red' ) plt . show () plot_data ( dist_a , dist_b , dist_c )","title":"Detecting concept drift"},{"location":"examples/concept-drift-detection/#drift-detection-test","text":"We will use the ADaptive WINdowing ( ADWIN ) drift detection method. Remember that the goal is to indicate that drift has occurred after samples 1000 and 2000 in the synthetic data stream. from river import drift drift_detector = drift . ADWIN () drifts = [] for i , val in enumerate ( stream ): drift_detector . update ( val ) # Data is processed one sample at a time if drift_detector . change_detected : # The drift detector indicates after each sample if there is a drift in the data print ( f 'Change detected at index { i } ' ) drifts . append ( i ) drift_detector . reset () # As a best practice, we reset the detector plot_data ( dist_a , dist_b , dist_c , drifts ) Change detected at index 1055 Change detected at index 2079 We see that ADWIN successfully indicates the presence of drift (red vertical lines) close to the begining of a new data distribution. We conclude this example with some remarks regarding concept drift detectors and their usage: In practice, drift detectors provide stream learning methods with robustness against concept drift. Drift detectors monitor the model usually through a performance metric. Drift detectors work on univariate data. This is why they are used to monitor a model's performance and not the data itself. Remember that concept drift is defined as a change in the relationship between data and the target to learn (in supervised learning). Drift detectors define their expectations regarding input data. It is important to know these expectations to feed a given drift detector with the correct data.","title":"Drift detection test"},{"location":"examples/debugging-a-pipeline/","text":"Debugging a pipeline \u00b6 river encourages users to make use of pipelines. The biggest pain point of pipelines is that it can be hard to understand what's happening to the data, especially when the pipeline is complex. Fortunately the Pipeline class has a debug_one method that can help out. Let's look at a fairly complex pipeline for predicting the number of bikes in 5 bike stations from the city of Toulouse. It doesn't matter if you understand the pipeline or not; the point of this notebook is to learn how to introspect a pipeline. import datetime as dt from river import compose from river import datasets from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats from river import stream X_y = datasets . Bikes () X_y = stream . simulate_qa ( X_y , moment = 'moment' , delay = dt . timedelta ( minutes = 30 )) def add_time_features ( x ): return { ** x , 'hour' : x [ 'moment' ] . hour , 'day' : x [ 'moment' ] . weekday () } model = add_time_features model |= ( compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) + feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () metric = metrics . MAE () questions = {} for i , x , y in X_y : # Question is_question = y is None if is_question : y_pred = model . predict_one ( x ) questions [ i ] = y_pred # Answer else : metric . update ( y , questions [ i ]) model = model . learn_one ( x , y ) if i >= 30000 and i % 30000 == 0 : print ( i , metric ) 30000 MAE: 2.220942 60000 MAE: 2.270271 90000 MAE: 2.301302 120000 MAE: 2.275876 150000 MAE: 2.275224 180000 MAE: 2.289347 We can start by looking at what the pipeline looks by drawing it. model . draw () As mentioned above the Pipeline class has a debug_one method. You can use this at any point you want to visualize what happen to an input x . For example, let's see what happens to the last seen x . model . debug_one ( x ) '0. Input\\n--------\\nclouds: 88 (int)\\ndescription: overcast clouds (str)\\nhumidity: 84 (int)\\nmoment: 2016-10-05 09:57:18 (datetime)\\npressure: 1,017.34000 (float)\\nstation: pomme (str)\\ntemperature: 17.45000 (float)\\nwind: 1.95000 (float)\\n\\n1. add_time_features\\n--------------------\\nclouds: 88 (int)\\nday: 2 (int)\\ndescription: overcast clouds (str)\\nhour: 9 (int)\\nhumidity: 84 (int)\\nmoment: 2016-10-05 09:57:18 (datetime)\\npressure: 1,017.34000 (float)\\nstation: pomme (str)\\ntemperature: 17.45000 (float)\\nwind: 1.95000 (float)\\n\\n2. Transformer union\\n--------------------\\n 2.0 Select\\n ----------\\n clouds: 88 (int)\\n humidity: 84 (int)\\n pressure: 1,017.34000 (float)\\n temperature: 17.45000 (float)\\n wind: 1.95000 (float)\\n\\n 2.1 TargetAgg\\n -------------\\n target_mean_by_station_and_hour: 7.89396 (float)\\n\\n 2.2 TargetAgg1\\n --------------\\n target_ewm_0.5_by_station: 11.80372 (float)\\n\\nclouds: 88 (int)\\nhumidity: 84 (int)\\npressure: 1,017.34000 (float)\\ntarget_ewm_0.5_by_station: 11.80372 (float)\\ntarget_mean_by_station_and_hour: 7.89396 (float)\\ntemperature: 17.45000 (float)\\nwind: 1.95000 (float)\\n\\n3. StandardScaler\\n-----------------\\nclouds: 1.54778 (float)\\nhumidity: 1.16366 (float)\\npressure: 0.04916 (float)\\ntarget_ewm_0.5_by_station: 0.19214 (float)\\ntarget_mean_by_station_and_hour: -0.26013 (float)\\ntemperature: -0.51938 (float)\\nwind: -0.69426 (float)\\n\\n4. LinearRegression\\n-------------------\\nName Value Weight Contribution \\n Intercept 1.00000 9.22316 9.22316 \\n target_ewm_0.5_by_station 0.19214 9.26418 1.78000 \\n humidity 1.16366 1.01252 1.17823 \\n temperature -0.51938 -0.42112 0.21872 \\n wind -0.69426 -0.04088 0.02838 \\n pressure 0.04916 0.18137 0.00892 \\ntarget_mean_by_station_and_hour -0.26013 0.19801 -0.05151 \\n clouds 1.54778 -0.32697 -0.50608 \\n\\nPrediction: 11.87982' The pipeline does quite a few things, but using debug_one shows what happens step by step. This is really useful for checking that the pipeline is behaving as you're expecting it too. Remember that you can debug_one whenever you wish, be it before, during, or after training a model.","title":"Debugging a pipeline"},{"location":"examples/debugging-a-pipeline/#debugging-a-pipeline","text":"river encourages users to make use of pipelines. The biggest pain point of pipelines is that it can be hard to understand what's happening to the data, especially when the pipeline is complex. Fortunately the Pipeline class has a debug_one method that can help out. Let's look at a fairly complex pipeline for predicting the number of bikes in 5 bike stations from the city of Toulouse. It doesn't matter if you understand the pipeline or not; the point of this notebook is to learn how to introspect a pipeline. import datetime as dt from river import compose from river import datasets from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats from river import stream X_y = datasets . Bikes () X_y = stream . simulate_qa ( X_y , moment = 'moment' , delay = dt . timedelta ( minutes = 30 )) def add_time_features ( x ): return { ** x , 'hour' : x [ 'moment' ] . hour , 'day' : x [ 'moment' ] . weekday () } model = add_time_features model |= ( compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) + feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () metric = metrics . MAE () questions = {} for i , x , y in X_y : # Question is_question = y is None if is_question : y_pred = model . predict_one ( x ) questions [ i ] = y_pred # Answer else : metric . update ( y , questions [ i ]) model = model . learn_one ( x , y ) if i >= 30000 and i % 30000 == 0 : print ( i , metric ) 30000 MAE: 2.220942 60000 MAE: 2.270271 90000 MAE: 2.301302 120000 MAE: 2.275876 150000 MAE: 2.275224 180000 MAE: 2.289347 We can start by looking at what the pipeline looks by drawing it. model . draw () As mentioned above the Pipeline class has a debug_one method. You can use this at any point you want to visualize what happen to an input x . For example, let's see what happens to the last seen x . model . debug_one ( x ) '0. Input\\n--------\\nclouds: 88 (int)\\ndescription: overcast clouds (str)\\nhumidity: 84 (int)\\nmoment: 2016-10-05 09:57:18 (datetime)\\npressure: 1,017.34000 (float)\\nstation: pomme (str)\\ntemperature: 17.45000 (float)\\nwind: 1.95000 (float)\\n\\n1. add_time_features\\n--------------------\\nclouds: 88 (int)\\nday: 2 (int)\\ndescription: overcast clouds (str)\\nhour: 9 (int)\\nhumidity: 84 (int)\\nmoment: 2016-10-05 09:57:18 (datetime)\\npressure: 1,017.34000 (float)\\nstation: pomme (str)\\ntemperature: 17.45000 (float)\\nwind: 1.95000 (float)\\n\\n2. Transformer union\\n--------------------\\n 2.0 Select\\n ----------\\n clouds: 88 (int)\\n humidity: 84 (int)\\n pressure: 1,017.34000 (float)\\n temperature: 17.45000 (float)\\n wind: 1.95000 (float)\\n\\n 2.1 TargetAgg\\n -------------\\n target_mean_by_station_and_hour: 7.89396 (float)\\n\\n 2.2 TargetAgg1\\n --------------\\n target_ewm_0.5_by_station: 11.80372 (float)\\n\\nclouds: 88 (int)\\nhumidity: 84 (int)\\npressure: 1,017.34000 (float)\\ntarget_ewm_0.5_by_station: 11.80372 (float)\\ntarget_mean_by_station_and_hour: 7.89396 (float)\\ntemperature: 17.45000 (float)\\nwind: 1.95000 (float)\\n\\n3. StandardScaler\\n-----------------\\nclouds: 1.54778 (float)\\nhumidity: 1.16366 (float)\\npressure: 0.04916 (float)\\ntarget_ewm_0.5_by_station: 0.19214 (float)\\ntarget_mean_by_station_and_hour: -0.26013 (float)\\ntemperature: -0.51938 (float)\\nwind: -0.69426 (float)\\n\\n4. LinearRegression\\n-------------------\\nName Value Weight Contribution \\n Intercept 1.00000 9.22316 9.22316 \\n target_ewm_0.5_by_station 0.19214 9.26418 1.78000 \\n humidity 1.16366 1.01252 1.17823 \\n temperature -0.51938 -0.42112 0.21872 \\n wind -0.69426 -0.04088 0.02838 \\n pressure 0.04916 0.18137 0.00892 \\ntarget_mean_by_station_and_hour -0.26013 0.19801 -0.05151 \\n clouds 1.54778 -0.32697 -0.50608 \\n\\nPrediction: 11.87982' The pipeline does quite a few things, but using debug_one shows what happens step by step. This is really useful for checking that the pipeline is behaving as you're expecting it too. Remember that you can debug_one whenever you wish, be it before, during, or after training a model.","title":"Debugging a pipeline"},{"location":"examples/imbalanced-learning/","text":"Working with imbalanced data \u00b6 In machine learning it is quite usual to have to deal with imbalanced dataset. This is particularly true in online learning for tasks such as fraud detection and spam classification. In these two cases, which are binary classification problems, there are usually many more 0s than 1s, which generally hinders the performance of the classifiers we thrown at them. As an example we'll use the credit card dataset available in river . We'll first use a collections.Counter to count the number of 0s and 1s in order to get an idea of the class balance. import collections from river import datasets X_y = datasets . CreditCard () counts = collections . Counter ( y for _ , y in X_y ) for c , count in counts . items (): print ( f ' { c } : { count } ( { count / sum ( counts . values ()) : .5% } )' ) Downloading https://maxhalford.github.io/files/datasets/creditcardfraud.zip (65.95 MB) Uncompressing into /home/runner/river_data/CreditCard 0: 284315 (99.82725%) 1: 492 (0.17275%) Baseline \u00b6 The dataset is quite unbalanced. For each 1 there are about 578 0s. Let's now train a logistic regression with default parameters and see how well it does. We'll measure the ROC AUC score. from river import linear_model from river import metrics from river import evaluate from river import preprocessing X_y = datasets . CreditCard () model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression () ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.891072 Importance weighting \u00b6 The performance is already quite acceptable, but as we will now see we can do even better. The first thing we can do is to add weight to the 1s by using the weight_pos argument of the Log loss function. from river import optim model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.914269 Focal loss \u00b6 The deep learning for object detection community has produced a special loss function for imbalaced learning called focal loss . We are doing binary classification, so we can plug the binary version of focal loss into our logistic regression and see how well it fairs. model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . BinaryFocalLoss ( 2 , 1 )) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.913072 Under-sampling the majority class \u00b6 Adding importance weights only works with gradient-based models (which includes neural networks). A more generic, and potentially more effective approach, is to use undersamplig and oversampling. As an example, we'll under-sample the stream so that our logistic regression encounter 20% of 1s and 80% of 0s. Under-sampling has the additional benefit of requiring less training steps, and thus reduces the total training time. from river import imblearn model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : . 8 , 1 : . 2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.948824 The RandomUnderSampler class is a wrapper for classifiers. This is represented by a rectangle around the logistic regression bubble when we draw the model. model . draw () Over-sampling the minority class \u00b6 We can also attain the same class distribution by over-sampling the minority class. This will come at cost of having to train with more samples. model = ( preprocessing . StandardScaler () | imblearn . RandomOverSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : . 8 , 1 : . 2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.918082 Sampling with a desired sample size \u00b6 The downside of both RandomUnderSampler and RandomOverSampler is that you don't have any control on the amount of data the classifier trains on. The number of samples is adjusted so that the target distribution can be attained, either by under-sampling or over-sampling. However, you can do both at the same time and choose how much data the classifier will see. To do so, we can use the RandomSampler class. In addition to the desired class distribution, we can specify how much data to train on. The samples will both be under-sampled and over-sampled in order to fit your constraints. This is powerful because it allows you to control both the class distribution and the size of the training data (and thus the training time). In the following example we'll set it so that the model will train with 1 percent of the data. model = ( preprocessing . StandardScaler () | imblearn . RandomSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : . 8 , 1 : . 2 }, sampling_rate =. 01 , seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.951296 Hybrid approach \u00b6 As you might have guessed by now, nothing is stopping you from mixing imbalanced learning methods together. As an example, let's combine sampling.RandomUnderSampler and the weight_pos parameter from the optim.losses.Log loss function. model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ), desired_dist = { 0 : . 8 , 1 : . 2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.968289","title":"Working with imbalanced data"},{"location":"examples/imbalanced-learning/#working-with-imbalanced-data","text":"In machine learning it is quite usual to have to deal with imbalanced dataset. This is particularly true in online learning for tasks such as fraud detection and spam classification. In these two cases, which are binary classification problems, there are usually many more 0s than 1s, which generally hinders the performance of the classifiers we thrown at them. As an example we'll use the credit card dataset available in river . We'll first use a collections.Counter to count the number of 0s and 1s in order to get an idea of the class balance. import collections from river import datasets X_y = datasets . CreditCard () counts = collections . Counter ( y for _ , y in X_y ) for c , count in counts . items (): print ( f ' { c } : { count } ( { count / sum ( counts . values ()) : .5% } )' ) Downloading https://maxhalford.github.io/files/datasets/creditcardfraud.zip (65.95 MB) Uncompressing into /home/runner/river_data/CreditCard 0: 284315 (99.82725%) 1: 492 (0.17275%)","title":"Working with imbalanced data"},{"location":"examples/imbalanced-learning/#baseline","text":"The dataset is quite unbalanced. For each 1 there are about 578 0s. Let's now train a logistic regression with default parameters and see how well it does. We'll measure the ROC AUC score. from river import linear_model from river import metrics from river import evaluate from river import preprocessing X_y = datasets . CreditCard () model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression () ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.891072","title":"Baseline"},{"location":"examples/imbalanced-learning/#importance-weighting","text":"The performance is already quite acceptable, but as we will now see we can do even better. The first thing we can do is to add weight to the 1s by using the weight_pos argument of the Log loss function. from river import optim model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.914269","title":"Importance weighting"},{"location":"examples/imbalanced-learning/#focal-loss","text":"The deep learning for object detection community has produced a special loss function for imbalaced learning called focal loss . We are doing binary classification, so we can plug the binary version of focal loss into our logistic regression and see how well it fairs. model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . BinaryFocalLoss ( 2 , 1 )) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.913072","title":"Focal loss"},{"location":"examples/imbalanced-learning/#under-sampling-the-majority-class","text":"Adding importance weights only works with gradient-based models (which includes neural networks). A more generic, and potentially more effective approach, is to use undersamplig and oversampling. As an example, we'll under-sample the stream so that our logistic regression encounter 20% of 1s and 80% of 0s. Under-sampling has the additional benefit of requiring less training steps, and thus reduces the total training time. from river import imblearn model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : . 8 , 1 : . 2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.948824 The RandomUnderSampler class is a wrapper for classifiers. This is represented by a rectangle around the logistic regression bubble when we draw the model. model . draw ()","title":"Under-sampling the majority class"},{"location":"examples/imbalanced-learning/#over-sampling-the-minority-class","text":"We can also attain the same class distribution by over-sampling the minority class. This will come at cost of having to train with more samples. model = ( preprocessing . StandardScaler () | imblearn . RandomOverSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : . 8 , 1 : . 2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.918082","title":"Over-sampling the minority class"},{"location":"examples/imbalanced-learning/#sampling-with-a-desired-sample-size","text":"The downside of both RandomUnderSampler and RandomOverSampler is that you don't have any control on the amount of data the classifier trains on. The number of samples is adjusted so that the target distribution can be attained, either by under-sampling or over-sampling. However, you can do both at the same time and choose how much data the classifier will see. To do so, we can use the RandomSampler class. In addition to the desired class distribution, we can specify how much data to train on. The samples will both be under-sampled and over-sampled in order to fit your constraints. This is powerful because it allows you to control both the class distribution and the size of the training data (and thus the training time). In the following example we'll set it so that the model will train with 1 percent of the data. model = ( preprocessing . StandardScaler () | imblearn . RandomSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : . 8 , 1 : . 2 }, sampling_rate =. 01 , seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.951296","title":"Sampling with a desired sample size"},{"location":"examples/imbalanced-learning/#hybrid-approach","text":"As you might have guessed by now, nothing is stopping you from mixing imbalanced learning methods together. As an example, let's combine sampling.RandomUnderSampler and the weight_pos parameter from the optim.losses.Log loss function. model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ), desired_dist = { 0 : . 8 , 1 : . 2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 0.968289","title":"Hybrid approach"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/","text":"Matrix Factorization for Recommender Systems - Part 1 \u00b6 Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning Introduction \u00b6 A recommender system is a software tool designed to generate and suggest items or entities to the users. Popular large scale examples include: Amazon (suggesting products) Facebook (suggesting posts in users' news feeds) Spotify (suggesting music) Social recommendation from graph (mostly used by social networks) are not covered in river . We focus on the general case, item recommendation. This problem can be represented with the user-item matrix: \\[ \\normalsize \\begin{matrix} & \\begin{matrix} _1 & _\\cdots & _\\cdots & _\\cdots & _I \\end{matrix} \\\\ \\begin{matrix} _1 \\\\ _\\vdots \\\\ _\\vdots \\\\ _\\vdots \\\\ _U \\end{matrix} & \\begin{bmatrix} {\\color{Red} ?} & 2 & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & 4.5 \\\\ \\vdots & \\ddots & \\ddots & \\ddots & \\vdots \\\\ 3 & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & 5 & {\\color{Red} ?} \\end{bmatrix} \\end{matrix} \\] Where \\(U\\) and \\(I\\) are the number of user and item of the system, respectively. A matrix entry represents a user's preference for an item, it can be a rating, a like or dislike, etc. Because of the huge number of users and items compared to the number of observed entries, those matrices are very sparsed (usually less than 1% filled). Matrix Factorization (MF) is a class of collaborative filtering algorithms derived from Singular Value Decomposition (SVD) . MF strength lies in its capacity to able to model high cardinality categorical variables interactions. This subfield boomed during the famous Netflix Prize contest in 2006, when numerous novel variants has been invented and became popular thanks to their attractive accuracy and scalability. MF approach seeks to fill the user-item matrix considering the problem as a matrix completion one. MF core idea assume a latent model learning its own representation of the users and the items in a lower latent dimensional space by factorizing the observed parts of the matrix. A factorized user or item is represented as a vector \\(\\mathbf{v}_u\\) or \\(\\mathbf{v}_i\\) composed of \\(k\\) latent factors, with \\(k << U, I\\) . Those learnt latent variables represent, for an item the various aspects describing it, and for a user its interests in terms of those aspects. The model then assume a user's choice or fondness is composed of a sum of preferences about the various aspects of the concerned item. This sum being the dot product between the latent vectors of a given user-item pair: \\[ \\normalsize \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f} \\] MF models weights are learnt in an online fashion, often with stochastic gradient descent as it provides relatively fast running time and good accuracy. There is a great and widely popular library named surprise that implements MF models (and others) but in contrast with river doesn't follow a pure online philosophy (all the data have to be loaded in memory and the API doesn't allow you to update your model with new data). Notes: In recent years, proposed deep learning techniques for recommendation tasks claim state of the art results. However, recent work (August 2019) showed that those promises can't be taken for granted and traditional MF methods are still relevant today. For more information about how the business value of recommender systems is measured and why they are one of the main success stories of machine learning, see the following literature survey (December 2019). Let's start \u00b6 In this tutorial, we are going to explore MF algorithms available in river and test them on a movie recommendation problem with the MovieLens 100K dataset. This latter is a collection of movie ratings (from 1 to 5) that includes various information about both the items and the users. We can access it from the river.datasets module: import json from river import datasets for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } \\n y = { y } ' ) break Downloading https://maxhalford.github.io/files/datasets/ml_100k.zip (1.83 MB) Uncompressing into /home/runner/river_data/MovieLens100K x = { \"user\": \"259\", \"item\": \"255\", \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 Let's define a routine to evaluate our different models on MovieLens 100K. Mean Absolute Error and Root Mean Squared Error will be our metrics printed alongside model's computation time and memory usage: from river import metrics from river.evaluate import progressive_val_score def evaluate ( model ): X_y = datasets . MovieLens100K () metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True ) Naive prediction \u00b6 It's good practice in machine learning to start with a naive baseline and then iterate from simple things to complex ones observing progress incrementally. Let's start by predicing the target running mean as a first shot: from river import stats mean = stats . Mean () metric = metrics . MAE () + metrics . RMSE () for i , x_y in enumerate ( datasets . MovieLens100K (), start = 1 ): _ , y = x_y metric . update ( y , mean . get ()) mean . update ( y ) if not i % 25_000 : print ( f '[ { i : ,d } ] { metric } ' ) [25,000] MAE: 0.934259, RMSE: 1.124469 [50,000] MAE: 0.923893, RMSE: 1.105 [75,000] MAE: 0.937359, RMSE: 1.123696 [100,000] MAE: 0.942162, RMSE: 1.125783 Baseline model \u00b6 Now we can do machine learning and explore available models in river.reco module starting with the baseline model. It extends our naive prediction by adding to the global running mean two bias terms characterizing the user and the item discrepancy from the general tendency. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} \\] This baseline model can be viewed as a linear regression where the intercept is replaced by the target running mean with the users and the items one hot encoded. All machine learning models in river expect dicts as input with feature names as keys and feature values as values. Specifically, models from river.reco expect a 'user' and an 'item' entries without any type constraint on their values (i.e. can be strings or numbers), e.g.: x = { 'user' : 'Guido' , 'item' : \"Monty Python's Flying Circus\" } Other entries, if exist, are simply ignored. This is quite useful as we don't need to spend time and storage doing one hot encoding. from river import meta from river import optim from river import reco baseline_params = { 'optimizer' : optim . SGD ( 0.025 ), 'l2' : 0. , 'initializer' : optim . initializers . Zeros () } model = meta . PredClipper ( regressor = reco . Baseline ( ** baseline_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761844, RMSE: 0.960972 \u2013 0:00:00 \u2013 169.73 KB [50,000] MAE: 0.753292, RMSE: 0.951223 \u2013 0:00:01 \u2013 238.37 KB [75,000] MAE: 0.754177, RMSE: 0.953376 \u2013 0:00:02 \u2013 282.17 KB [100,000] MAE: 0.754651, RMSE: 0.954148 \u2013 0:00:03 \u2013 305.77 KB We won two tenth of MAE compared to our naive prediction (0.7546 vs 0.9421) meaning that significant information has been learnt by the model. Funk Matrix Factorization (FunkMF) \u00b6 It's the pure form of matrix factorization consisting of only learning the users and items latent representations as discussed in introduction. Simon Funk popularized its stochastic gradient descent optimization in 2006 during the Netflix Prize. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: FunkMF is sometimes referred as Probabilistic Matrix Factorization which is an extended probabilistic version. funk_mf_params = { 'n_factors' : 10 , 'optimizer' : optim . SGD ( 0.05 ), 'l2' : 0.1 , 'initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ) } model = meta . PredClipper ( regressor = reco . FunkMF ( ** funk_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 1.070136, RMSE: 1.397014 \u2013 0:00:01 \u2013 925.2 KB [50,000] MAE: 0.99174, RMSE: 1.290666 \u2013 0:00:03 \u2013 1.11 MB [75,000] MAE: 0.961072, RMSE: 1.250842 \u2013 0:00:04 \u2013 1.31 MB [100,000] MAE: 0.944883, RMSE: 1.227688 \u2013 0:00:06 \u2013 1.48 MB Results are equivalent to our naive prediction (0.9448 vs 0.9421). By only focusing on the users preferences and the items characteristics, the model is limited in his ability to capture different views of the problem. Despite its poor performance alone, this algorithm is quite useful combined in other models or when we need to build dense representations for other tasks. Biased Matrix Factorization (BiasedMF) \u00b6 It's the combination of the Baseline model and FunkMF. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: Biased Matrix Factorization name is used by some people but some others refer to it by SVD or Funk SVD . It's the case of Yehuda Koren and Robert Bell in Recommender Systems Handbook (Chapter 5 Advances in Collaborative Filtering ) and of surprise library. Nevertheless, SVD could be confused with the original Singular Value Decomposition from which it's derived from, and Funk SVD could also be misleading because of the biased part of the model equation which doesn't come from Simon Funk's work. For those reasons, we chose to side with Biased Matrix Factorization which fits more naturally to it. biased_mf_params = { 'n_factors' : 10 , 'bias_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), 'l2_bias' : 0. , 'l2_latent' : 0. } model = meta . PredClipper ( regressor = reco . BiasedMF ( ** biased_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761818, RMSE: 0.961057 \u2013 0:00:01 \u2013 1 MB [50,000] MAE: 0.751667, RMSE: 0.949443 \u2013 0:00:03 \u2013 1.26 MB [75,000] MAE: 0.749653, RMSE: 0.948723 \u2013 0:00:05 \u2013 1.49 MB [100,000] MAE: 0.748559, RMSE: 0.947854 \u2013 0:00:07 \u2013 1.67 MB Results improved (0.7485 vs 0.7546) demonstrating that users and items latent representations bring additional information. To conclude this first tutorial about factorization models, let's review the important parameters to tune when dealing with this family of methods: n_factors : the number of latent factors. The more you set, the more items aspects and users preferences you are going to learn. Too many will cause overfitting, l2 regularization could help. *_optimizer : the optimizers. Classic stochastic gradient descent performs well, finding the good learning rate will make the difference. initializer : the latent weights initialization. Latent vectors have to be initialized with non-constant values. We generally sample them from a zero-mean normal distribution with small standard deviation.","title":"Matrix Factorization for Recommender Systems - Part 1"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/#matrix-factorization-for-recommender-systems-part-1","text":"Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning","title":"Matrix Factorization for Recommender Systems - Part 1"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/#introduction","text":"A recommender system is a software tool designed to generate and suggest items or entities to the users. Popular large scale examples include: Amazon (suggesting products) Facebook (suggesting posts in users' news feeds) Spotify (suggesting music) Social recommendation from graph (mostly used by social networks) are not covered in river . We focus on the general case, item recommendation. This problem can be represented with the user-item matrix: \\[ \\normalsize \\begin{matrix} & \\begin{matrix} _1 & _\\cdots & _\\cdots & _\\cdots & _I \\end{matrix} \\\\ \\begin{matrix} _1 \\\\ _\\vdots \\\\ _\\vdots \\\\ _\\vdots \\\\ _U \\end{matrix} & \\begin{bmatrix} {\\color{Red} ?} & 2 & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & 4.5 \\\\ \\vdots & \\ddots & \\ddots & \\ddots & \\vdots \\\\ 3 & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & 5 & {\\color{Red} ?} \\end{bmatrix} \\end{matrix} \\] Where \\(U\\) and \\(I\\) are the number of user and item of the system, respectively. A matrix entry represents a user's preference for an item, it can be a rating, a like or dislike, etc. Because of the huge number of users and items compared to the number of observed entries, those matrices are very sparsed (usually less than 1% filled). Matrix Factorization (MF) is a class of collaborative filtering algorithms derived from Singular Value Decomposition (SVD) . MF strength lies in its capacity to able to model high cardinality categorical variables interactions. This subfield boomed during the famous Netflix Prize contest in 2006, when numerous novel variants has been invented and became popular thanks to their attractive accuracy and scalability. MF approach seeks to fill the user-item matrix considering the problem as a matrix completion one. MF core idea assume a latent model learning its own representation of the users and the items in a lower latent dimensional space by factorizing the observed parts of the matrix. A factorized user or item is represented as a vector \\(\\mathbf{v}_u\\) or \\(\\mathbf{v}_i\\) composed of \\(k\\) latent factors, with \\(k << U, I\\) . Those learnt latent variables represent, for an item the various aspects describing it, and for a user its interests in terms of those aspects. The model then assume a user's choice or fondness is composed of a sum of preferences about the various aspects of the concerned item. This sum being the dot product between the latent vectors of a given user-item pair: \\[ \\normalsize \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f} \\] MF models weights are learnt in an online fashion, often with stochastic gradient descent as it provides relatively fast running time and good accuracy. There is a great and widely popular library named surprise that implements MF models (and others) but in contrast with river doesn't follow a pure online philosophy (all the data have to be loaded in memory and the API doesn't allow you to update your model with new data). Notes: In recent years, proposed deep learning techniques for recommendation tasks claim state of the art results. However, recent work (August 2019) showed that those promises can't be taken for granted and traditional MF methods are still relevant today. For more information about how the business value of recommender systems is measured and why they are one of the main success stories of machine learning, see the following literature survey (December 2019).","title":"Introduction"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/#lets-start","text":"In this tutorial, we are going to explore MF algorithms available in river and test them on a movie recommendation problem with the MovieLens 100K dataset. This latter is a collection of movie ratings (from 1 to 5) that includes various information about both the items and the users. We can access it from the river.datasets module: import json from river import datasets for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } \\n y = { y } ' ) break Downloading https://maxhalford.github.io/files/datasets/ml_100k.zip (1.83 MB) Uncompressing into /home/runner/river_data/MovieLens100K x = { \"user\": \"259\", \"item\": \"255\", \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 Let's define a routine to evaluate our different models on MovieLens 100K. Mean Absolute Error and Root Mean Squared Error will be our metrics printed alongside model's computation time and memory usage: from river import metrics from river.evaluate import progressive_val_score def evaluate ( model ): X_y = datasets . MovieLens100K () metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True )","title":"Let's start"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/#naive-prediction","text":"It's good practice in machine learning to start with a naive baseline and then iterate from simple things to complex ones observing progress incrementally. Let's start by predicing the target running mean as a first shot: from river import stats mean = stats . Mean () metric = metrics . MAE () + metrics . RMSE () for i , x_y in enumerate ( datasets . MovieLens100K (), start = 1 ): _ , y = x_y metric . update ( y , mean . get ()) mean . update ( y ) if not i % 25_000 : print ( f '[ { i : ,d } ] { metric } ' ) [25,000] MAE: 0.934259, RMSE: 1.124469 [50,000] MAE: 0.923893, RMSE: 1.105 [75,000] MAE: 0.937359, RMSE: 1.123696 [100,000] MAE: 0.942162, RMSE: 1.125783","title":"Naive prediction"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/#baseline-model","text":"Now we can do machine learning and explore available models in river.reco module starting with the baseline model. It extends our naive prediction by adding to the global running mean two bias terms characterizing the user and the item discrepancy from the general tendency. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} \\] This baseline model can be viewed as a linear regression where the intercept is replaced by the target running mean with the users and the items one hot encoded. All machine learning models in river expect dicts as input with feature names as keys and feature values as values. Specifically, models from river.reco expect a 'user' and an 'item' entries without any type constraint on their values (i.e. can be strings or numbers), e.g.: x = { 'user' : 'Guido' , 'item' : \"Monty Python's Flying Circus\" } Other entries, if exist, are simply ignored. This is quite useful as we don't need to spend time and storage doing one hot encoding. from river import meta from river import optim from river import reco baseline_params = { 'optimizer' : optim . SGD ( 0.025 ), 'l2' : 0. , 'initializer' : optim . initializers . Zeros () } model = meta . PredClipper ( regressor = reco . Baseline ( ** baseline_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761844, RMSE: 0.960972 \u2013 0:00:00 \u2013 169.73 KB [50,000] MAE: 0.753292, RMSE: 0.951223 \u2013 0:00:01 \u2013 238.37 KB [75,000] MAE: 0.754177, RMSE: 0.953376 \u2013 0:00:02 \u2013 282.17 KB [100,000] MAE: 0.754651, RMSE: 0.954148 \u2013 0:00:03 \u2013 305.77 KB We won two tenth of MAE compared to our naive prediction (0.7546 vs 0.9421) meaning that significant information has been learnt by the model.","title":"Baseline model"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/#funk-matrix-factorization-funkmf","text":"It's the pure form of matrix factorization consisting of only learning the users and items latent representations as discussed in introduction. Simon Funk popularized its stochastic gradient descent optimization in 2006 during the Netflix Prize. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: FunkMF is sometimes referred as Probabilistic Matrix Factorization which is an extended probabilistic version. funk_mf_params = { 'n_factors' : 10 , 'optimizer' : optim . SGD ( 0.05 ), 'l2' : 0.1 , 'initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ) } model = meta . PredClipper ( regressor = reco . FunkMF ( ** funk_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 1.070136, RMSE: 1.397014 \u2013 0:00:01 \u2013 925.2 KB [50,000] MAE: 0.99174, RMSE: 1.290666 \u2013 0:00:03 \u2013 1.11 MB [75,000] MAE: 0.961072, RMSE: 1.250842 \u2013 0:00:04 \u2013 1.31 MB [100,000] MAE: 0.944883, RMSE: 1.227688 \u2013 0:00:06 \u2013 1.48 MB Results are equivalent to our naive prediction (0.9448 vs 0.9421). By only focusing on the users preferences and the items characteristics, the model is limited in his ability to capture different views of the problem. Despite its poor performance alone, this algorithm is quite useful combined in other models or when we need to build dense representations for other tasks.","title":"Funk Matrix Factorization (FunkMF)"},{"location":"examples/matrix-factorization-for-recommender-systems-part-1/#biased-matrix-factorization-biasedmf","text":"It's the combination of the Baseline model and FunkMF. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: Biased Matrix Factorization name is used by some people but some others refer to it by SVD or Funk SVD . It's the case of Yehuda Koren and Robert Bell in Recommender Systems Handbook (Chapter 5 Advances in Collaborative Filtering ) and of surprise library. Nevertheless, SVD could be confused with the original Singular Value Decomposition from which it's derived from, and Funk SVD could also be misleading because of the biased part of the model equation which doesn't come from Simon Funk's work. For those reasons, we chose to side with Biased Matrix Factorization which fits more naturally to it. biased_mf_params = { 'n_factors' : 10 , 'bias_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), 'l2_bias' : 0. , 'l2_latent' : 0. } model = meta . PredClipper ( regressor = reco . BiasedMF ( ** biased_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761818, RMSE: 0.961057 \u2013 0:00:01 \u2013 1 MB [50,000] MAE: 0.751667, RMSE: 0.949443 \u2013 0:00:03 \u2013 1.26 MB [75,000] MAE: 0.749653, RMSE: 0.948723 \u2013 0:00:05 \u2013 1.49 MB [100,000] MAE: 0.748559, RMSE: 0.947854 \u2013 0:00:07 \u2013 1.67 MB Results improved (0.7485 vs 0.7546) demonstrating that users and items latent representations bring additional information. To conclude this first tutorial about factorization models, let's review the important parameters to tune when dealing with this family of methods: n_factors : the number of latent factors. The more you set, the more items aspects and users preferences you are going to learn. Too many will cause overfitting, l2 regularization could help. *_optimizer : the optimizers. Classic stochastic gradient descent performs well, finding the good learning rate will make the difference. initializer : the latent weights initialization. Latent vectors have to be initialized with non-constant values. We generally sample them from a zero-mean normal distribution with small standard deviation.","title":"Biased Matrix Factorization (BiasedMF)"},{"location":"examples/matrix-factorization-for-recommender-systems-part-2/","text":"Matrix Factorization for Recommender Systems - Part 2 \u00b6 As seen in Part 1 , strength of Matrix Factorization (MF) lies in its ability to deal with sparse and high cardinality categorical variables. In this second tutorial we will have a look at Factorization Machines (FM) algorithm and study how it generalizes the power of MF. Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning Factorization Machines \u00b6 Steffen Rendel came up in 2010 with Factorization Machines , an algorithm able to handle any real valued feature vector, combining the advantages of general predictors with factorization models. It became quite popular in the field of online advertising, notably after winning several Kaggle competitions. The modeling technique starts with a linear regression to capture the effects of each variable individually: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} \\] Then are added interaction terms to learn features relations. Instead of learning a single and specific weight per interaction (as in polynomial regression ), a set of latent factors is learnt per feature (as in MF). An interaction is calculated by multiplying involved features product with their latent vectors dot product. The degree of factorization \u2014 or model order \u2014 represents the maximum number of features per interaction considered. The model equation for a factorization machine of degree \\(d\\) = 2 is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] Where \\(\\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle\\) is the dot product of \\(j\\) and \\(j'\\) latent vectors: \\[ \\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{j, f} \\cdot \\mathbf{v}_{j', f} \\] Higher-order FM will be covered in a following section, just note that factorization models express their power in sparse settings, which is also where higher-order interactions are hard to estimate. Strong emphasis must be placed on feature engineering as it allows FM to mimic most factorization models and significantly impact its performance. High cardinality categorical variables one hot encoding is the most frequent step before feeding the model with data. For more efficiency, river FM implementation considers string values as categorical variables and automatically one hot encode them. FM models have their own module river.facto . ## Mimic Biased Matrix Factorization (BiasedMF) Let's start with a simple example where we want to reproduce the Biased Matrix Factorization model we trained in the previous tutorial. For a fair comparison with Part 1 example , let's set the same evaluation framework: from river import datasets from river import metrics from river.evaluate import progressive_val_score def evaluate ( model ): X_y = datasets . MovieLens100K () metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True ) In order to build an equivalent model we need to use the same hyper-parameters. As we can't replace FM intercept by the global running mean we won't be able to build the exact same model: from river import compose from river import facto from river import meta from river import optim from river import stats fm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'sample_normalization' : False , 'l1_weight' : 0. , 'l2_weight' : 0. , 'l1_latent' : 0. , 'l2_latent' : 0. , 'intercept' : 3 , 'intercept_lr' : . 01 , 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor |= facto . FMRegressor ( ** fm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761761, RMSE: 0.960662 \u2013 0:00:04 \u2013 1.15 MB [50,000] MAE: 0.751922, RMSE: 0.949783 \u2013 0:00:09 \u2013 1.34 MB [75,000] MAE: 0.749822, RMSE: 0.948634 \u2013 0:00:14 \u2013 1.56 MB [100,000] MAE: 0.748393, RMSE: 0.94776 \u2013 0:00:19 \u2013 1.75 MB Both MAE are very close to each other (0.7486 vs 0.7485) showing that we almost reproduced reco.BiasedMF algorithm. The cost is a naturally slower running time as FM implementation offers more flexibility. Feature engineering for FM models \u00b6 Let's study the basics of how to properly encode data for FM models. We are going to keep using MovieLens 100K as it provides various feature types: import json for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } \\n y = { y } ' ) break x = { \"user\": \"259\", \"item\": \"255\", \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 The features we are going to add to our model don't improve its predictive power. Nevertheless, they are useful to illustrate different methods of data encoding: Set-categorical variables We have seen that categorical variables are one hot encoded automatically if set to strings, in the other hand, set-categorical variables must be encoded explicitly by the user. A good way of doing so is to assign them a value of \\(1/m\\) , where \\(m\\) is the number of elements of the sample set. It gives the feature a constant \"weight\" across all samples preserving model's stability. Let's create a routine to encode movies genres this way: def split_genres ( x ): genres = x [ 'genres' ] . split ( ', ' ) return { f 'genre_ { genre } ' : 1 / len ( genres ) for genre in genres } Numerical variables In practice, transforming numerical features into categorical ones works better in most cases. Feature binning is the natural way, but finding good bins is sometimes more an art than a science. Let's encode users age with something simple: def bin_age ( x ): if x [ 'age' ] <= 18 : return { 'age_0-18' : 1 } elif x [ 'age' ] <= 32 : return { 'age_19-32' : 1 } elif x [ 'age' ] < 55 : return { 'age_33-54' : 1 } else : return { 'age_55-100' : 1 } Let's put everything together: fm_params = { 'n_factors' : 14 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FMRegressor ( ** fm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.760059, RMSE: 0.961415 \u2013 0:00:12 \u2013 1.42 MB [50,000] MAE: 0.751429, RMSE: 0.951504 \u2013 0:00:24 \u2013 1.66 MB [75,000] MAE: 0.750568, RMSE: 0.951592 \u2013 0:00:37 \u2013 1.93 MB [100,000] MAE: 0.75018, RMSE: 0.951622 \u2013 0:00:49 \u2013 2.18 MB Note that using more variables involves factorizing a larger latent space, then increasing the number of latent factors \\(k\\) often helps capturing more information. Some other feature engineering tips from 3 idiots' winning solution for Kaggle Criteo display ads competition in 2014: Infrequent modalities often bring noise and little information, transforming them into a special tag can help In some cases, sample-wise normalization seems to make the optimization problem easier to be solved Higher-Order Factorization Machines (HOFM) \u00b6 The model equation generalized to any order \\(d \\geq 2\\) is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right) \\] hofm_params = { 'degree' : 3 , 'n_factors' : 12 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . HOFMRegressor ( ** hofm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761379, RMSE: 0.96214 \u2013 0:01:07 \u2013 2.59 MB [50,000] MAE: 0.751998, RMSE: 0.951589 \u2013 0:02:13 \u2013 3.05 MB [75,000] MAE: 0.750994, RMSE: 0.951616 \u2013 0:03:19 \u2013 3.56 MB [100,000] MAE: 0.750849, RMSE: 0.952142 \u2013 0:04:25 \u2013 4.03 MB As said previously, high-order interactions are often hard to estimate due to too much sparsity, that's why we won't spend too much time here. Field-aware Factorization Machines (FFM) \u00b6 Field-aware variant of FM (FFM) improved the original method by adding the notion of \" fields \". A \" field \" is a group of features that belong to a specific domain (e.g. the \" users \" field, the \" items \" field, or the \" movie genres \" field). FFM restricts itself to pairwise interactions and factorizes separated latent spaces \u2014 one per combination of fields (e.g. users/items, users/movie genres, or items/movie genres) \u2014 instead of a common one shared by all fields. Therefore, each feature has one latent vector per field it can interact with \u2014 so that it can learn the specific effect with each different field. The model equation is defined by: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_{j}} \\rangle x_{j} x_{j'} \\] Where \\(f_j\\) and \\(f_{j'}\\) are the fields corresponding to \\(j\\) and \\(j'\\) features, respectively. ffm_params = { 'n_factors' : 8 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FFMRegressor ( ** ffm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.758339, RMSE: 0.959047 \u2013 0:00:18 \u2013 3 MB [50,000] MAE: 0.749833, RMSE: 0.948531 \u2013 0:00:36 \u2013 3.54 MB [75,000] MAE: 0.749631, RMSE: 0.949418 \u2013 0:00:55 \u2013 4.14 MB [100,000] MAE: 0.749776, RMSE: 0.950131 \u2013 0:01:13 \u2013 4.69 MB Note that FFM usually needs to learn smaller number of latent factors \\(k\\) than FM as each latent vector only deals with one field. Field-weighted Factorization Machines (FwFM) \u00b6 Field-weighted Factorization Machines (FwFM) address FFM memory issues caused by its large number of parameters, which is in the order of feature number times field number . As FFM, FwFM is an extension of FM restricted to pairwise interactions, but instead of factorizing separated latent spaces, it learns a specific weight \\(r_{f_j, f_{j'}}\\) for each field combination modelling the interaction strength. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] fwfm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'seed' : 73 , } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FwFMRegressor ( ** fwfm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761435, RMSE: 0.962211 \u2013 0:00:23 \u2013 1.17 MB [50,000] MAE: 0.754063, RMSE: 0.953248 \u2013 0:00:47 \u2013 1.36 MB [75,000] MAE: 0.754729, RMSE: 0.95507 \u2013 0:01:11 \u2013 1.58 MB [100,000] MAE: 0.755697, RMSE: 0.956542 \u2013 0:01:35 \u2013 1.77 MB","title":"Matrix Factorization for Recommender Systems - Part 2"},{"location":"examples/matrix-factorization-for-recommender-systems-part-2/#matrix-factorization-for-recommender-systems-part-2","text":"As seen in Part 1 , strength of Matrix Factorization (MF) lies in its ability to deal with sparse and high cardinality categorical variables. In this second tutorial we will have a look at Factorization Machines (FM) algorithm and study how it generalizes the power of MF. Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning","title":"Matrix Factorization for Recommender Systems - Part 2"},{"location":"examples/matrix-factorization-for-recommender-systems-part-2/#factorization-machines","text":"Steffen Rendel came up in 2010 with Factorization Machines , an algorithm able to handle any real valued feature vector, combining the advantages of general predictors with factorization models. It became quite popular in the field of online advertising, notably after winning several Kaggle competitions. The modeling technique starts with a linear regression to capture the effects of each variable individually: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} \\] Then are added interaction terms to learn features relations. Instead of learning a single and specific weight per interaction (as in polynomial regression ), a set of latent factors is learnt per feature (as in MF). An interaction is calculated by multiplying involved features product with their latent vectors dot product. The degree of factorization \u2014 or model order \u2014 represents the maximum number of features per interaction considered. The model equation for a factorization machine of degree \\(d\\) = 2 is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] Where \\(\\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle\\) is the dot product of \\(j\\) and \\(j'\\) latent vectors: \\[ \\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{j, f} \\cdot \\mathbf{v}_{j', f} \\] Higher-order FM will be covered in a following section, just note that factorization models express their power in sparse settings, which is also where higher-order interactions are hard to estimate. Strong emphasis must be placed on feature engineering as it allows FM to mimic most factorization models and significantly impact its performance. High cardinality categorical variables one hot encoding is the most frequent step before feeding the model with data. For more efficiency, river FM implementation considers string values as categorical variables and automatically one hot encode them. FM models have their own module river.facto . ## Mimic Biased Matrix Factorization (BiasedMF) Let's start with a simple example where we want to reproduce the Biased Matrix Factorization model we trained in the previous tutorial. For a fair comparison with Part 1 example , let's set the same evaluation framework: from river import datasets from river import metrics from river.evaluate import progressive_val_score def evaluate ( model ): X_y = datasets . MovieLens100K () metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True ) In order to build an equivalent model we need to use the same hyper-parameters. As we can't replace FM intercept by the global running mean we won't be able to build the exact same model: from river import compose from river import facto from river import meta from river import optim from river import stats fm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'sample_normalization' : False , 'l1_weight' : 0. , 'l2_weight' : 0. , 'l1_latent' : 0. , 'l2_latent' : 0. , 'intercept' : 3 , 'intercept_lr' : . 01 , 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor |= facto . FMRegressor ( ** fm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761761, RMSE: 0.960662 \u2013 0:00:04 \u2013 1.15 MB [50,000] MAE: 0.751922, RMSE: 0.949783 \u2013 0:00:09 \u2013 1.34 MB [75,000] MAE: 0.749822, RMSE: 0.948634 \u2013 0:00:14 \u2013 1.56 MB [100,000] MAE: 0.748393, RMSE: 0.94776 \u2013 0:00:19 \u2013 1.75 MB Both MAE are very close to each other (0.7486 vs 0.7485) showing that we almost reproduced reco.BiasedMF algorithm. The cost is a naturally slower running time as FM implementation offers more flexibility.","title":"Factorization Machines"},{"location":"examples/matrix-factorization-for-recommender-systems-part-2/#feature-engineering-for-fm-models","text":"Let's study the basics of how to properly encode data for FM models. We are going to keep using MovieLens 100K as it provides various feature types: import json for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } \\n y = { y } ' ) break x = { \"user\": \"259\", \"item\": \"255\", \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 The features we are going to add to our model don't improve its predictive power. Nevertheless, they are useful to illustrate different methods of data encoding: Set-categorical variables We have seen that categorical variables are one hot encoded automatically if set to strings, in the other hand, set-categorical variables must be encoded explicitly by the user. A good way of doing so is to assign them a value of \\(1/m\\) , where \\(m\\) is the number of elements of the sample set. It gives the feature a constant \"weight\" across all samples preserving model's stability. Let's create a routine to encode movies genres this way: def split_genres ( x ): genres = x [ 'genres' ] . split ( ', ' ) return { f 'genre_ { genre } ' : 1 / len ( genres ) for genre in genres } Numerical variables In practice, transforming numerical features into categorical ones works better in most cases. Feature binning is the natural way, but finding good bins is sometimes more an art than a science. Let's encode users age with something simple: def bin_age ( x ): if x [ 'age' ] <= 18 : return { 'age_0-18' : 1 } elif x [ 'age' ] <= 32 : return { 'age_19-32' : 1 } elif x [ 'age' ] < 55 : return { 'age_33-54' : 1 } else : return { 'age_55-100' : 1 } Let's put everything together: fm_params = { 'n_factors' : 14 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FMRegressor ( ** fm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.760059, RMSE: 0.961415 \u2013 0:00:12 \u2013 1.42 MB [50,000] MAE: 0.751429, RMSE: 0.951504 \u2013 0:00:24 \u2013 1.66 MB [75,000] MAE: 0.750568, RMSE: 0.951592 \u2013 0:00:37 \u2013 1.93 MB [100,000] MAE: 0.75018, RMSE: 0.951622 \u2013 0:00:49 \u2013 2.18 MB Note that using more variables involves factorizing a larger latent space, then increasing the number of latent factors \\(k\\) often helps capturing more information. Some other feature engineering tips from 3 idiots' winning solution for Kaggle Criteo display ads competition in 2014: Infrequent modalities often bring noise and little information, transforming them into a special tag can help In some cases, sample-wise normalization seems to make the optimization problem easier to be solved","title":"Feature engineering for FM models"},{"location":"examples/matrix-factorization-for-recommender-systems-part-2/#higher-order-factorization-machines-hofm","text":"The model equation generalized to any order \\(d \\geq 2\\) is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right) \\] hofm_params = { 'degree' : 3 , 'n_factors' : 12 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . HOFMRegressor ( ** hofm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761379, RMSE: 0.96214 \u2013 0:01:07 \u2013 2.59 MB [50,000] MAE: 0.751998, RMSE: 0.951589 \u2013 0:02:13 \u2013 3.05 MB [75,000] MAE: 0.750994, RMSE: 0.951616 \u2013 0:03:19 \u2013 3.56 MB [100,000] MAE: 0.750849, RMSE: 0.952142 \u2013 0:04:25 \u2013 4.03 MB As said previously, high-order interactions are often hard to estimate due to too much sparsity, that's why we won't spend too much time here.","title":"Higher-Order Factorization Machines (HOFM)"},{"location":"examples/matrix-factorization-for-recommender-systems-part-2/#field-aware-factorization-machines-ffm","text":"Field-aware variant of FM (FFM) improved the original method by adding the notion of \" fields \". A \" field \" is a group of features that belong to a specific domain (e.g. the \" users \" field, the \" items \" field, or the \" movie genres \" field). FFM restricts itself to pairwise interactions and factorizes separated latent spaces \u2014 one per combination of fields (e.g. users/items, users/movie genres, or items/movie genres) \u2014 instead of a common one shared by all fields. Therefore, each feature has one latent vector per field it can interact with \u2014 so that it can learn the specific effect with each different field. The model equation is defined by: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_{j}} \\rangle x_{j} x_{j'} \\] Where \\(f_j\\) and \\(f_{j'}\\) are the fields corresponding to \\(j\\) and \\(j'\\) features, respectively. ffm_params = { 'n_factors' : 8 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FFMRegressor ( ** ffm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.758339, RMSE: 0.959047 \u2013 0:00:18 \u2013 3 MB [50,000] MAE: 0.749833, RMSE: 0.948531 \u2013 0:00:36 \u2013 3.54 MB [75,000] MAE: 0.749631, RMSE: 0.949418 \u2013 0:00:55 \u2013 4.14 MB [100,000] MAE: 0.749776, RMSE: 0.950131 \u2013 0:01:13 \u2013 4.69 MB Note that FFM usually needs to learn smaller number of latent factors \\(k\\) than FM as each latent vector only deals with one field.","title":"Field-aware Factorization Machines (FFM)"},{"location":"examples/matrix-factorization-for-recommender-systems-part-2/#field-weighted-factorization-machines-fwfm","text":"Field-weighted Factorization Machines (FwFM) address FFM memory issues caused by its large number of parameters, which is in the order of feature number times field number . As FFM, FwFM is an extension of FM restricted to pairwise interactions, but instead of factorizing separated latent spaces, it learns a specific weight \\(r_{f_j, f_{j'}}\\) for each field combination modelling the interaction strength. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] fwfm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'seed' : 73 , } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FwFMRegressor ( ** fwfm_params ) model = meta . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761435, RMSE: 0.962211 \u2013 0:00:23 \u2013 1.17 MB [50,000] MAE: 0.754063, RMSE: 0.953248 \u2013 0:00:47 \u2013 1.36 MB [75,000] MAE: 0.754729, RMSE: 0.95507 \u2013 0:01:11 \u2013 1.58 MB [100,000] MAE: 0.755697, RMSE: 0.956542 \u2013 0:01:35 \u2013 1.77 MB","title":"Field-weighted Factorization Machines (FwFM)"},{"location":"examples/matrix-factorization-for-recommender-systems-part-3/","text":"Matrix Factorization for Recommender Systems - Part 3 \u00b6 Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning To do.","title":"Matrix Factorization for Recommender Systems - Part 3"},{"location":"examples/matrix-factorization-for-recommender-systems-part-3/#matrix-factorization-for-recommender-systems-part-3","text":"Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning To do.","title":"Matrix Factorization for Recommender Systems - Part 3"},{"location":"examples/quantile-regression-uncertainty/","text":"Handling uncertainty with quantile regression \u00b6 % matplotlib inline Quantile regression is useful when you're not so much interested in the accuracy of your model, but rather you want your model to be good at ranking observations correctly. The typical way to perform quantile regression is to use a special loss function, namely the quantile loss. The quantile loss takes a parameter, \\(\\alpha\\) (alpha), which indicates which quantile the model should be targeting. In the case of \\(\\alpha = 0.5\\) , then this is equivalent to asking the model to predict the median value of the target, and not the most likely value which would be the mean. A nice thing we can do with quantile regression is to produce a prediction interval for each prediction. Indeed, if we predict the lower and upper quantiles of the target then we will be able to obtain a \"trust region\" in between which the true value is likely to belong. Of course, the likeliness will depend on the chosen quantiles. For a slightly more detailed explanation see this blog post. As an example, let us take the simple time series model we built in another notebook . Instead of predicting the mean value of the target distribution, we will predict the 5th, 50th, 95th quantiles. This will require training three separate models, so we will encapsulate the model building logic in a function called make_model . We also have to slightly adapt the training loop, but not by much. Finally, we will draw the prediction interval along with the predictions from for 50th quantile (i.e. the median) and the true values. import calendar import math import matplotlib.pyplot as plt from river import compose from river import datasets from river import linear_model from river import metrics from river import optim from river import preprocessing from river import stats from river import time_series def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } def make_model ( alpha ): extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 3 ), loss = optim . losses . Quantile ( alpha = alpha ) ) model = extract_features | scale | learn model = time_series . Detrender ( regressor = model , window_size = 12 ) return model metric = metrics . MAE () models = { 'lower' : make_model ( alpha = 0.05 ), 'center' : make_model ( alpha = 0.5 ), 'upper' : make_model ( alpha = 0.95 ) } dates = [] y_trues = [] y_preds = { 'lower' : [], 'center' : [], 'upper' : [] } for x , y in datasets . AirlinePassengers (): y_trues . append ( y ) dates . append ( x [ 'month' ]) for name , model in models . items (): y_preds [ name ] . append ( model . predict_one ( x )) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_preds [ 'center' ][ - 1 ]) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Truth' ) ax . plot ( dates , y_preds [ 'center' ], lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . fill_between ( dates , y_preds [ 'lower' ], y_preds [ 'upper' ], color = '#e74c3c' , alpha = 0.3 , label = 'Prediction interval' ) ax . legend () ax . set_title ( metric ); Text(0.5, 1.0, 'MAE: 15.634343') An important thing to note is that the prediction interval we obtained should not be confused with a confidence interval. Simply put, a prediction interval represents uncertainty for where the true value lies, whereas a confidence interval encapsulates the uncertainty on the prediction. You can find out more by reading this CrossValidated post.","title":"Handling uncertainty with quantile regression"},{"location":"examples/quantile-regression-uncertainty/#handling-uncertainty-with-quantile-regression","text":"% matplotlib inline Quantile regression is useful when you're not so much interested in the accuracy of your model, but rather you want your model to be good at ranking observations correctly. The typical way to perform quantile regression is to use a special loss function, namely the quantile loss. The quantile loss takes a parameter, \\(\\alpha\\) (alpha), which indicates which quantile the model should be targeting. In the case of \\(\\alpha = 0.5\\) , then this is equivalent to asking the model to predict the median value of the target, and not the most likely value which would be the mean. A nice thing we can do with quantile regression is to produce a prediction interval for each prediction. Indeed, if we predict the lower and upper quantiles of the target then we will be able to obtain a \"trust region\" in between which the true value is likely to belong. Of course, the likeliness will depend on the chosen quantiles. For a slightly more detailed explanation see this blog post. As an example, let us take the simple time series model we built in another notebook . Instead of predicting the mean value of the target distribution, we will predict the 5th, 50th, 95th quantiles. This will require training three separate models, so we will encapsulate the model building logic in a function called make_model . We also have to slightly adapt the training loop, but not by much. Finally, we will draw the prediction interval along with the predictions from for 50th quantile (i.e. the median) and the true values. import calendar import math import matplotlib.pyplot as plt from river import compose from river import datasets from river import linear_model from river import metrics from river import optim from river import preprocessing from river import stats from river import time_series def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } def make_model ( alpha ): extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 3 ), loss = optim . losses . Quantile ( alpha = alpha ) ) model = extract_features | scale | learn model = time_series . Detrender ( regressor = model , window_size = 12 ) return model metric = metrics . MAE () models = { 'lower' : make_model ( alpha = 0.05 ), 'center' : make_model ( alpha = 0.5 ), 'upper' : make_model ( alpha = 0.95 ) } dates = [] y_trues = [] y_preds = { 'lower' : [], 'center' : [], 'upper' : [] } for x , y in datasets . AirlinePassengers (): y_trues . append ( y ) dates . append ( x [ 'month' ]) for name , model in models . items (): y_preds [ name ] . append ( model . predict_one ( x )) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_preds [ 'center' ][ - 1 ]) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Truth' ) ax . plot ( dates , y_preds [ 'center' ], lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . fill_between ( dates , y_preds [ 'lower' ], y_preds [ 'upper' ], color = '#e74c3c' , alpha = 0.3 , label = 'Prediction interval' ) ax . legend () ax . set_title ( metric ); Text(0.5, 1.0, 'MAE: 15.634343') An important thing to note is that the prediction interval we obtained should not be confused with a confidence interval. Simply put, a prediction interval represents uncertainty for where the true value lies, whereas a confidence interval encapsulates the uncertainty on the prediction. You can find out more by reading this CrossValidated post.","title":"Handling uncertainty with quantile regression"},{"location":"examples/sentence_classification/","text":"Sentence classification \u00b6 In this tutorial we will try to predict whether an SMS is a spam or not. To train our model, we will use the SMSSpam dataset. This dataset is unbalanced, there is only 13.4% spam. Let's look at the data: from river import datasets datasets . SMSSpam () SMS Spam Collection dataset. The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not. Name SMSSpam Task Binary classification Samples 5,574 Features 1 Sparse False Path /Users/home/river_data/SMSSpam/SMSSpamCollection URL https://archive.ics.uci.edu/ml/machine-learning-databases/00228/smsspamcollection.zip Size 466.71 KB Downloaded True from pprint import pprint X_y = datasets . SMSSpam () for x , y in X_y : pprint ( x ) print ( f 'Spam: { y } ' ) break {'body': 'Go until jurong point, crazy.. Available only in bugis n great world ' 'la e buffet... Cine there got amore wat...\\n'} Spam: False Let's start by building a simple model like a Naive Bayes classifier. We will first preprocess the sentences with a TF-IDF transform that our model can consume. Then, we will measure the accuracy of our model with the AUC metric. This is the right metric to use when the classes are not balanced. In addition, the Naive Bayes models can perform very well on unbalanced datasets and can be used for both binary and multi-class classification problems. from river import feature_extraction from river import naive_bayes from river import metrics def extract_body ( x ): \"\"\"Extract the body of the sms.\"\"\" return x [ 'body' ] X_y = datasets . SMSSpam () model = ( extract_body | feature_extraction . TFIDF () | naive_bayes . BernoulliNB ( alpha = 0 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) if y_pred is not None : metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.929296 The confusion matrix: cm False True False 4809 17 True 103 644 The results are quite good with this first model. Since we are working with an unbalanced dataset, we can use the imblearn module to rebalance the classes of our dataset. For more information about the imblearn module, you can find a dedicated tutorial here . from river import imblearn X_y = datasets . SMSSpam () model = ( extract_body | feature_extraction . TFIDF () | imblearn . RandomUnderSampler ( classifier = naive_bayes . BernoulliNB ( alpha = 0 ), desired_dist = { 0 : . 5 , 1 : . 5 }, seed = 42 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) if y_pred is not None : metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.951728 The imblearn module improved our results. Not bad! We can visualize the pipeline to understand how the data is processed. The confusion matrix: cm False True False 4624 201 True 41 706 model . draw () Now let's try to use logistic regression to classify messages. We will use different tips to make my model perform better. As in the previous example, we rebalance the classes of our dataset. The logistics regression will be fed from a TF-IDF. from river import linear_model from river import optim from river import preprocessing X_y = datasets . SMSSpam () model = ( extract_body | feature_extraction . TFIDF () | preprocessing . Normalizer () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression ( optimizer = optim . SGD ( . 9 ), loss = optim . losses . Log () ), desired_dist = { 0 : . 5 , 1 : . 5 }, seed = 42 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.946039 The confusion matrix: cm False True False 4655 172 True 54 693 model . draw () The results of the logistic regression are quite good but still inferior to the naive Bayes model. Let's try to use word embeddings to improve our logistic regression. Word embeddings allow you to represent a word as a vector. Embeddings are developed to build semantically rich vectors. For instance, the vector which represents the word python should be close to the vector which represents the word programming . We will use spaCy to convert our sentence to vectors. spaCy converts a sentence to a vector by calculating the average of the embeddings of the words in the sentence. You can download pre-trained embeddings in many languages. We will use English pre-trained embeddings as our SMS are in English. The command below allows you to download the pre-trained embeddings that spaCy makes available. More informations about spaCy and its installation may be found here here . python -m spacy download en_core_web_sm Here, we create a custom transformer to convert an input sentence to a dict of floats. We will integrate this transformer into our pipeline. import spacy from river.base import Transformer class Embeddings ( Transformer ): \"\"\"My custom transformer, word embedding using spaCy.\"\"\" def __init__ ( self ): self . embeddings = spacy . load ( 'en_core_web_sm' ) def transform_one ( self , x , y = None ): return { dimension : xi for dimension , xi in enumerate ( self . embeddings ( x ) . vector )} Let's train our logistic regression: X_y = datasets . SMSSpam () model = ( extract_body | Embeddings () | preprocessing . Normalizer () | imblearn . RandomOverSampler ( classifier = linear_model . LogisticRegression ( optimizer = optim . SGD ( . 5 ), loss = optim . losses . Log () ), desired_dist = { 0 : . 5 , 1 : . 5 }, seed = 42 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.91568 The confusion matrix: cm False True False 4517 310 True 78 669 model . draw () The results of the logistic regression using spaCy embeddings are lower than those obtained with TF-IDF values. We could surely improve the results by cleaning up the text. We could also use embeddings more suited to our dataset. However, on this problem, the logistic regression is not better than the Naive Bayes model. No free lunch today.","title":"Sentence classification"},{"location":"examples/sentence_classification/#sentence-classification","text":"In this tutorial we will try to predict whether an SMS is a spam or not. To train our model, we will use the SMSSpam dataset. This dataset is unbalanced, there is only 13.4% spam. Let's look at the data: from river import datasets datasets . SMSSpam () SMS Spam Collection dataset. The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not. Name SMSSpam Task Binary classification Samples 5,574 Features 1 Sparse False Path /Users/home/river_data/SMSSpam/SMSSpamCollection URL https://archive.ics.uci.edu/ml/machine-learning-databases/00228/smsspamcollection.zip Size 466.71 KB Downloaded True from pprint import pprint X_y = datasets . SMSSpam () for x , y in X_y : pprint ( x ) print ( f 'Spam: { y } ' ) break {'body': 'Go until jurong point, crazy.. Available only in bugis n great world ' 'la e buffet... Cine there got amore wat...\\n'} Spam: False Let's start by building a simple model like a Naive Bayes classifier. We will first preprocess the sentences with a TF-IDF transform that our model can consume. Then, we will measure the accuracy of our model with the AUC metric. This is the right metric to use when the classes are not balanced. In addition, the Naive Bayes models can perform very well on unbalanced datasets and can be used for both binary and multi-class classification problems. from river import feature_extraction from river import naive_bayes from river import metrics def extract_body ( x ): \"\"\"Extract the body of the sms.\"\"\" return x [ 'body' ] X_y = datasets . SMSSpam () model = ( extract_body | feature_extraction . TFIDF () | naive_bayes . BernoulliNB ( alpha = 0 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) if y_pred is not None : metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.929296 The confusion matrix: cm False True False 4809 17 True 103 644 The results are quite good with this first model. Since we are working with an unbalanced dataset, we can use the imblearn module to rebalance the classes of our dataset. For more information about the imblearn module, you can find a dedicated tutorial here . from river import imblearn X_y = datasets . SMSSpam () model = ( extract_body | feature_extraction . TFIDF () | imblearn . RandomUnderSampler ( classifier = naive_bayes . BernoulliNB ( alpha = 0 ), desired_dist = { 0 : . 5 , 1 : . 5 }, seed = 42 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) if y_pred is not None : metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.951728 The imblearn module improved our results. Not bad! We can visualize the pipeline to understand how the data is processed. The confusion matrix: cm False True False 4624 201 True 41 706 model . draw () Now let's try to use logistic regression to classify messages. We will use different tips to make my model perform better. As in the previous example, we rebalance the classes of our dataset. The logistics regression will be fed from a TF-IDF. from river import linear_model from river import optim from river import preprocessing X_y = datasets . SMSSpam () model = ( extract_body | feature_extraction . TFIDF () | preprocessing . Normalizer () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression ( optimizer = optim . SGD ( . 9 ), loss = optim . losses . Log () ), desired_dist = { 0 : . 5 , 1 : . 5 }, seed = 42 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.946039 The confusion matrix: cm False True False 4655 172 True 54 693 model . draw () The results of the logistic regression are quite good but still inferior to the naive Bayes model. Let's try to use word embeddings to improve our logistic regression. Word embeddings allow you to represent a word as a vector. Embeddings are developed to build semantically rich vectors. For instance, the vector which represents the word python should be close to the vector which represents the word programming . We will use spaCy to convert our sentence to vectors. spaCy converts a sentence to a vector by calculating the average of the embeddings of the words in the sentence. You can download pre-trained embeddings in many languages. We will use English pre-trained embeddings as our SMS are in English. The command below allows you to download the pre-trained embeddings that spaCy makes available. More informations about spaCy and its installation may be found here here . python -m spacy download en_core_web_sm Here, we create a custom transformer to convert an input sentence to a dict of floats. We will integrate this transformer into our pipeline. import spacy from river.base import Transformer class Embeddings ( Transformer ): \"\"\"My custom transformer, word embedding using spaCy.\"\"\" def __init__ ( self ): self . embeddings = spacy . load ( 'en_core_web_sm' ) def transform_one ( self , x , y = None ): return { dimension : xi for dimension , xi in enumerate ( self . embeddings ( x ) . vector )} Let's train our logistic regression: X_y = datasets . SMSSpam () model = ( extract_body | Embeddings () | preprocessing . Normalizer () | imblearn . RandomOverSampler ( classifier = linear_model . LogisticRegression ( optimizer = optim . SGD ( . 5 ), loss = optim . losses . Log () ), desired_dist = { 0 : . 5 , 1 : . 5 }, seed = 42 ) ) metric = metrics . ROCAUC () cm = metrics . ConfusionMatrix () for x , y in X_y : y_pred = model . predict_one ( x ) metric . update ( y_pred = y_pred , y_true = y ) cm . update ( y_pred = y_pred , y_true = y ) model . learn_one ( x , y ) metric ROCAUC: 0.91568 The confusion matrix: cm False True False 4517 310 True 78 669 model . draw () The results of the logistic regression using spaCy embeddings are lower than those obtained with TF-IDF values. We could surely improve the results by cleaning up the text. We could also use embeddings more suited to our dataset. However, on this problem, the logistic regression is not better than the Naive Bayes model. No free lunch today.","title":"Sentence classification"},{"location":"examples/the-art-of-using-pipelines/","text":"The art of using pipelines \u00b6 Pipelines are a natural way to think about a machine learning system. Indeed with some practice a data scientist can visualise data \"flowing\" through a series of steps. The input is typically some raw data which has to be processed in some manner. The goal is to represent the data in such a way that is can be ingested by a machine learning algorithm. Along the way some steps will extract features, while others will normalize the data and remove undesirable elements. Pipelines are simple, and yet they are a powerful way of designing sophisticated machine learning systems. Both scikit-learn and pandas make it possible to use pipelines. However it's quite rare to see pipelines being used in practice (at least on Kaggle). Sometimes you get to see people using scikit-learn's pipeline module, however the pipe method from pandas is sadly underappreciated. A big reason why pipelines are not given much love is that it's easier to think of batch learning in terms of a script or a notebook. Indeed many people doing data science seem to prefer a procedural style to a declarative style. Moreover in practice pipelines can be a bit rigid if one wishes to do non-orthodox operations. Although pipelines may be a bit of an odd fit for batch learning, they make complete sense when they are used for online learning. Indeed the UNIX philosophy has advocated the use of pipelines for data processing for many decades. If you can visualise data as a stream of observations then using pipelines should make a lot of sense to you. We'll attempt to convince you by writing a machine learning algorithm in a procedural way and then converting it to a declarative pipeline in small steps. Hopefully by the end you'll be convinced, or not! In this notebook we'll manipulate data from the Kaggle Recruit Restaurants Visitor Forecasting competition . The data is directly available through river 's datasets module. from pprint import pprint from river import datasets for x , y in datasets . Restaurants (): pprint ( x ) pprint ( y ) break Downloading https://maxhalford.github.io/files/datasets/kaggle_recruit_restaurants.zip (4.28 MB) Uncompressing into /home/runner/river_data/Restaurants {'area_name': 'T\u014dky\u014d-to Nerima-ku Toyotamakita', 'date': datetime.datetime(2016, 1, 1, 0, 0), 'genre_name': 'Izakaya', 'is_holiday': True, 'latitude': 35.7356234, 'longitude': 139.6516577, 'store_id': 'air_04341b588bde96cd'} 10 We'll start by building and running a model using a procedural coding style. The performance of the model doesn't matter, we're simply interested in the design of the model. from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats means = ( feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) scaler = preprocessing . StandardScaler () lin_reg = linear_model . LinearRegression () metric = metrics . MAE () for x , y in datasets . Restaurants (): # Derive date features x [ 'weekday' ] = x [ 'date' ] . weekday () x [ 'is_weekend' ] = x [ 'date' ] . weekday () in ( 5 , 6 ) # Process the rolling means of the target for mean in means : x = { ** x , ** mean . transform_one ( x )} mean . learn_one ( x , y ) # Remove the key/value pairs that aren't features for key in [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ]: x . pop ( key ) # Rescale the data x = scaler . learn_one ( x ) . transform_one ( x ) # Fit the linear regression y_pred = lin_reg . predict_one ( x ) lin_reg . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.465114 We're not using many features. We can print the last x to get an idea of the features (don't forget they've been scaled!) pprint ( x ) {'is_holiday': -0.23103573677646685, 'is_weekend': 1.6249280076334165, 'target_rollingmean_14_by_store_id': -1.4125913815779154, 'target_rollingmean_21_by_store_id': -1.3980979075298519, 'target_rollingmean_7_by_store_id': -1.3502314499809096, 'weekday': 1.0292832579142892} The above chunk of code is quite explicit but it's a bit verbose. The whole point of libraries such as river is to make life easier for users. Moreover there's too much space for users to mess up the order in which things are done, which increases the chance of there being target leakage. We'll now rewrite our model in a declarative fashion using a pipeline \u00e0 la sklearn . from river import compose def get_date_features ( x ): weekday = x [ 'date' ] . weekday () return { 'weekday' : weekday , 'is_weekend' : weekday in ( 5 , 6 )} model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) metric = metrics . MAE () for x , y in datasets . Restaurants (): # Make a prediction without using the target y_pred = model . predict_one ( x ) # Update the model using the target model . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.38533 We use a Pipeline to arrange each step in a sequential order. A TransformerUnion is used to merge multiple feature extractors into a single transformer. The for loop is now much shorter and is thus easier to grok: we get the out-of-fold prediction, we fit the model, and finally we update the metric. This way of evaluating a model is typical of online learning, and so we put it wrapped it inside a function called progressive_val_score part of the evaluate module. We can use it to replace the for loop. from river import evaluate model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) evaluate . progressive_val_score ( dataset = datasets . Restaurants (), model = model , metric = metrics . MAE ()) MAE: 8.38533 Notice that you couldn't have used the progressive_val_score method if you wrote the model in a procedural manner. Our code is getting shorter, but it's still a bit difficult on the eyes. Indeed there is a lot of boilerplate code associated with pipelines that can get tedious to write. However river has some special tricks up it's sleeve to save you from a lot of pain. The first trick is that the name of each step in the pipeline can be omitted. If no name is given for a step then river automatically infers one. model = compose . Pipeline ( compose . TransformerUnion ( compose . FuncTransformer ( get_date_features ), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Under the hood a Pipeline inherits from collections.OrderedDict . Indeed this makes sense because if you think about it a Pipeline is simply a sequence of steps where each step has a name. The reason we mention this is because it means you can manipulate a Pipeline the same way you would manipulate an ordinary dict . For instance we can print the name of each step by using the keys method. for name in model . steps : print ( name ) TransformerUnion Discard StandardScaler LinearRegression The first step is a FeatureUnion and it's string representation contains the string representation of each of it's elements. Not having to write names saves up some time and space and is certainly less tedious. The next trick is that we can use mathematical operators to compose our pipeline. For example we can use the + operator to merge Transformer s into a TransformerUnion . model = compose . Pipeline ( compose . FuncTransformer ( get_date_features ) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Likewhise we can use the | operator to assemble steps into a Pipeline . model = ( compose . FuncTransformer ( get_date_features ) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) to_discard = [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ] model = model | compose . Discard ( * to_discard ) | preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Hopefully you'll agree that this is a powerful way to express machine learning pipelines. For some people this should be quite remeniscent of the UNIX pipe operator. One final trick we want to mention is that functions are automatically wrapped with a FuncTransformer , which can be quite handy. model = get_date_features for n in [ 7 , 14 , 21 ]: model += feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( n )) model |= compose . Discard ( * to_discard ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Naturally some may prefer the procedural style we first used because they find it easier to work with. It all depends on your style and you should use what you feel comfortable with. However we encourage you to use operators because we believe that this will increase the readability of your code, which is very important. To each their own! Before finishing we can take a look at what our pipeline looks graphically. model . draw ()","title":"The art of using pipelines"},{"location":"examples/the-art-of-using-pipelines/#the-art-of-using-pipelines","text":"Pipelines are a natural way to think about a machine learning system. Indeed with some practice a data scientist can visualise data \"flowing\" through a series of steps. The input is typically some raw data which has to be processed in some manner. The goal is to represent the data in such a way that is can be ingested by a machine learning algorithm. Along the way some steps will extract features, while others will normalize the data and remove undesirable elements. Pipelines are simple, and yet they are a powerful way of designing sophisticated machine learning systems. Both scikit-learn and pandas make it possible to use pipelines. However it's quite rare to see pipelines being used in practice (at least on Kaggle). Sometimes you get to see people using scikit-learn's pipeline module, however the pipe method from pandas is sadly underappreciated. A big reason why pipelines are not given much love is that it's easier to think of batch learning in terms of a script or a notebook. Indeed many people doing data science seem to prefer a procedural style to a declarative style. Moreover in practice pipelines can be a bit rigid if one wishes to do non-orthodox operations. Although pipelines may be a bit of an odd fit for batch learning, they make complete sense when they are used for online learning. Indeed the UNIX philosophy has advocated the use of pipelines for data processing for many decades. If you can visualise data as a stream of observations then using pipelines should make a lot of sense to you. We'll attempt to convince you by writing a machine learning algorithm in a procedural way and then converting it to a declarative pipeline in small steps. Hopefully by the end you'll be convinced, or not! In this notebook we'll manipulate data from the Kaggle Recruit Restaurants Visitor Forecasting competition . The data is directly available through river 's datasets module. from pprint import pprint from river import datasets for x , y in datasets . Restaurants (): pprint ( x ) pprint ( y ) break Downloading https://maxhalford.github.io/files/datasets/kaggle_recruit_restaurants.zip (4.28 MB) Uncompressing into /home/runner/river_data/Restaurants {'area_name': 'T\u014dky\u014d-to Nerima-ku Toyotamakita', 'date': datetime.datetime(2016, 1, 1, 0, 0), 'genre_name': 'Izakaya', 'is_holiday': True, 'latitude': 35.7356234, 'longitude': 139.6516577, 'store_id': 'air_04341b588bde96cd'} 10 We'll start by building and running a model using a procedural coding style. The performance of the model doesn't matter, we're simply interested in the design of the model. from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats means = ( feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) scaler = preprocessing . StandardScaler () lin_reg = linear_model . LinearRegression () metric = metrics . MAE () for x , y in datasets . Restaurants (): # Derive date features x [ 'weekday' ] = x [ 'date' ] . weekday () x [ 'is_weekend' ] = x [ 'date' ] . weekday () in ( 5 , 6 ) # Process the rolling means of the target for mean in means : x = { ** x , ** mean . transform_one ( x )} mean . learn_one ( x , y ) # Remove the key/value pairs that aren't features for key in [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ]: x . pop ( key ) # Rescale the data x = scaler . learn_one ( x ) . transform_one ( x ) # Fit the linear regression y_pred = lin_reg . predict_one ( x ) lin_reg . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.465114 We're not using many features. We can print the last x to get an idea of the features (don't forget they've been scaled!) pprint ( x ) {'is_holiday': -0.23103573677646685, 'is_weekend': 1.6249280076334165, 'target_rollingmean_14_by_store_id': -1.4125913815779154, 'target_rollingmean_21_by_store_id': -1.3980979075298519, 'target_rollingmean_7_by_store_id': -1.3502314499809096, 'weekday': 1.0292832579142892} The above chunk of code is quite explicit but it's a bit verbose. The whole point of libraries such as river is to make life easier for users. Moreover there's too much space for users to mess up the order in which things are done, which increases the chance of there being target leakage. We'll now rewrite our model in a declarative fashion using a pipeline \u00e0 la sklearn . from river import compose def get_date_features ( x ): weekday = x [ 'date' ] . weekday () return { 'weekday' : weekday , 'is_weekend' : weekday in ( 5 , 6 )} model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) metric = metrics . MAE () for x , y in datasets . Restaurants (): # Make a prediction without using the target y_pred = model . predict_one ( x ) # Update the model using the target model . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.38533 We use a Pipeline to arrange each step in a sequential order. A TransformerUnion is used to merge multiple feature extractors into a single transformer. The for loop is now much shorter and is thus easier to grok: we get the out-of-fold prediction, we fit the model, and finally we update the metric. This way of evaluating a model is typical of online learning, and so we put it wrapped it inside a function called progressive_val_score part of the evaluate module. We can use it to replace the for loop. from river import evaluate model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) evaluate . progressive_val_score ( dataset = datasets . Restaurants (), model = model , metric = metrics . MAE ()) MAE: 8.38533 Notice that you couldn't have used the progressive_val_score method if you wrote the model in a procedural manner. Our code is getting shorter, but it's still a bit difficult on the eyes. Indeed there is a lot of boilerplate code associated with pipelines that can get tedious to write. However river has some special tricks up it's sleeve to save you from a lot of pain. The first trick is that the name of each step in the pipeline can be omitted. If no name is given for a step then river automatically infers one. model = compose . Pipeline ( compose . TransformerUnion ( compose . FuncTransformer ( get_date_features ), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Under the hood a Pipeline inherits from collections.OrderedDict . Indeed this makes sense because if you think about it a Pipeline is simply a sequence of steps where each step has a name. The reason we mention this is because it means you can manipulate a Pipeline the same way you would manipulate an ordinary dict . For instance we can print the name of each step by using the keys method. for name in model . steps : print ( name ) TransformerUnion Discard StandardScaler LinearRegression The first step is a FeatureUnion and it's string representation contains the string representation of each of it's elements. Not having to write names saves up some time and space and is certainly less tedious. The next trick is that we can use mathematical operators to compose our pipeline. For example we can use the + operator to merge Transformer s into a TransformerUnion . model = compose . Pipeline ( compose . FuncTransformer ( get_date_features ) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Likewhise we can use the | operator to assemble steps into a Pipeline . model = ( compose . FuncTransformer ( get_date_features ) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) to_discard = [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ] model = model | compose . Discard ( * to_discard ) | preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Hopefully you'll agree that this is a powerful way to express machine learning pipelines. For some people this should be quite remeniscent of the UNIX pipe operator. One final trick we want to mention is that functions are automatically wrapped with a FuncTransformer , which can be quite handy. model = get_date_features for n in [ 7 , 14 , 21 ]: model += feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( n )) model |= compose . Discard ( * to_discard ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Naturally some may prefer the procedural style we first used because they find it easier to work with. It all depends on your style and you should use what you feel comfortable with. However we encourage you to use operators because we believe that this will increase the readability of your code, which is very important. To each their own! Before finishing we can take a look at what our pipeline looks graphically. model . draw ()","title":"The art of using pipelines"},{"location":"faq/faq/","text":"Frequently Asked Questions \u00b6 Do all classifiers support multi-class classification? No, they don't. Although binary classification can be seen as a special case of multi-class classification, there are many optimizations that can be performed if we know that there are only two classes. It would be annoying to have to check whether this is the case in an online setting. All in all we find that separating both cases leads to much cleaner code. Note that the multiclass module contains wrapper models that enable you to perform multi-class classification with binary classifiers. How do I know if a classifier supports multi-class classification? Each classifier that is part of river is either a base.BinaryClassifier or a base.MultiClassifier . You can use Python's isinstance function to check for a particular classifier, as so: >>> from river import base >>> from river import linear_model >>> classifier = linear_model . LogisticRegression () >>> isinstance ( classifier , base . BinaryClassifier ) True >>> isinstance ( classifier , base . MultiClassifier ) False Why doesn't river do any input validation? Python encourages a coding style called EAFP , which stands for \"Easier to Ask for Forgiveness than Permission\". The idea is to assume that runtime errors don't occur, and instead use try/expects to catch errors. The great benefit is that we don't have to drown our code with if statements, which is symptomatic of the LBYL style , which stands for \"look before you leap\". This makes our implementations much more readable than, say, scikit-learn, which does a lot of input validation. The catch is that users have to be careful to use sane inputs. As always, there is no free lunch ! What about reinforcement learning? Reinforcement learning works in an online manner because of the nature of the task. Reinforcement learning can be therefore be seen as a subcase of online machine learning. However, we prefer not to support it because there are already many existing opensource libraries dedicated to it. What are the differences between scikit-learn's online learning algorithm which have a partial_fit method and their equivalents in river? The algorithms from sklearn that support incremental learning are mostly meant for mini-batch learning. In a pure streaming context where the observations arrive one by one, then river is much faster than sklearn . This is mostly because sklearn incurs a lot of overhead by performing data checks. Also, sklearn assumes that you're always using the same number of features. This is not the case with river because it use dictionaries which allows you to drop and add features as you wish. How do I save and load models? >>> from river import ensemble >>> import pickle >>> model = ensemble . AdaptiveRandomForestClassifier () # save >>> with open ( 'model.pkl' , 'wb' ) as f : ... pickle . dump ( model , f ) # load >>> with open ( 'model.pkl' , 'rb' ) as f : ... model = pickle . load ( f ) We also encourage you to try out dill and cloudpickle . What about neural networks? There are many great open-source libraries for building neural network models. We don't feel that we can bring anything of value to the existing Python ecosystem. However, we are open to implementing compatibility wrappers for popular libraries such as PyTorch and Keras. Who are the authors of this library? We are research engineers, graduate students, PhDs and machine learning researchers. The members of the develompent team are mainly located in France, Brazil and New Zealand.","title":"Frequently Asked Questions"},{"location":"faq/faq/#frequently-asked-questions","text":"Do all classifiers support multi-class classification? No, they don't. Although binary classification can be seen as a special case of multi-class classification, there are many optimizations that can be performed if we know that there are only two classes. It would be annoying to have to check whether this is the case in an online setting. All in all we find that separating both cases leads to much cleaner code. Note that the multiclass module contains wrapper models that enable you to perform multi-class classification with binary classifiers. How do I know if a classifier supports multi-class classification? Each classifier that is part of river is either a base.BinaryClassifier or a base.MultiClassifier . You can use Python's isinstance function to check for a particular classifier, as so: >>> from river import base >>> from river import linear_model >>> classifier = linear_model . LogisticRegression () >>> isinstance ( classifier , base . BinaryClassifier ) True >>> isinstance ( classifier , base . MultiClassifier ) False Why doesn't river do any input validation? Python encourages a coding style called EAFP , which stands for \"Easier to Ask for Forgiveness than Permission\". The idea is to assume that runtime errors don't occur, and instead use try/expects to catch errors. The great benefit is that we don't have to drown our code with if statements, which is symptomatic of the LBYL style , which stands for \"look before you leap\". This makes our implementations much more readable than, say, scikit-learn, which does a lot of input validation. The catch is that users have to be careful to use sane inputs. As always, there is no free lunch ! What about reinforcement learning? Reinforcement learning works in an online manner because of the nature of the task. Reinforcement learning can be therefore be seen as a subcase of online machine learning. However, we prefer not to support it because there are already many existing opensource libraries dedicated to it. What are the differences between scikit-learn's online learning algorithm which have a partial_fit method and their equivalents in river? The algorithms from sklearn that support incremental learning are mostly meant for mini-batch learning. In a pure streaming context where the observations arrive one by one, then river is much faster than sklearn . This is mostly because sklearn incurs a lot of overhead by performing data checks. Also, sklearn assumes that you're always using the same number of features. This is not the case with river because it use dictionaries which allows you to drop and add features as you wish. How do I save and load models? >>> from river import ensemble >>> import pickle >>> model = ensemble . AdaptiveRandomForestClassifier () # save >>> with open ( 'model.pkl' , 'wb' ) as f : ... pickle . dump ( model , f ) # load >>> with open ( 'model.pkl' , 'rb' ) as f : ... model = pickle . load ( f ) We also encourage you to try out dill and cloudpickle . What about neural networks? There are many great open-source libraries for building neural network models. We don't feel that we can bring anything of value to the existing Python ecosystem. However, we are open to implementing compatibility wrappers for popular libraries such as PyTorch and Keras. Who are the authors of this library? We are research engineers, graduate students, PhDs and machine learning researchers. The members of the develompent team are mainly located in France, Brazil and New Zealand.","title":"Frequently Asked Questions"},{"location":"getting-started/getting-started/","text":"Getting started \u00b6 First things first, make sure you have installed river . In river , features are represented with dictionaries, where the keys correspond to the features names. For instance: import datetime as dt x = { 'shop' : 'Ikea' , 'city' : 'Stockholm' , 'date' : dt . datetime ( 2020 , 6 , 1 ), 'sales' : 42 } It is up to you, the user, to decide how to stream your data. river offers a stream module which has various utilities for handling streaming data, such as stream.iter_csv . For the sake of example, river also provides a datasets module which contains various streaming datasets. For example, the datasets.Phishing dataset contains records of phishing attempts on web pages. from river import datasets dataset = datasets . Phishing () print ( dataset ) Phishing websites. This dataset contains features from web pages that are classified as phishing or not. Name Phishing Task Binary classification Samples 1,250 Features 9 Sparse False Path /home/runner/work/river/river/river/datasets/phishing.csv.gz The dataset is a streaming dataset, and therefore doesn't sit in memory. Instead, we can loop over each sample with a for loop: for x , y in dataset : pass print ( x ) {'empty_server_form_handler': 1.0, 'popup_window': 0.5, 'https': 1.0, 'request_from_other_domain': 1.0, 'anchor_from_other_domain': 1.0, 'is_popular': 0.5, 'long_url': 0.0, 'age_of_domain': 0, 'ip_in_url': 0} print ( y ) False Typically, models learn via a learn_one(x, y) method, which takes as input some features and a target value. Being able to learn with a single instance gives a lot of flexibility. For instance, a model can be updated whenever a new sample arrives from a stream. To exemplify this, let's train a logistic regression on the above dataset. from river import linear_model model = linear_model . LogisticRegression () for x , y in dataset : model . learn_one ( x , y ) Predictions can be obtained by calling a model's predict_one method. In the case of a classifier, we can also use predict_proba_one to produce probability estimates. model = linear_model . LogisticRegression () for x , y in dataset : y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) print ( y_pred ) {False: 0.7731541581376543, True: 0.22684584186234572} The metrics module gives access to many metrics that are commonly used in machine learning. Like the rest of river , these metrics can be updated with one element at a time: from river import metrics model = linear_model . LogisticRegression () metric = metrics . ROCAUC () for x , y in dataset : y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric ROCAUC: 0.893565 A common way to improve the performance of a logistic regression is to scale the data. This can be done by using a preprocessing.StandardScaler . In particular, we can define a pipeline to organise our model into a sequence of steps: from river import compose from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) model . draw () metric = metrics . ROCAUC () for x , y in datasets . Phishing (): y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric ROCAUC: 0.950363 As we can see, the model is performing much better now that the data is being scaled. Under the hood, the standard scaler maintains a running average and a running variance for each feature in the dataset. Each feature is thus scaled according to the average and the variance seen up to every given point in time. This concludes this short guide to getting started with river . There is a lot more to discover and understand. Head towards the user guide for recipes on how to perform common machine learning tasks. You may also consult the API reference , which is a catalogue of all the modules that river exposes. Finally, the examples section contains comprehensive examples for various usecases.","title":"In a nutshell"},{"location":"getting-started/getting-started/#getting-started","text":"First things first, make sure you have installed river . In river , features are represented with dictionaries, where the keys correspond to the features names. For instance: import datetime as dt x = { 'shop' : 'Ikea' , 'city' : 'Stockholm' , 'date' : dt . datetime ( 2020 , 6 , 1 ), 'sales' : 42 } It is up to you, the user, to decide how to stream your data. river offers a stream module which has various utilities for handling streaming data, such as stream.iter_csv . For the sake of example, river also provides a datasets module which contains various streaming datasets. For example, the datasets.Phishing dataset contains records of phishing attempts on web pages. from river import datasets dataset = datasets . Phishing () print ( dataset ) Phishing websites. This dataset contains features from web pages that are classified as phishing or not. Name Phishing Task Binary classification Samples 1,250 Features 9 Sparse False Path /home/runner/work/river/river/river/datasets/phishing.csv.gz The dataset is a streaming dataset, and therefore doesn't sit in memory. Instead, we can loop over each sample with a for loop: for x , y in dataset : pass print ( x ) {'empty_server_form_handler': 1.0, 'popup_window': 0.5, 'https': 1.0, 'request_from_other_domain': 1.0, 'anchor_from_other_domain': 1.0, 'is_popular': 0.5, 'long_url': 0.0, 'age_of_domain': 0, 'ip_in_url': 0} print ( y ) False Typically, models learn via a learn_one(x, y) method, which takes as input some features and a target value. Being able to learn with a single instance gives a lot of flexibility. For instance, a model can be updated whenever a new sample arrives from a stream. To exemplify this, let's train a logistic regression on the above dataset. from river import linear_model model = linear_model . LogisticRegression () for x , y in dataset : model . learn_one ( x , y ) Predictions can be obtained by calling a model's predict_one method. In the case of a classifier, we can also use predict_proba_one to produce probability estimates. model = linear_model . LogisticRegression () for x , y in dataset : y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) print ( y_pred ) {False: 0.7731541581376543, True: 0.22684584186234572} The metrics module gives access to many metrics that are commonly used in machine learning. Like the rest of river , these metrics can be updated with one element at a time: from river import metrics model = linear_model . LogisticRegression () metric = metrics . ROCAUC () for x , y in dataset : y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric ROCAUC: 0.893565 A common way to improve the performance of a logistic regression is to scale the data. This can be done by using a preprocessing.StandardScaler . In particular, we can define a pipeline to organise our model into a sequence of steps: from river import compose from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) model . draw () metric = metrics . ROCAUC () for x , y in datasets . Phishing (): y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric ROCAUC: 0.950363 As we can see, the model is performing much better now that the data is being scaled. Under the hood, the standard scaler maintains a running average and a running variance for each feature in the dataset. Each feature is thus scaled according to the average and the variance seen up to every given point in time. This concludes this short guide to getting started with river . There is a lot more to discover and understand. Head towards the user guide for recipes on how to perform common machine learning tasks. You may also consult the API reference , which is a catalogue of all the modules that river exposes. Finally, the examples section contains comprehensive examples for various usecases.","title":"Getting started"},{"location":"getting-started/installation/","text":"Installation \u00b6 river is intended to work with Python 3.6 or above . Installation can be done via pip : pip install git+git://github.com/online-ml/river.git@v0.1.0 You can install the latest development version from GitHub as so: pip install git+https://github.com/online-ml/river --upgrade Or, through SSH: pip install git+ssh://git@github.com/online-ml/river.git --upgrade Feel welcome to open an issue on GitHub if you are having any trouble.","title":"Installation"},{"location":"getting-started/installation/#installation","text":"river is intended to work with Python 3.6 or above . Installation can be done via pip : pip install git+git://github.com/online-ml/river.git@v0.1.0 You can install the latest development version from GitHub as so: pip install git+https://github.com/online-ml/river --upgrade Or, through SSH: pip install git+ssh://git@github.com/online-ml/river.git --upgrade Feel welcome to open an issue on GitHub if you are having any trouble.","title":"Installation"},{"location":"releases/0.0.2/","text":"0.0.2 - 2019-02-13 \u00b6 PyPI GitHub compat \u00b6 Added sklearn wrappers. ensemble \u00b6 Added ensemble.HedgeClassifier . feature_selection \u00b6 Added feature_selection.RandomDiscarder . feature_extraction \u00b6 Added feature_extraction.TargetEncoder . impute \u00b6 Added impute.NumericImputer . optim \u00b6 Added optim.AbsoluteLoss . Added optim.HingeLoss . Added optim.EpsilonInsensitiveHingeLoss . stats \u00b6 Added stats.NUnique . Added stats.Min . Added stats.Max . Added stats.PeakToPeak . Added stats.Kurtosis . Added stats.Skew . Added stats.Sum . Added stats.EWMean . Made sure the running statistics produce the same results as pandas.DataFrame.rolling method.","title":"0.0.2 - 2019-02-13"},{"location":"releases/0.0.2/#002-2019-02-13","text":"PyPI GitHub","title":"0.0.2 - 2019-02-13"},{"location":"releases/0.0.2/#compat","text":"Added sklearn wrappers.","title":"compat"},{"location":"releases/0.0.2/#ensemble","text":"Added ensemble.HedgeClassifier .","title":"ensemble"},{"location":"releases/0.0.2/#feature_selection","text":"Added feature_selection.RandomDiscarder .","title":"feature_selection"},{"location":"releases/0.0.2/#feature_extraction","text":"Added feature_extraction.TargetEncoder .","title":"feature_extraction"},{"location":"releases/0.0.2/#impute","text":"Added impute.NumericImputer .","title":"impute"},{"location":"releases/0.0.2/#optim","text":"Added optim.AbsoluteLoss . Added optim.HingeLoss . Added optim.EpsilonInsensitiveHingeLoss .","title":"optim"},{"location":"releases/0.0.2/#stats","text":"Added stats.NUnique . Added stats.Min . Added stats.Max . Added stats.PeakToPeak . Added stats.Kurtosis . Added stats.Skew . Added stats.Sum . Added stats.EWMean . Made sure the running statistics produce the same results as pandas.DataFrame.rolling method.","title":"stats"},{"location":"releases/0.0.3/","text":"0.0.3 - 2019-03-21 \u00b6 PyPI GitHub base \u00b6 Calling fit_one now returns the calling instance, not the out-of-fold prediction/transform; fit_predict_one , fit_predict_proba_one , and fit_transform_one are available to reproduce the previous behavior. Binary classifiers now output a dict with probabilities for False and True when calling predict_proba_one , which solves the interface issues of having multi-class classifiers do binary classification. compat \u00b6 Added compat.convert_river_to_sklearn . compose \u00b6 Added compose.BoxCoxTransformRegressor . Added compose.TargetModifierRegressor . datasets \u00b6 Added datasets.fetch_restaurants . Added datasets.load_airline . dist \u00b6 Added dist.Multinomial . Added dist.Normal . ensemble \u00b6 Added ensemble.BaggingRegressor . feature_extraction \u00b6 Added feature_extraction.TargetGroupBy . impute \u00b6 Added impute.CategoricalImputer . linear_model \u00b6 Added linear_model.FMRegressor . Removed all the passive-aggressive estimators. metrics \u00b6 Added metrics.Accuracy . Added metrics.MAE . Added metrics.MSE . Added metrics.RMSE . Added metrics.RMSLE . Added metrics.SMAPE . Added metrics.Precision . Added metrics.Recall . Added metrics.F1 . model_selection \u00b6 model_selection.online_score can now be passed a metrics.Metric instead of an sklearn metric; it also checks that the provided metric can be used with the accompanying model. naive_bayes \u00b6 Added naive_bayes.GaussianNB . optim \u00b6 Added optim.PassiveAggressiveI . Added optim.PassiveAggressiveII . preprocessing \u00b6 Added preprocessing.Discarder . Added preprocessing.PolynomialExtender . Added preprocessing.FuncTransformer . reco \u00b6 Added reco.SVD . stats \u00b6 Added stats.Mode . Added stats.Quantile . Added stats.RollingQuantile . Added stats.Entropy . Added stats.RollingMin . Added stats.RollingMax . Added stats.RollingMode . Added stats.RollingSum . Added stats.RollingPeakToPeak . stream \u00b6 Added stream.iter_csv . tree \u00b6 Added tree.MondrianTreeClassifier . Added tree.MondrianTreeRegressor .","title":"0.0.3 - 2019-03-21"},{"location":"releases/0.0.3/#003-2019-03-21","text":"PyPI GitHub","title":"0.0.3 - 2019-03-21"},{"location":"releases/0.0.3/#base","text":"Calling fit_one now returns the calling instance, not the out-of-fold prediction/transform; fit_predict_one , fit_predict_proba_one , and fit_transform_one are available to reproduce the previous behavior. Binary classifiers now output a dict with probabilities for False and True when calling predict_proba_one , which solves the interface issues of having multi-class classifiers do binary classification.","title":"base"},{"location":"releases/0.0.3/#compat","text":"Added compat.convert_river_to_sklearn .","title":"compat"},{"location":"releases/0.0.3/#compose","text":"Added compose.BoxCoxTransformRegressor . Added compose.TargetModifierRegressor .","title":"compose"},{"location":"releases/0.0.3/#datasets","text":"Added datasets.fetch_restaurants . Added datasets.load_airline .","title":"datasets"},{"location":"releases/0.0.3/#dist","text":"Added dist.Multinomial . Added dist.Normal .","title":"dist"},{"location":"releases/0.0.3/#ensemble","text":"Added ensemble.BaggingRegressor .","title":"ensemble"},{"location":"releases/0.0.3/#feature_extraction","text":"Added feature_extraction.TargetGroupBy .","title":"feature_extraction"},{"location":"releases/0.0.3/#impute","text":"Added impute.CategoricalImputer .","title":"impute"},{"location":"releases/0.0.3/#linear_model","text":"Added linear_model.FMRegressor . Removed all the passive-aggressive estimators.","title":"linear_model"},{"location":"releases/0.0.3/#metrics","text":"Added metrics.Accuracy . Added metrics.MAE . Added metrics.MSE . Added metrics.RMSE . Added metrics.RMSLE . Added metrics.SMAPE . Added metrics.Precision . Added metrics.Recall . Added metrics.F1 .","title":"metrics"},{"location":"releases/0.0.3/#model_selection","text":"model_selection.online_score can now be passed a metrics.Metric instead of an sklearn metric; it also checks that the provided metric can be used with the accompanying model.","title":"model_selection"},{"location":"releases/0.0.3/#naive_bayes","text":"Added naive_bayes.GaussianNB .","title":"naive_bayes"},{"location":"releases/0.0.3/#optim","text":"Added optim.PassiveAggressiveI . Added optim.PassiveAggressiveII .","title":"optim"},{"location":"releases/0.0.3/#preprocessing","text":"Added preprocessing.Discarder . Added preprocessing.PolynomialExtender . Added preprocessing.FuncTransformer .","title":"preprocessing"},{"location":"releases/0.0.3/#reco","text":"Added reco.SVD .","title":"reco"},{"location":"releases/0.0.3/#stats","text":"Added stats.Mode . Added stats.Quantile . Added stats.RollingQuantile . Added stats.Entropy . Added stats.RollingMin . Added stats.RollingMax . Added stats.RollingMode . Added stats.RollingSum . Added stats.RollingPeakToPeak .","title":"stats"},{"location":"releases/0.0.3/#stream","text":"Added stream.iter_csv .","title":"stream"},{"location":"releases/0.0.3/#tree","text":"Added tree.MondrianTreeClassifier . Added tree.MondrianTreeRegressor .","title":"tree"},{"location":"releases/0.1.0/","text":"0.1.0 - 2019-05-08 \u00b6 PyPI GitHub base \u00b6 Removed the fit_predict_one estimator method. Removed the fit_predict_proba_one estimator method. Removed the fit_transform_one estimator method. compat \u00b6 Added compat.convert_sklearn_to_river . compat.convert_river_to_sklearn now returns an sklearn.pipeline.Pipeline when provided with a compose.Pipeline . compose \u00b6 Added compose.Discard . Added compose.Select . Added compose.SplitRegressor . The draw method of compose.Pipeline now works properly for arbitrary amounts of nesting, including multiple nested compose.FeatureUnion . datasets \u00b6 Added datasets.fetch_electricity . dummy \u00b6 Added dummy.NoChangeClassifier . Added dummy.PriorClassifier . Added dummy.StatisticRegressor . feature_extraction \u00b6 Added feature_extraction.Differ . Renamed feature_extraction.GroupBy to feature_extraction.Agg . Renamed feature_extraction.TargetGroupBy to feature_extraction.TargetAgg . feature_selection \u00b6 Added feature_selection.SelectKBest . Added feature_selection.VarianceThreshold . impute \u00b6 Added impute.StatImputer . Removed impute.CategoricalImputer . Removed impute.NumericImputer . linear_model \u00b6 Added linear_model.PAClassifier . Added linear_model.PARegressor . Added linear_model.SoftmaxRegression . metrics \u00b6 Added metrics.ConfusionMatrix . Added metrics.CrossEntropy . Added metrics.MacroF1 . Added metrics.MacroPrecision . Added metrics.MacroRecall . Added metrics.MicroF1 . Added metrics.MicroPrecision . Added metrics.MicroRecall . Each metric now has a bigger_is_better property to indicate if a high value is better than a low one or not. optim \u00b6 Added optim.OptimalLR . Added optim.CrossEntropy . Removed optim.PassiveAggressiveI . Removed optim.PassiveAggressiveII . preprocessing \u00b6 Removed preprocessing.Discarder . Added on and sparse parameters to preprocessing.OneHotEncoder . stats \u00b6 Added stats.Covariance . Added stats.PearsonCorrelation . Added stats.SmoothMean . utils \u00b6 Added utils.check_estimator . Added utils.Histogram . Added utils.SortedWindow . Added utils.Window .","title":"0.1.0 - 2019-05-08"},{"location":"releases/0.1.0/#010-2019-05-08","text":"PyPI GitHub","title":"0.1.0 - 2019-05-08"},{"location":"releases/0.1.0/#base","text":"Removed the fit_predict_one estimator method. Removed the fit_predict_proba_one estimator method. Removed the fit_transform_one estimator method.","title":"base"},{"location":"releases/0.1.0/#compat","text":"Added compat.convert_sklearn_to_river . compat.convert_river_to_sklearn now returns an sklearn.pipeline.Pipeline when provided with a compose.Pipeline .","title":"compat"},{"location":"releases/0.1.0/#compose","text":"Added compose.Discard . Added compose.Select . Added compose.SplitRegressor . The draw method of compose.Pipeline now works properly for arbitrary amounts of nesting, including multiple nested compose.FeatureUnion .","title":"compose"},{"location":"releases/0.1.0/#datasets","text":"Added datasets.fetch_electricity .","title":"datasets"},{"location":"releases/0.1.0/#dummy","text":"Added dummy.NoChangeClassifier . Added dummy.PriorClassifier . Added dummy.StatisticRegressor .","title":"dummy"},{"location":"releases/0.1.0/#feature_extraction","text":"Added feature_extraction.Differ . Renamed feature_extraction.GroupBy to feature_extraction.Agg . Renamed feature_extraction.TargetGroupBy to feature_extraction.TargetAgg .","title":"feature_extraction"},{"location":"releases/0.1.0/#feature_selection","text":"Added feature_selection.SelectKBest . Added feature_selection.VarianceThreshold .","title":"feature_selection"},{"location":"releases/0.1.0/#impute","text":"Added impute.StatImputer . Removed impute.CategoricalImputer . Removed impute.NumericImputer .","title":"impute"},{"location":"releases/0.1.0/#linear_model","text":"Added linear_model.PAClassifier . Added linear_model.PARegressor . Added linear_model.SoftmaxRegression .","title":"linear_model"},{"location":"releases/0.1.0/#metrics","text":"Added metrics.ConfusionMatrix . Added metrics.CrossEntropy . Added metrics.MacroF1 . Added metrics.MacroPrecision . Added metrics.MacroRecall . Added metrics.MicroF1 . Added metrics.MicroPrecision . Added metrics.MicroRecall . Each metric now has a bigger_is_better property to indicate if a high value is better than a low one or not.","title":"metrics"},{"location":"releases/0.1.0/#optim","text":"Added optim.OptimalLR . Added optim.CrossEntropy . Removed optim.PassiveAggressiveI . Removed optim.PassiveAggressiveII .","title":"optim"},{"location":"releases/0.1.0/#preprocessing","text":"Removed preprocessing.Discarder . Added on and sparse parameters to preprocessing.OneHotEncoder .","title":"preprocessing"},{"location":"releases/0.1.0/#stats","text":"Added stats.Covariance . Added stats.PearsonCorrelation . Added stats.SmoothMean .","title":"stats"},{"location":"releases/0.1.0/#utils","text":"Added utils.check_estimator . Added utils.Histogram . Added utils.SortedWindow . Added utils.Window .","title":"utils"},{"location":"releases/0.2.0/","text":"0.2.0 - 2019-05-27 \u00b6 PyPI GitHub compose \u00b6 compose.Pipeline now has a debug_one . compose.Discard and compose.Select now take variadic inputs, which means you don't have to provide a list of features to exclude/include. datasets \u00b6 Added datasets.fetch_bikes feature_extraction \u00b6 Classes that inherit from feature_extraction.VectorizerMixin can now directly be passed str instances instead of dict instances. feature_extraction.Agg and feature_extraction.TargetAgg can now aggregate on multiple attributes. metrics \u00b6 Added RollingAccuracy Added RollingCrossEntropy Added RollingF1 Added RollingLogLoss Added RollingMacroF1 Added RollingMacroPrecision Added RollingMacroRecall Added RollingMAE Added RollingMicroF1 Added RollingMicroPrecision Added RollingMicroRecall Added RollingMSE Added RollingPrecision Added RollingRecall Added RollingRMSE Added RollingRMSLE Added RollingSMAPE model_selection \u00b6 Added model_selection.online_qa_score . proba \u00b6 The dist module has been renamed to proba and is now public, for the moment it contains a single distribution called proba.Gaussian . naive_bayes \u00b6 Added naive_bayes.BernoulliNB . Added naive_bayes.ComplementNB . optim \u00b6 Added optim.AdaBound . tree \u00b6 Added tree.DecisionTreeClassifier . Removed tree.MondrianTreeClassifier and tree.MondrianTreeRegressor because their performance wasn't good enough. stats \u00b6 Added stats.AutoCorrelation . Added stats.EWVar . Rename stats.Variance to stats.Var and stats.RollingVariance to stats.RollingVar . stream \u00b6 Added stream.simulate_qa . utils \u00b6 Added utils.SDFT . Added utils.Skyline . Renamed the window_size parameter to size in utils.Window and utils.SortedWindow .","title":"0.2.0 - 2019-05-27"},{"location":"releases/0.2.0/#020-2019-05-27","text":"PyPI GitHub","title":"0.2.0 - 2019-05-27"},{"location":"releases/0.2.0/#compose","text":"compose.Pipeline now has a debug_one . compose.Discard and compose.Select now take variadic inputs, which means you don't have to provide a list of features to exclude/include.","title":"compose"},{"location":"releases/0.2.0/#datasets","text":"Added datasets.fetch_bikes","title":"datasets"},{"location":"releases/0.2.0/#feature_extraction","text":"Classes that inherit from feature_extraction.VectorizerMixin can now directly be passed str instances instead of dict instances. feature_extraction.Agg and feature_extraction.TargetAgg can now aggregate on multiple attributes.","title":"feature_extraction"},{"location":"releases/0.2.0/#metrics","text":"Added RollingAccuracy Added RollingCrossEntropy Added RollingF1 Added RollingLogLoss Added RollingMacroF1 Added RollingMacroPrecision Added RollingMacroRecall Added RollingMAE Added RollingMicroF1 Added RollingMicroPrecision Added RollingMicroRecall Added RollingMSE Added RollingPrecision Added RollingRecall Added RollingRMSE Added RollingRMSLE Added RollingSMAPE","title":"metrics"},{"location":"releases/0.2.0/#model_selection","text":"Added model_selection.online_qa_score .","title":"model_selection"},{"location":"releases/0.2.0/#proba","text":"The dist module has been renamed to proba and is now public, for the moment it contains a single distribution called proba.Gaussian .","title":"proba"},{"location":"releases/0.2.0/#naive_bayes","text":"Added naive_bayes.BernoulliNB . Added naive_bayes.ComplementNB .","title":"naive_bayes"},{"location":"releases/0.2.0/#optim","text":"Added optim.AdaBound .","title":"optim"},{"location":"releases/0.2.0/#tree","text":"Added tree.DecisionTreeClassifier . Removed tree.MondrianTreeClassifier and tree.MondrianTreeRegressor because their performance wasn't good enough.","title":"tree"},{"location":"releases/0.2.0/#stats","text":"Added stats.AutoCorrelation . Added stats.EWVar . Rename stats.Variance to stats.Var and stats.RollingVariance to stats.RollingVar .","title":"stats"},{"location":"releases/0.2.0/#stream","text":"Added stream.simulate_qa .","title":"stream"},{"location":"releases/0.2.0/#utils","text":"Added utils.SDFT . Added utils.Skyline . Renamed the window_size parameter to size in utils.Window and utils.SortedWindow .","title":"utils"},{"location":"releases/0.3.0/","text":"0.3.0 - 2019-06-23 \u00b6 PyPI GitHub datasets \u00b6 Added datasets.load_chick_weights . decomposition \u00b6 Added decomposition.LDA . ensemble \u00b6 Added ensemble.HedgeRegressor . Added ensemble.StackingBinaryClassifier . metrics \u00b6 Added metrics.FBeta Added metrics.MacroFBeta Added metrics.MicroFBeta Added metrics.MultiFBeta Added metrics.RollingFBeta Added metrics.RollingMacroFBeta Added metrics.RollingMicroFBeta Added metrics.RollingMultiFBeta Added metrics.Jaccard Added metrics.RollingConfusionMatrix Added metrics.RegressionMultiOutput Added metrics.MCC Added metrics.RollingMCC Added metrics.ROCAUC Renamed metrics.F1Score to metrics.F1 . multioutput \u00b6 Added multioutput.ClassifierChain . Added multioutput.RegressorChain . optim \u00b6 Added optim.QuantileLoss Added optim.MiniBatcher . preprocessing \u00b6 Added preprocessing.Normalizer . proba \u00b6 Added proba.Multinomial .","title":"0.3.0 - 2019-06-23"},{"location":"releases/0.3.0/#030-2019-06-23","text":"PyPI GitHub","title":"0.3.0 - 2019-06-23"},{"location":"releases/0.3.0/#datasets","text":"Added datasets.load_chick_weights .","title":"datasets"},{"location":"releases/0.3.0/#decomposition","text":"Added decomposition.LDA .","title":"decomposition"},{"location":"releases/0.3.0/#ensemble","text":"Added ensemble.HedgeRegressor . Added ensemble.StackingBinaryClassifier .","title":"ensemble"},{"location":"releases/0.3.0/#metrics","text":"Added metrics.FBeta Added metrics.MacroFBeta Added metrics.MicroFBeta Added metrics.MultiFBeta Added metrics.RollingFBeta Added metrics.RollingMacroFBeta Added metrics.RollingMicroFBeta Added metrics.RollingMultiFBeta Added metrics.Jaccard Added metrics.RollingConfusionMatrix Added metrics.RegressionMultiOutput Added metrics.MCC Added metrics.RollingMCC Added metrics.ROCAUC Renamed metrics.F1Score to metrics.F1 .","title":"metrics"},{"location":"releases/0.3.0/#multioutput","text":"Added multioutput.ClassifierChain . Added multioutput.RegressorChain .","title":"multioutput"},{"location":"releases/0.3.0/#optim","text":"Added optim.QuantileLoss Added optim.MiniBatcher .","title":"optim"},{"location":"releases/0.3.0/#preprocessing","text":"Added preprocessing.Normalizer .","title":"preprocessing"},{"location":"releases/0.3.0/#proba","text":"Added proba.Multinomial .","title":"proba"},{"location":"releases/0.4.1/","text":"0.4.1 - 2019-10-23 \u00b6 PyPI GitHub base \u00b6 Tests are now much more extensive, thanks mostly to the newly added estimator tags. compose \u00b6 Added compose.Renamer . datasets \u00b6 Added fetch_kdd99_http . Added fetch_sms . Added fetch_trec07p . ensemble \u00b6 Removed ensemble.HedgeBinaryClassifier because it's performance was subpar. Removed ensemble.GroupRegressor , as this should be a special case of ensemble.StackingRegressor . feature_extraction \u00b6 Fixed a bug where feature_extraction.CountVectorizer and feature_extraction.TFIDFVectorizer couldn't be pickled. linear_model \u00b6 linear_model.LogisticRegression and linear_model.LinearRegression now have an intercept_lr parameter. metrics \u00b6 Metrics can now be composed using the + operator, which is useful for evaluating multiple metrics at the same time. Added metrics.Rolling , which eliminates the need for a specific rolling implementation for each metric. Each metric can now be passed a sample_weight argument. Added metrics.WeightedF1 . Added metrics.WeightedFBeta . Added metrics.WeightedPrecision . Added metrics.WeightedRecall . neighbors \u00b6 Added neighbors.KNeighborsRegressor . Added neighbors.KNeighborsClassifier . optim \u00b6 Added optim.AdaMax . The optim module has been reorganized into submodules; namely optim.schedulers , optim.initializers , and optim.losses . The top-level now only contains optimizers. Some classes have been renamed accordingly. See the documentation for details. Renamed optim.VanillaSGD to optim.SGD . stats \u00b6 Added stats.IQR . Added stats.RollingIQR . Cythonized stats.Mean and stats.Var . stream \u00b6 Added stream.shuffle . stream.iter_csv now has fraction and seed parameters to sample rows, deterministically or not. Renamed stream.iter_numpy to stream.iter_array . stream.iter_csv can now read from gzipped files. time_series \u00b6 time_series.Detrender now has a window_size parameter for detrending with a rolling mean. tree \u00b6 Added tree.RandomForestClassifier . utils \u00b6 Fixed a bug where utils.dot could take longer than necessary.","title":"0.4.1 - 2019-10-23"},{"location":"releases/0.4.1/#041-2019-10-23","text":"PyPI GitHub","title":"0.4.1 - 2019-10-23"},{"location":"releases/0.4.1/#base","text":"Tests are now much more extensive, thanks mostly to the newly added estimator tags.","title":"base"},{"location":"releases/0.4.1/#compose","text":"Added compose.Renamer .","title":"compose"},{"location":"releases/0.4.1/#datasets","text":"Added fetch_kdd99_http . Added fetch_sms . Added fetch_trec07p .","title":"datasets"},{"location":"releases/0.4.1/#ensemble","text":"Removed ensemble.HedgeBinaryClassifier because it's performance was subpar. Removed ensemble.GroupRegressor , as this should be a special case of ensemble.StackingRegressor .","title":"ensemble"},{"location":"releases/0.4.1/#feature_extraction","text":"Fixed a bug where feature_extraction.CountVectorizer and feature_extraction.TFIDFVectorizer couldn't be pickled.","title":"feature_extraction"},{"location":"releases/0.4.1/#linear_model","text":"linear_model.LogisticRegression and linear_model.LinearRegression now have an intercept_lr parameter.","title":"linear_model"},{"location":"releases/0.4.1/#metrics","text":"Metrics can now be composed using the + operator, which is useful for evaluating multiple metrics at the same time. Added metrics.Rolling , which eliminates the need for a specific rolling implementation for each metric. Each metric can now be passed a sample_weight argument. Added metrics.WeightedF1 . Added metrics.WeightedFBeta . Added metrics.WeightedPrecision . Added metrics.WeightedRecall .","title":"metrics"},{"location":"releases/0.4.1/#neighbors","text":"Added neighbors.KNeighborsRegressor . Added neighbors.KNeighborsClassifier .","title":"neighbors"},{"location":"releases/0.4.1/#optim","text":"Added optim.AdaMax . The optim module has been reorganized into submodules; namely optim.schedulers , optim.initializers , and optim.losses . The top-level now only contains optimizers. Some classes have been renamed accordingly. See the documentation for details. Renamed optim.VanillaSGD to optim.SGD .","title":"optim"},{"location":"releases/0.4.1/#stats","text":"Added stats.IQR . Added stats.RollingIQR . Cythonized stats.Mean and stats.Var .","title":"stats"},{"location":"releases/0.4.1/#stream","text":"Added stream.shuffle . stream.iter_csv now has fraction and seed parameters to sample rows, deterministically or not. Renamed stream.iter_numpy to stream.iter_array . stream.iter_csv can now read from gzipped files.","title":"stream"},{"location":"releases/0.4.1/#time_series","text":"time_series.Detrender now has a window_size parameter for detrending with a rolling mean.","title":"time_series"},{"location":"releases/0.4.1/#tree","text":"Added tree.RandomForestClassifier .","title":"tree"},{"location":"releases/0.4.1/#utils","text":"Fixed a bug where utils.dot could take longer than necessary.","title":"utils"},{"location":"releases/0.4.3/","text":"0.4.3 - 2019-10-27 \u00b6 PyPI GitHub base \u00b6 Model that inherit from base.Wrapper (e.g. tree.RandomForestClassifier ) can now be pickled. datasets \u00b6 Added datasets.fetch_credit_card . utils \u00b6 Added the utils.math sub-module. tree \u00b6 Fixed the debug_one method of tree.DecisionTreeClassifier .","title":"0.4.3 - 2019-10-27"},{"location":"releases/0.4.3/#043-2019-10-27","text":"PyPI GitHub","title":"0.4.3 - 2019-10-27"},{"location":"releases/0.4.3/#base","text":"Model that inherit from base.Wrapper (e.g. tree.RandomForestClassifier ) can now be pickled.","title":"base"},{"location":"releases/0.4.3/#datasets","text":"Added datasets.fetch_credit_card .","title":"datasets"},{"location":"releases/0.4.3/#utils","text":"Added the utils.math sub-module.","title":"utils"},{"location":"releases/0.4.3/#tree","text":"Fixed the debug_one method of tree.DecisionTreeClassifier .","title":"tree"},{"location":"releases/0.4.4/","text":"0.4.4 - 2019-11-11 \u00b6 PyPI GitHub This release was mainly made to provide access to wheels <https://pythonwheels.com/> _ for Windows and MacOS. ensemble \u00b6 Added ensemble.AdaBoostClassifier . linear_model \u00b6 Added a clip_gradient parameter to linear_model.LinearRegression and linear_model.LogisticRegression . Gradient clipping was already implemented, but the maximum absolute value can now be set by the user. The intercept_lr parameter of linear_model.LinearRegression and linear_model.LogisticRegression can now be passed an instance of optim.schedulers.Scheduler as well as a float . metrics \u00b6 Fixed metrics.SMAPE , the implementation was missing a multiplication by 2. optim \u00b6 Added optim.schedulers.Optimal produces results that are identical to sklearn.linear_model.SGDRegressor and sklearn.linear_model.SGDClassifier when setting their learning_rate parameter to 'optimal' . time_series \u00b6 Added time_series.SNARIMAX , a generic model which encompasses well-known time series models such as ARIMA and NARX.","title":"0.4.4 - 2019-11-11"},{"location":"releases/0.4.4/#044-2019-11-11","text":"PyPI GitHub This release was mainly made to provide access to wheels <https://pythonwheels.com/> _ for Windows and MacOS.","title":"0.4.4 - 2019-11-11"},{"location":"releases/0.4.4/#ensemble","text":"Added ensemble.AdaBoostClassifier .","title":"ensemble"},{"location":"releases/0.4.4/#linear_model","text":"Added a clip_gradient parameter to linear_model.LinearRegression and linear_model.LogisticRegression . Gradient clipping was already implemented, but the maximum absolute value can now be set by the user. The intercept_lr parameter of linear_model.LinearRegression and linear_model.LogisticRegression can now be passed an instance of optim.schedulers.Scheduler as well as a float .","title":"linear_model"},{"location":"releases/0.4.4/#metrics","text":"Fixed metrics.SMAPE , the implementation was missing a multiplication by 2.","title":"metrics"},{"location":"releases/0.4.4/#optim","text":"Added optim.schedulers.Optimal produces results that are identical to sklearn.linear_model.SGDRegressor and sklearn.linear_model.SGDClassifier when setting their learning_rate parameter to 'optimal' .","title":"optim"},{"location":"releases/0.4.4/#time_series","text":"Added time_series.SNARIMAX , a generic model which encompasses well-known time series models such as ARIMA and NARX.","title":"time_series"},{"location":"releases/0.5.0/","text":"0.5.0 - 2020-03-13 \u00b6 PyPI GitHub compat \u00b6 Added compat.PyTorch2CremeRegressor . compat.SKL2CremeRegressor and compat.SKL2CremeClassifier now have an optional batch_size parameter in order to perform mini-batching. compose \u00b6 Renamed compose.Whitelister to compose.Select . Renamed compose.Blacklister to compose.Discard . facto \u00b6 Added facto.FFMClassifier . Added facto.FFMRegressor . Added facto.FwFMClassifier . Added facto.FwFMRegressor . Added facto.HOFMClassifier . Added facto.HOFMRegressor . Refactored facto.FMClassifier . Refactored facto.FMRegressor . feature_selection \u00b6 Added feature_selection.PoissonInclusion . Removed feature_selection.RandomDiscarder as it didn't make much sense. feature_extraction \u00b6 Renamed feature_extraction.CountVectorizer to feature_extraction.BagOfWords . Renamed feature_extraction.TFIDFVectorizer to feature_extraction.TFIDF . Added preprocessor and ngram_range parameters to feature_extraction.BagOfWords . Added preprocessor and ngram_range parameters to feature_extraction.TFIDF . datasets \u00b6 The datasets module has been overhauled. Each dataset is now a class (e.g. fetch_electricity has become datasets.Elec2 ). Added datasets.TrumpApproval . Added datasets.MaliciousURL . Added datasets.gen.SEA . Added datasets.Higgs . Added datasets.MovieLens100K . Added datasets.Bananas . Added datasets.Taxis . Added datasets.ImageSegments . Added datasets.SMTP impute \u00b6 Added impute.PreviousImputer . linear_model \u00b6 linear_model.FMClassifier has been moved to the facto module. linear_model.FMRegressor has been moved to the facto module. Added linear_model.ALMAClassifier . metrics \u00b6 Added metrics.ClassificationReport . Added metrics.TimeRolling . The implementation of metrics.ROCAUC was incorrect. Using the trapezoidal rule instead of Simpson's rule seems to be more robust. metrics.PerClass has been removed; it is recommended that you use metrics.ClassificationReport instead as it gives a better overview. meta \u00b6 Moved meta.TransformedTargetRegressor and meta.BoxCoxRegressor to this module (they were previously in the compose module). Added meta.PredClipper model_selection \u00b6 Added model_selection.expand_param_grid to generate a list of models from a grid of parameters. Added the model_selection.successive_halving method for selecting hyperparameters. The online_score and online_qa_score methods have been merged into a single method named model_selection.progressive_val_score . preprocessing \u00b6 Added preprocessing.RBFSampler . Added preprocessing.MaxAbsScaler . Added preprocessing.RobustScaler . Added preprocessing.Binarizer . Added with_mean and with_std parameters to preprocessing.StandardScaler . optim \u00b6 Added optim.losses.BinaryFocalLoss . Added the optim.AMSGrad optimizer. Added the optim.Nadam optimizer. Added optim.losses.Poisson . Fixed a performance bug in optim.NesterovMomentum . reco \u00b6 Added reco.FunkMF . Renamed reco.SVD to reco.BiasedMF . Renamed reco.SGDBaseline to reco.Baseline . Models now expect a dict input with user and item fields. sampling \u00b6 Added sampling.RandomUnderSampler . Added sampling.RandomOverSampler . Added sampling.RandomSampler . Added sampling.HardSamplingClassifier . Added sampling.HardSamplingRegressor . stats \u00b6 Added stats.AbsMax . Added stats.RollingAbsMax . stream \u00b6 Added stream.iter_libsvm . stream.iter_csv now supports reading from '.zip' files. Added stream.Cache . Added a drop parameter to stream.iter_csv to discard fields.","title":"0.5.0 - 2020-03-13"},{"location":"releases/0.5.0/#050-2020-03-13","text":"PyPI GitHub","title":"0.5.0 - 2020-03-13"},{"location":"releases/0.5.0/#compat","text":"Added compat.PyTorch2CremeRegressor . compat.SKL2CremeRegressor and compat.SKL2CremeClassifier now have an optional batch_size parameter in order to perform mini-batching.","title":"compat"},{"location":"releases/0.5.0/#compose","text":"Renamed compose.Whitelister to compose.Select . Renamed compose.Blacklister to compose.Discard .","title":"compose"},{"location":"releases/0.5.0/#facto","text":"Added facto.FFMClassifier . Added facto.FFMRegressor . Added facto.FwFMClassifier . Added facto.FwFMRegressor . Added facto.HOFMClassifier . Added facto.HOFMRegressor . Refactored facto.FMClassifier . Refactored facto.FMRegressor .","title":"facto"},{"location":"releases/0.5.0/#feature_selection","text":"Added feature_selection.PoissonInclusion . Removed feature_selection.RandomDiscarder as it didn't make much sense.","title":"feature_selection"},{"location":"releases/0.5.0/#feature_extraction","text":"Renamed feature_extraction.CountVectorizer to feature_extraction.BagOfWords . Renamed feature_extraction.TFIDFVectorizer to feature_extraction.TFIDF . Added preprocessor and ngram_range parameters to feature_extraction.BagOfWords . Added preprocessor and ngram_range parameters to feature_extraction.TFIDF .","title":"feature_extraction"},{"location":"releases/0.5.0/#datasets","text":"The datasets module has been overhauled. Each dataset is now a class (e.g. fetch_electricity has become datasets.Elec2 ). Added datasets.TrumpApproval . Added datasets.MaliciousURL . Added datasets.gen.SEA . Added datasets.Higgs . Added datasets.MovieLens100K . Added datasets.Bananas . Added datasets.Taxis . Added datasets.ImageSegments . Added datasets.SMTP","title":"datasets"},{"location":"releases/0.5.0/#impute","text":"Added impute.PreviousImputer .","title":"impute"},{"location":"releases/0.5.0/#linear_model","text":"linear_model.FMClassifier has been moved to the facto module. linear_model.FMRegressor has been moved to the facto module. Added linear_model.ALMAClassifier .","title":"linear_model"},{"location":"releases/0.5.0/#metrics","text":"Added metrics.ClassificationReport . Added metrics.TimeRolling . The implementation of metrics.ROCAUC was incorrect. Using the trapezoidal rule instead of Simpson's rule seems to be more robust. metrics.PerClass has been removed; it is recommended that you use metrics.ClassificationReport instead as it gives a better overview.","title":"metrics"},{"location":"releases/0.5.0/#meta","text":"Moved meta.TransformedTargetRegressor and meta.BoxCoxRegressor to this module (they were previously in the compose module). Added meta.PredClipper","title":"meta"},{"location":"releases/0.5.0/#model_selection","text":"Added model_selection.expand_param_grid to generate a list of models from a grid of parameters. Added the model_selection.successive_halving method for selecting hyperparameters. The online_score and online_qa_score methods have been merged into a single method named model_selection.progressive_val_score .","title":"model_selection"},{"location":"releases/0.5.0/#preprocessing","text":"Added preprocessing.RBFSampler . Added preprocessing.MaxAbsScaler . Added preprocessing.RobustScaler . Added preprocessing.Binarizer . Added with_mean and with_std parameters to preprocessing.StandardScaler .","title":"preprocessing"},{"location":"releases/0.5.0/#optim","text":"Added optim.losses.BinaryFocalLoss . Added the optim.AMSGrad optimizer. Added the optim.Nadam optimizer. Added optim.losses.Poisson . Fixed a performance bug in optim.NesterovMomentum .","title":"optim"},{"location":"releases/0.5.0/#reco","text":"Added reco.FunkMF . Renamed reco.SVD to reco.BiasedMF . Renamed reco.SGDBaseline to reco.Baseline . Models now expect a dict input with user and item fields.","title":"reco"},{"location":"releases/0.5.0/#sampling","text":"Added sampling.RandomUnderSampler . Added sampling.RandomOverSampler . Added sampling.RandomSampler . Added sampling.HardSamplingClassifier . Added sampling.HardSamplingRegressor .","title":"sampling"},{"location":"releases/0.5.0/#stats","text":"Added stats.AbsMax . Added stats.RollingAbsMax .","title":"stats"},{"location":"releases/0.5.0/#stream","text":"Added stream.iter_libsvm . stream.iter_csv now supports reading from '.zip' files. Added stream.Cache . Added a drop parameter to stream.iter_csv to discard fields.","title":"stream"},{"location":"releases/0.5.1/","text":"0.5.1 - 2020-03-29 \u00b6 PyPI GitHub compose \u00b6 compose.Pipeline and compose.TransformerUnion now variadic arguments as input instead of a list. This doesn't change anything when using the shorthand operators | and + . model_selection \u00b6 Removed model_selection.successive_halving Added model_selection.SuccessiveHalvingRegressor and model_selection.SuccessiveHalvingClassifier stream \u00b6 Added a copy parameter to stream.simulate_qa in order to handle unwanted feature modifications. tree \u00b6 Added a curtail_under parameter to tree.DecisionTreeClassifier . The speed and accuracy of both tree.DecisionTreeClassifier and tree.RandomForestClassifier has been slightly improved for numerical attributes. The esthetics of the tree.DecisionTreeClassifier.draw method have been improved.","title":"0.5.1 - 2020-03-29"},{"location":"releases/0.5.1/#051-2020-03-29","text":"PyPI GitHub","title":"0.5.1 - 2020-03-29"},{"location":"releases/0.5.1/#compose","text":"compose.Pipeline and compose.TransformerUnion now variadic arguments as input instead of a list. This doesn't change anything when using the shorthand operators | and + .","title":"compose"},{"location":"releases/0.5.1/#model_selection","text":"Removed model_selection.successive_halving Added model_selection.SuccessiveHalvingRegressor and model_selection.SuccessiveHalvingClassifier","title":"model_selection"},{"location":"releases/0.5.1/#stream","text":"Added a copy parameter to stream.simulate_qa in order to handle unwanted feature modifications.","title":"stream"},{"location":"releases/0.5.1/#tree","text":"Added a curtail_under parameter to tree.DecisionTreeClassifier . The speed and accuracy of both tree.DecisionTreeClassifier and tree.RandomForestClassifier has been slightly improved for numerical attributes. The esthetics of the tree.DecisionTreeClassifier.draw method have been improved.","title":"tree"},{"location":"releases/0.6.0/","text":"0.6.0 - 2020-06-09 \u00b6 base \u00b6 Added a new base class called SupervisedTransformer from which supervised transformers inherit from. Before this, supervised transformers has a is_supervised property. compose \u00b6 Added compose.SelectType , which allows selecting feature subsets based on their type. Added a score_one method to compose.Pipeline so that estimators from the anomaly module can be pipelined. Added compose.Grouper , which allows applying transformers within different subgroups. datasets \u00b6 Added datasets.Music , which is a dataset for multi-output binary classification. Added datasets.synth.Friedman , which is synthetic regression dataset. The datasets.gen module has been renamed to datasets.synth Each dataset now has a __repr__ method which displays some descriptive information. Added datasets.Insects , which has 10 variants. feature_extraction \u00b6 feature_extraction.Differ has been deprecated. We might put it back in a future if we find a better design. impute \u00b6 impute.StatImputer has been completely refactored. metrics \u00b6 In metrics.SMAPE , instead of raising a ZeroDivisionError , the convention is now to use 0 when both y_true and y_pred are equal to 0. model_selection \u00b6 Added the possibility to configure how the progress is printed in model_selection.progressive_val_score . For instance, the progress can now be printed to a file by providing the file argument. multiclass \u00b6 Added multiclass.OutputCodeClassifier . Added multiclass.OneVsOneClassifier . multioutput \u00b6 Fixed a bug where multioutput.ClassifierChain and multioutput.RegressorChain could not be pickled. stats \u00b6 Added stats.Shift , which can be used to compute statistics over a shifted version of a variable. Added stats.Link , which can be used to compose univariate statistics. Univariate statistics can now be composed via the | operator. Renamed stats.Covariance to stats.Cov . Renamed stats.PearsonCorrelation to stats.PearsonCorr . Renamed stats.AutoCorrelation to stats.AutoCorr . Added stats.RollingCov , which computes covariance between two variables over a window. Added stats.RollingPearsonCorr , which computes the Pearson correlation over a window. stream \u00b6 Added a stream.iter_sql utility method to work with SQLAlchemy. The target_name parameter of stream.iter_csv has been renamed to target . It can now be passed a list of values in order to support multi-output scenarios. Added stream.iter_arff for handling ARFF files. tree \u00b6 Cancelled the behavior where tree.DecisionTreeRegressor would raise an exception when no split was found.","title":"0.6.0 - 2020-06-09"},{"location":"releases/0.6.0/#060-2020-06-09","text":"","title":"0.6.0 - 2020-06-09"},{"location":"releases/0.6.0/#base","text":"Added a new base class called SupervisedTransformer from which supervised transformers inherit from. Before this, supervised transformers has a is_supervised property.","title":"base"},{"location":"releases/0.6.0/#compose","text":"Added compose.SelectType , which allows selecting feature subsets based on their type. Added a score_one method to compose.Pipeline so that estimators from the anomaly module can be pipelined. Added compose.Grouper , which allows applying transformers within different subgroups.","title":"compose"},{"location":"releases/0.6.0/#datasets","text":"Added datasets.Music , which is a dataset for multi-output binary classification. Added datasets.synth.Friedman , which is synthetic regression dataset. The datasets.gen module has been renamed to datasets.synth Each dataset now has a __repr__ method which displays some descriptive information. Added datasets.Insects , which has 10 variants.","title":"datasets"},{"location":"releases/0.6.0/#feature_extraction","text":"feature_extraction.Differ has been deprecated. We might put it back in a future if we find a better design.","title":"feature_extraction"},{"location":"releases/0.6.0/#impute","text":"impute.StatImputer has been completely refactored.","title":"impute"},{"location":"releases/0.6.0/#metrics","text":"In metrics.SMAPE , instead of raising a ZeroDivisionError , the convention is now to use 0 when both y_true and y_pred are equal to 0.","title":"metrics"},{"location":"releases/0.6.0/#model_selection","text":"Added the possibility to configure how the progress is printed in model_selection.progressive_val_score . For instance, the progress can now be printed to a file by providing the file argument.","title":"model_selection"},{"location":"releases/0.6.0/#multiclass","text":"Added multiclass.OutputCodeClassifier . Added multiclass.OneVsOneClassifier .","title":"multiclass"},{"location":"releases/0.6.0/#multioutput","text":"Fixed a bug where multioutput.ClassifierChain and multioutput.RegressorChain could not be pickled.","title":"multioutput"},{"location":"releases/0.6.0/#stats","text":"Added stats.Shift , which can be used to compute statistics over a shifted version of a variable. Added stats.Link , which can be used to compose univariate statistics. Univariate statistics can now be composed via the | operator. Renamed stats.Covariance to stats.Cov . Renamed stats.PearsonCorrelation to stats.PearsonCorr . Renamed stats.AutoCorrelation to stats.AutoCorr . Added stats.RollingCov , which computes covariance between two variables over a window. Added stats.RollingPearsonCorr , which computes the Pearson correlation over a window.","title":"stats"},{"location":"releases/0.6.0/#stream","text":"Added a stream.iter_sql utility method to work with SQLAlchemy. The target_name parameter of stream.iter_csv has been renamed to target . It can now be passed a list of values in order to support multi-output scenarios. Added stream.iter_arff for handling ARFF files.","title":"stream"},{"location":"releases/0.6.0/#tree","text":"Cancelled the behavior where tree.DecisionTreeRegressor would raise an exception when no split was found.","title":"tree"},{"location":"releases/0.6.1/","text":"0.6.1 - 2020-06-10 \u00b6 compose \u00b6 Fixed a bug that occurred when part of a compose.Transformer was a compose.Pipeline and wasn't properly handled.","title":"0.6.1 - 2020-06-10"},{"location":"releases/0.6.1/#061-2020-06-10","text":"","title":"0.6.1 - 2020-06-10"},{"location":"releases/0.6.1/#compose","text":"Fixed a bug that occurred when part of a compose.Transformer was a compose.Pipeline and wasn't properly handled.","title":"compose"},{"location":"releases/unreleased/","text":"Unreleased \u00b6 base \u00b6 The base.BinaryClassifier and base.MultiClassifier have been merge into base.Classifier . The 'binary_only' tag is now used to indicate whether or not a classifier support multi-class classification or not. compose \u00b6 Fixed some bugs related to mini-batching in compose.Pipeline . datasets \u00b6 Added datasets.SolarFlare , which is a small multi-output regression dataset. decomposition \u00b6 decomposition.LDA now takes as input word counts instead of raw text. expert \u00b6 Created this new module, which will regroup methods that perform expert learning, which boils down to managing multiple models. Moved ensemble.StackingBinaryClassifier to expert.StackingClassifier . Moved model_selection.SuccessiveHalvingClassifier to expert.SuccessiveHalvingClassifier . Moved model_selection.SuccessiveHalvingRegressor to expert.SuccessiveHalvingRegressor . Moved ensemble.HedgeRegressor to ensemble.EWARegressor . evaluate \u00b6 Created this new module, which will contains methods for evaluating models. feature_extraction \u00b6 Moved preprocessing.PolynomialExtender to feature_extraction.PolynomialExtender . Moved preprocessing.RBFSampler to feature_extraction.RBFSampler . linear_model \u00b6 Added linear_model.Perceptron , which is implemented as a special case of logistic regression. model_selection \u00b6 Deleted this module. multiclass \u00b6 multiclass.OneVsRestClassifier now supports mini-batching. optim \u00b6 Removed optim.MiniBatcher . Implemented optim.Averager , which allows doing averaged stochastic gradient descent. Removed optim.Perceptron . utils \u00b6 Moved model_selection.expand_param_grid to utils.expand_param_grid .","title":"Unreleased"},{"location":"releases/unreleased/#unreleased","text":"","title":"Unreleased"},{"location":"releases/unreleased/#base","text":"The base.BinaryClassifier and base.MultiClassifier have been merge into base.Classifier . The 'binary_only' tag is now used to indicate whether or not a classifier support multi-class classification or not.","title":"base"},{"location":"releases/unreleased/#compose","text":"Fixed some bugs related to mini-batching in compose.Pipeline .","title":"compose"},{"location":"releases/unreleased/#datasets","text":"Added datasets.SolarFlare , which is a small multi-output regression dataset.","title":"datasets"},{"location":"releases/unreleased/#decomposition","text":"decomposition.LDA now takes as input word counts instead of raw text.","title":"decomposition"},{"location":"releases/unreleased/#expert","text":"Created this new module, which will regroup methods that perform expert learning, which boils down to managing multiple models. Moved ensemble.StackingBinaryClassifier to expert.StackingClassifier . Moved model_selection.SuccessiveHalvingClassifier to expert.SuccessiveHalvingClassifier . Moved model_selection.SuccessiveHalvingRegressor to expert.SuccessiveHalvingRegressor . Moved ensemble.HedgeRegressor to ensemble.EWARegressor .","title":"expert"},{"location":"releases/unreleased/#evaluate","text":"Created this new module, which will contains methods for evaluating models.","title":"evaluate"},{"location":"releases/unreleased/#feature_extraction","text":"Moved preprocessing.PolynomialExtender to feature_extraction.PolynomialExtender . Moved preprocessing.RBFSampler to feature_extraction.RBFSampler .","title":"feature_extraction"},{"location":"releases/unreleased/#linear_model","text":"Added linear_model.Perceptron , which is implemented as a special case of logistic regression.","title":"linear_model"},{"location":"releases/unreleased/#model_selection","text":"Deleted this module.","title":"model_selection"},{"location":"releases/unreleased/#multiclass","text":"multiclass.OneVsRestClassifier now supports mini-batching.","title":"multiclass"},{"location":"releases/unreleased/#optim","text":"Removed optim.MiniBatcher . Implemented optim.Averager , which allows doing averaged stochastic gradient descent. Removed optim.Perceptron .","title":"optim"},{"location":"releases/unreleased/#utils","text":"Moved model_selection.expand_param_grid to utils.expand_param_grid .","title":"utils"},{"location":"user-guide/feature-extraction/","text":"Feature extraction \u00b6 To do.","title":"Feature extraction"},{"location":"user-guide/feature-extraction/#feature-extraction","text":"To do.","title":"Feature extraction"},{"location":"user-guide/hyperparameter-tuning/","text":"Hyperparameter tuning \u00b6 To do.","title":"Hyperparameter tuning"},{"location":"user-guide/hyperparameter-tuning/#hyperparameter-tuning","text":"To do.","title":"Hyperparameter tuning"},{"location":"user-guide/mini-batching/","text":"Mini-batching \u00b6 In its purest form, online machine learning encompasses models which learn with one sample at a time. This is the design which is used in river . The main downside of single-instance processing is that it doesn't scale to big data, at least not in the sense of traditional batch learning. Indeed, processing one sample at a time means that we are unable to fully take advantage of vectorisation and other computational tools that are taken for granted in batch learning. On top of this, processing a large dataset in river essentially involves a Python for loop, which might be too slow for some usecases. However, this doesn't mean that river is slow. In fact, for processing a single instance, river is actually a couple of orders of magnitude faster than libraries such as scikit-learn, PyTorch, and Tensorflow. The reason why is because river is designed from the ground up to process a single instance, whereas the majority of other libraries choose to care about batches of data. Both approaches offer different compromises, and the best choice depends on your usecase. In order to propose the best of both worlds, river offers some limited support for mini-batch learning. Some of river 's estimators implement *_many methods on top of their *_one counterparts. For instance, preprocessing.StandardScaler has a learn_many method as well as a transform_many method, in addition to learn_one and transform_one . Each mini-batch method takes as input a pandas.DataFrame . Supervised estimators also take as input a pandas.Series of target values. We choose to use pandas.DataFrames over numpy.ndarrays because of the simple fact that the former allows us to name each feature. This in turn allows us to offer a uniform interface for both single instance and mini-batch learning. As an example, we will build a simple pipeline that scales the data and trains a logistic regression. Indeed, the compose.Pipeline class can be applied to mini-batches, as long as each step is able to do so. from river import compose from river import linear_model from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) For this example, we will use datasets.Higgs . from river import datasets dataset = datasets . Higgs () if not dataset . is_downloaded : dataset . download () dataset Downloading https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz (2.62 GB) Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes. Name Higgs Task Binary classification Samples 11,000,000 Features 28 Sparse False Path /home/runner/river_data/Higgs/HIGGS.csv.gz URL https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz Size 2.62 GB Downloaded True The easiest way to read the data in a mini-batch fashion is to use the read_csv from pandas . import pandas as pd names = [ 'target' , 'lepton pT' , 'lepton eta' , 'lepton phi' , 'missing energy magnitude' , 'missing energy phi' , 'jet 1 pt' , 'jet 1 eta' , 'jet 1 phi' , 'jet 1 b-tag' , 'jet 2 pt' , 'jet 2 eta' , 'jet 2 phi' , 'jet 2 b-tag' , 'jet 3 pt' , 'jet 3 eta' , 'jet 3 phi' , 'jet 3 b-tag' , 'jet 4 pt' , 'jet 4 eta' , 'jet 4 phi' , 'jet 4 b-tag' , 'm_jj' , 'm_jjj' , 'm_lv' , 'm_jlv' , 'm_bb' , 'm_wbb' , 'm_wwbb' ] for x in pd . read_csv ( dataset . path , names = names , chunksize = 8096 , nrows = 3e5 ): y = x . pop ( 'target' ) y_pred = model . predict_proba_many ( x ) model . learn_many ( x , y ) If you are familiar with scikit-learn, you might be aware that some of their estimators have a partial_fit method, which is similar to river's learn_many method. Here are some advantages that river has over scikit-learn: We guarantee that river's is just as fast, if not faster than scikit-learn. The differences are negligeable, but are slightly in favor of river. We take as input dataframes, which allows us to name each feature. The benefit is that you can add/remove/permute features between batches and everything will keep working. Estimators that support mini-batches also support single instance learning. This means that you can enjoy the best of both worlds. For instance, you can train with mini-batches and use predict_one to make predictions. Note that you can check which estimators can process mini-batches programmatically: import importlib import inspect def can_mini_batch ( obj ): return hasattr ( obj , 'learn_many' ) for module in importlib . import_module ( 'river' ) . __all__ : if module in [ 'datasets' , 'synth' ]: continue for name , obj in inspect . getmembers ( importlib . import_module ( f 'river. { module } ' ), can_mini_batch ): print ( name ) MiniBatchClassifier MiniBatchRegressor SKL2RiverClassifier SKL2RiverRegressor Pipeline LinearRegression LogisticRegression Perceptron OneVsRestClassifier StandardScaler Because mini-batch learning isn't treated as a first-class citizen, some of the river's functionalities require some work in order to play nicely with mini-batches. For instance, the objects from the metrics module have an update method that take as input a single pair (y_true, y_pred) . This might change in the future, depending on the demand. We plan to promote more models to the mini-batch regime. However, we will only be doing so for the methods that benefit the most from it, as well as those that are most popular. Indeed, river 's core philosophy will remain to cater to single instance learning.","title":"Mini-batching"},{"location":"user-guide/mini-batching/#mini-batching","text":"In its purest form, online machine learning encompasses models which learn with one sample at a time. This is the design which is used in river . The main downside of single-instance processing is that it doesn't scale to big data, at least not in the sense of traditional batch learning. Indeed, processing one sample at a time means that we are unable to fully take advantage of vectorisation and other computational tools that are taken for granted in batch learning. On top of this, processing a large dataset in river essentially involves a Python for loop, which might be too slow for some usecases. However, this doesn't mean that river is slow. In fact, for processing a single instance, river is actually a couple of orders of magnitude faster than libraries such as scikit-learn, PyTorch, and Tensorflow. The reason why is because river is designed from the ground up to process a single instance, whereas the majority of other libraries choose to care about batches of data. Both approaches offer different compromises, and the best choice depends on your usecase. In order to propose the best of both worlds, river offers some limited support for mini-batch learning. Some of river 's estimators implement *_many methods on top of their *_one counterparts. For instance, preprocessing.StandardScaler has a learn_many method as well as a transform_many method, in addition to learn_one and transform_one . Each mini-batch method takes as input a pandas.DataFrame . Supervised estimators also take as input a pandas.Series of target values. We choose to use pandas.DataFrames over numpy.ndarrays because of the simple fact that the former allows us to name each feature. This in turn allows us to offer a uniform interface for both single instance and mini-batch learning. As an example, we will build a simple pipeline that scales the data and trains a logistic regression. Indeed, the compose.Pipeline class can be applied to mini-batches, as long as each step is able to do so. from river import compose from river import linear_model from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) For this example, we will use datasets.Higgs . from river import datasets dataset = datasets . Higgs () if not dataset . is_downloaded : dataset . download () dataset Downloading https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz (2.62 GB) Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes. Name Higgs Task Binary classification Samples 11,000,000 Features 28 Sparse False Path /home/runner/river_data/Higgs/HIGGS.csv.gz URL https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz Size 2.62 GB Downloaded True The easiest way to read the data in a mini-batch fashion is to use the read_csv from pandas . import pandas as pd names = [ 'target' , 'lepton pT' , 'lepton eta' , 'lepton phi' , 'missing energy magnitude' , 'missing energy phi' , 'jet 1 pt' , 'jet 1 eta' , 'jet 1 phi' , 'jet 1 b-tag' , 'jet 2 pt' , 'jet 2 eta' , 'jet 2 phi' , 'jet 2 b-tag' , 'jet 3 pt' , 'jet 3 eta' , 'jet 3 phi' , 'jet 3 b-tag' , 'jet 4 pt' , 'jet 4 eta' , 'jet 4 phi' , 'jet 4 b-tag' , 'm_jj' , 'm_jjj' , 'm_lv' , 'm_jlv' , 'm_bb' , 'm_wbb' , 'm_wwbb' ] for x in pd . read_csv ( dataset . path , names = names , chunksize = 8096 , nrows = 3e5 ): y = x . pop ( 'target' ) y_pred = model . predict_proba_many ( x ) model . learn_many ( x , y ) If you are familiar with scikit-learn, you might be aware that some of their estimators have a partial_fit method, which is similar to river's learn_many method. Here are some advantages that river has over scikit-learn: We guarantee that river's is just as fast, if not faster than scikit-learn. The differences are negligeable, but are slightly in favor of river. We take as input dataframes, which allows us to name each feature. The benefit is that you can add/remove/permute features between batches and everything will keep working. Estimators that support mini-batches also support single instance learning. This means that you can enjoy the best of both worlds. For instance, you can train with mini-batches and use predict_one to make predictions. Note that you can check which estimators can process mini-batches programmatically: import importlib import inspect def can_mini_batch ( obj ): return hasattr ( obj , 'learn_many' ) for module in importlib . import_module ( 'river' ) . __all__ : if module in [ 'datasets' , 'synth' ]: continue for name , obj in inspect . getmembers ( importlib . import_module ( f 'river. { module } ' ), can_mini_batch ): print ( name ) MiniBatchClassifier MiniBatchRegressor SKL2RiverClassifier SKL2RiverRegressor Pipeline LinearRegression LogisticRegression Perceptron OneVsRestClassifier StandardScaler Because mini-batch learning isn't treated as a first-class citizen, some of the river's functionalities require some work in order to play nicely with mini-batches. For instance, the objects from the metrics module have an update method that take as input a single pair (y_true, y_pred) . This might change in the future, depending on the demand. We plan to promote more models to the mini-batch regime. However, we will only be doing so for the methods that benefit the most from it, as well as those that are most popular. Indeed, river 's core philosophy will remain to cater to single instance learning.","title":"Mini-batching"},{"location":"user-guide/model-evaluation/","text":"Model evaluation \u00b6 To do.","title":"Model evaluation"},{"location":"user-guide/model-evaluation/#model-evaluation","text":"To do.","title":"Model evaluation"},{"location":"user-guide/pipelines/","text":"Pipelines \u00b6 Pipelines are an integral part of river. We encourage their usage and apply them in many of their examples. The compose.Pipeline contains all the logic for building and applying pipelines. A pipeline is essentially a list of estimators that are applied in sequence. The only requirement is that the first n - 1 steps be transformers. The last step can be a regressor, a classifier, a clusterer, a transformer, etc. Here is an example: from river import compose from river import linear_model from river import preprocessing from river import feature_extraction model = compose . Pipeline ( preprocessing . StandardScaler (), feature_extraction . PolynomialExtender (), linear_model . LinearRegression () ) You can also use the | operator, as so: model = ( preprocessing . StandardScaler () | feature_extraction . PolynomialExtender () | linear_model . LinearRegression () ) Or, equally: model = preprocessing . StandardScaler () model |= feature_extraction . PolynomialExtender () model |= linear_model . LinearRegression () A pipeline has a draw method that can be used to visualize it: model . draw () compose.Pipeline inherits from base.Estimator , which means that it has a learn_one method. You would expect learn_one to update each estimator, but that's not actually what happens . Instead, the transformers are updated when predict_one (or predict_proba_one for that matter) is called. Indeed, in online machine learning, we can update the unsupervised parts of our model when a sample arrives. We don't have to wait for the ground truth to arrive in order to update unsupervised estimators that don't depend on it. In other words, in a pipeline, learn_one updates the supervised parts, whilst predict_one updates the unsupervised parts. It's important to be aware of this behavior, as it is quite different to what is done in other libraries that rely on batch machine learning. Here is a small example to illustrate the previous point: from river import datasets dataset = datasets . TrumpApproval () x , y = next ( iter ( dataset )) x , y ({'ordinal_date': 736389, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}, 43.75505) Let us call predict_one , which will update each transformer, but won't update the linear regression. model . predict_one ( x ) 0.0 The prediction is nil because each weight of the linear regression is equal to 0. model [ 'StandardScaler' ] . means defaultdict(float, {'ordinal_date': 736389.0, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}) As we can see, the means of each feature have been updated, even though we called predict_one and not learn_one . Note that if you call transform_one with a pipeline who's last step is not a transformer, then the output from the last transformer (which is thus the penultimate step) will be returned: model . transform_one ( x ) {'ordinal_date': 0.0, 'gallup': 0.0, 'ipsos': 0.0, 'morning_consult': 0.0, 'rasmussen': 0.0, 'you_gov': 0.0, 'ordinal_date*ordinal_date': 0.0, 'gallup*ordinal_date': 0.0, 'ipsos*ordinal_date': 0.0, 'morning_consult*ordinal_date': 0.0, 'ordinal_date*rasmussen': 0.0, 'ordinal_date*you_gov': 0.0, 'gallup*gallup': 0.0, 'gallup*ipsos': 0.0, 'gallup*morning_consult': 0.0, 'gallup*rasmussen': 0.0, 'gallup*you_gov': 0.0, 'ipsos*ipsos': 0.0, 'ipsos*morning_consult': 0.0, 'ipsos*rasmussen': 0.0, 'ipsos*you_gov': 0.0, 'morning_consult*morning_consult': 0.0, 'morning_consult*rasmussen': 0.0, 'morning_consult*you_gov': 0.0, 'rasmussen*rasmussen': 0.0, 'rasmussen*you_gov': 0.0, 'you_gov*you_gov': 0.0} In many cases, you might want to connect a step to multiple steps. For instance, you might to extract different kinds of features from a single input. An elegant way to do this is to use a compose.TransformerUnion . Essentially, the latter is a list of transformers who's results will be merged into a single dict when transform_one is called. As an example let's say that we want to apply a feature_extraction.RBFSampler as well as the feature_extraction.PolynomialExtender . This may be done as so: model = ( preprocessing . StandardScaler () | ( feature_extraction . PolynomialExtender () + feature_extraction . RBFSampler ()) | linear_model . LinearRegression () ) model . draw () Note that the + symbol acts as a shorthand notation for creating a compose.TransformerUnion , which means that we could have declared the above pipeline as so: model = ( preprocessing . StandardScaler () | compose . TransformerUnion ( feature_extraction . PolynomialExtender (), feature_extraction . RBFSampler () ) | linear_model . LinearRegression () ) Pipelines provide the benefit of removing a lot of cruft by taking care of tedious details for you. They also enable to clearly define what steps your model is made of. Finally, having your model in a single object means that you can move it around more easily. Note that you can include user-defined functions in a pipeline by using a compose.FuncTransformer .","title":"Pipelines"},{"location":"user-guide/pipelines/#pipelines","text":"Pipelines are an integral part of river. We encourage their usage and apply them in many of their examples. The compose.Pipeline contains all the logic for building and applying pipelines. A pipeline is essentially a list of estimators that are applied in sequence. The only requirement is that the first n - 1 steps be transformers. The last step can be a regressor, a classifier, a clusterer, a transformer, etc. Here is an example: from river import compose from river import linear_model from river import preprocessing from river import feature_extraction model = compose . Pipeline ( preprocessing . StandardScaler (), feature_extraction . PolynomialExtender (), linear_model . LinearRegression () ) You can also use the | operator, as so: model = ( preprocessing . StandardScaler () | feature_extraction . PolynomialExtender () | linear_model . LinearRegression () ) Or, equally: model = preprocessing . StandardScaler () model |= feature_extraction . PolynomialExtender () model |= linear_model . LinearRegression () A pipeline has a draw method that can be used to visualize it: model . draw () compose.Pipeline inherits from base.Estimator , which means that it has a learn_one method. You would expect learn_one to update each estimator, but that's not actually what happens . Instead, the transformers are updated when predict_one (or predict_proba_one for that matter) is called. Indeed, in online machine learning, we can update the unsupervised parts of our model when a sample arrives. We don't have to wait for the ground truth to arrive in order to update unsupervised estimators that don't depend on it. In other words, in a pipeline, learn_one updates the supervised parts, whilst predict_one updates the unsupervised parts. It's important to be aware of this behavior, as it is quite different to what is done in other libraries that rely on batch machine learning. Here is a small example to illustrate the previous point: from river import datasets dataset = datasets . TrumpApproval () x , y = next ( iter ( dataset )) x , y ({'ordinal_date': 736389, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}, 43.75505) Let us call predict_one , which will update each transformer, but won't update the linear regression. model . predict_one ( x ) 0.0 The prediction is nil because each weight of the linear regression is equal to 0. model [ 'StandardScaler' ] . means defaultdict(float, {'ordinal_date': 736389.0, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}) As we can see, the means of each feature have been updated, even though we called predict_one and not learn_one . Note that if you call transform_one with a pipeline who's last step is not a transformer, then the output from the last transformer (which is thus the penultimate step) will be returned: model . transform_one ( x ) {'ordinal_date': 0.0, 'gallup': 0.0, 'ipsos': 0.0, 'morning_consult': 0.0, 'rasmussen': 0.0, 'you_gov': 0.0, 'ordinal_date*ordinal_date': 0.0, 'gallup*ordinal_date': 0.0, 'ipsos*ordinal_date': 0.0, 'morning_consult*ordinal_date': 0.0, 'ordinal_date*rasmussen': 0.0, 'ordinal_date*you_gov': 0.0, 'gallup*gallup': 0.0, 'gallup*ipsos': 0.0, 'gallup*morning_consult': 0.0, 'gallup*rasmussen': 0.0, 'gallup*you_gov': 0.0, 'ipsos*ipsos': 0.0, 'ipsos*morning_consult': 0.0, 'ipsos*rasmussen': 0.0, 'ipsos*you_gov': 0.0, 'morning_consult*morning_consult': 0.0, 'morning_consult*rasmussen': 0.0, 'morning_consult*you_gov': 0.0, 'rasmussen*rasmussen': 0.0, 'rasmussen*you_gov': 0.0, 'you_gov*you_gov': 0.0} In many cases, you might want to connect a step to multiple steps. For instance, you might to extract different kinds of features from a single input. An elegant way to do this is to use a compose.TransformerUnion . Essentially, the latter is a list of transformers who's results will be merged into a single dict when transform_one is called. As an example let's say that we want to apply a feature_extraction.RBFSampler as well as the feature_extraction.PolynomialExtender . This may be done as so: model = ( preprocessing . StandardScaler () | ( feature_extraction . PolynomialExtender () + feature_extraction . RBFSampler ()) | linear_model . LinearRegression () ) model . draw () Note that the + symbol acts as a shorthand notation for creating a compose.TransformerUnion , which means that we could have declared the above pipeline as so: model = ( preprocessing . StandardScaler () | compose . TransformerUnion ( feature_extraction . PolynomialExtender (), feature_extraction . RBFSampler () ) | linear_model . LinearRegression () ) Pipelines provide the benefit of removing a lot of cruft by taking care of tedious details for you. They also enable to clearly define what steps your model is made of. Finally, having your model in a single object means that you can move it around more easily. Note that you can include user-defined functions in a pipeline by using a compose.FuncTransformer .","title":"Pipelines"},{"location":"user-guide/reading-data/","text":"Reading data \u00b6 In river , the features of a sample are stored inside a dictionary, which in Python is called a dict and is a native data structure. In other words, we don't use any sophisticated data structure, such as a numpy.ndarray or a pandas.DataFrame . The main advantage of using plain dict s is that it removes the overhead that comes with using the aforementioned data structures. This is important in a streaming context because we want to be able to process many individual samples in rapid succession. Another advantage is that dict s allow us to give names to our features. Finally, dict s are not typed, and can therefore store heterogeneous data. Another advantage which we haven't mentioned is that dict s play nicely with Python's standard library. Indeed, Python contains many tools that allow manipulating dict s. For instance, the csv.DictReader can be used to read a CSV file and convert each row to a dict . In fact, the stream.iter_csv method from river is just a wrapper on top of csv.DictReader that adds a few bells and whistles. river provides some out-of-the-box datasets to get you started. from river import datasets dataset = datasets . Bikes () dataset Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse. Name Bikes Task Regression Samples 182,470 Features 8 Sparse False Path /home/runner/river_data/Bikes/toulouse_bikes.csv URL https://maxhalford.github.io/files/datasets/toulouse_bikes.zip Size 12.52 MB Downloaded True Note that when we say \"loaded\", we don't mean that the actual data is read from the disk. On the contrary, the dataset is a streaming data that can be iterated over one sample at a time. In Python lingo, it's a generator . Let's take a look at the first sample: x , y = next ( iter ( dataset )) x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} Each dataset is iterable, which means we can also do: for x , y in dataset : break x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} As we can see, the values have different types. Under the hood, calling for x, y in dataset simply iterates over a file and parses each value appropriately. We can do this ourselves by using stream.iter_csv : from river import stream X_y = stream . iter_csv ( dataset . path ) x , y = next ( X_y ) x , y ({'moment': '2016-04-01 00:00:07', 'bikes': '1', 'station': 'metro-canal-du-midi', 'clouds': '75', 'description': 'light rain', 'humidity': '81', 'pressure': '1017.0', 'temperature': '6.54', 'wind': '9.3'}, None) There are a couple things that are wrong. First of all, the numeric features have not been casted into numbers. Indeed, by default, stream.iter_csv assumes that everything is a string. A related issue is that the moment field hasn't been parsed into a datetime . Finally, the target field, which is bikes , hasn't been separated from the rest of the features. We can remedy to these issues by setting a few parameters: X_y = stream . iter_csv ( dataset . path , converters = { 'bikes' : int , 'clouds' : int , 'humidity' : int , 'pressure' : float , 'temperature' : float , 'wind' : float }, parse_dates = { 'moment' : '%Y-%m- %d %H:%M:%S' }, target = 'bikes' ) x , y = next ( X_y ) x , y ({'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3}, 1) That's much better. We invite you to take a look at the stream module to see for yourself what other methods are available. Note that river is first and foremost a machine learning library, and therefore isn't as much concerned about reading data as it is about statistical algorithms. We do however believe that the fact that we use dictionary gives you, the user, a lot of freedom and flexibility. To conclude, let us shortly mention between proactive learning and reactive learning in the specific context of online machine learning. When we loop over a data with a for loop, we have the control over the data and the order in which it arrives. We are proactive in the sense that we, the user, are asking for the data to arrive. In contract, in a reactive situation, we don't have control on the data arrival. A typical example of such a situation is web server, where web requests arrive in an arbitrary order. This is a situation where river shines. For instance, in a Flask application, you could define a route to make predictions with a river model as so: import flask app = flask . Flask ( __name__ ) @app . route ( '/' , methods = [ 'GET' ]) def predict (): payload = flask . request . json river_model = load_model () return river_model . predict_proba_one ( payload ) Likewise, a model can be updated whenever a request arrives as so: @app . route ( '/' , methods = [ 'POST' ]) def learn (): payload = flask . request . json river_model = load_model () river_model . learn_one ( payload [ 'features' ], payload [ 'target' ]) return {}, 201 To summarize, river can be used in many different ways. The fact that it uses dictionaries to represent features provides a lot of flexibility and space for creativity.","title":"Reading data"},{"location":"user-guide/reading-data/#reading-data","text":"In river , the features of a sample are stored inside a dictionary, which in Python is called a dict and is a native data structure. In other words, we don't use any sophisticated data structure, such as a numpy.ndarray or a pandas.DataFrame . The main advantage of using plain dict s is that it removes the overhead that comes with using the aforementioned data structures. This is important in a streaming context because we want to be able to process many individual samples in rapid succession. Another advantage is that dict s allow us to give names to our features. Finally, dict s are not typed, and can therefore store heterogeneous data. Another advantage which we haven't mentioned is that dict s play nicely with Python's standard library. Indeed, Python contains many tools that allow manipulating dict s. For instance, the csv.DictReader can be used to read a CSV file and convert each row to a dict . In fact, the stream.iter_csv method from river is just a wrapper on top of csv.DictReader that adds a few bells and whistles. river provides some out-of-the-box datasets to get you started. from river import datasets dataset = datasets . Bikes () dataset Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse. Name Bikes Task Regression Samples 182,470 Features 8 Sparse False Path /home/runner/river_data/Bikes/toulouse_bikes.csv URL https://maxhalford.github.io/files/datasets/toulouse_bikes.zip Size 12.52 MB Downloaded True Note that when we say \"loaded\", we don't mean that the actual data is read from the disk. On the contrary, the dataset is a streaming data that can be iterated over one sample at a time. In Python lingo, it's a generator . Let's take a look at the first sample: x , y = next ( iter ( dataset )) x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} Each dataset is iterable, which means we can also do: for x , y in dataset : break x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} As we can see, the values have different types. Under the hood, calling for x, y in dataset simply iterates over a file and parses each value appropriately. We can do this ourselves by using stream.iter_csv : from river import stream X_y = stream . iter_csv ( dataset . path ) x , y = next ( X_y ) x , y ({'moment': '2016-04-01 00:00:07', 'bikes': '1', 'station': 'metro-canal-du-midi', 'clouds': '75', 'description': 'light rain', 'humidity': '81', 'pressure': '1017.0', 'temperature': '6.54', 'wind': '9.3'}, None) There are a couple things that are wrong. First of all, the numeric features have not been casted into numbers. Indeed, by default, stream.iter_csv assumes that everything is a string. A related issue is that the moment field hasn't been parsed into a datetime . Finally, the target field, which is bikes , hasn't been separated from the rest of the features. We can remedy to these issues by setting a few parameters: X_y = stream . iter_csv ( dataset . path , converters = { 'bikes' : int , 'clouds' : int , 'humidity' : int , 'pressure' : float , 'temperature' : float , 'wind' : float }, parse_dates = { 'moment' : '%Y-%m- %d %H:%M:%S' }, target = 'bikes' ) x , y = next ( X_y ) x , y ({'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3}, 1) That's much better. We invite you to take a look at the stream module to see for yourself what other methods are available. Note that river is first and foremost a machine learning library, and therefore isn't as much concerned about reading data as it is about statistical algorithms. We do however believe that the fact that we use dictionary gives you, the user, a lot of freedom and flexibility. To conclude, let us shortly mention between proactive learning and reactive learning in the specific context of online machine learning. When we loop over a data with a for loop, we have the control over the data and the order in which it arrives. We are proactive in the sense that we, the user, are asking for the data to arrive. In contract, in a reactive situation, we don't have control on the data arrival. A typical example of such a situation is web server, where web requests arrive in an arbitrary order. This is a situation where river shines. For instance, in a Flask application, you could define a route to make predictions with a river model as so: import flask app = flask . Flask ( __name__ ) @app . route ( '/' , methods = [ 'GET' ]) def predict (): payload = flask . request . json river_model = load_model () return river_model . predict_proba_one ( payload ) Likewise, a model can be updated whenever a request arrives as so: @app . route ( '/' , methods = [ 'POST' ]) def learn (): payload = flask . request . json river_model = load_model () river_model . learn_one ( payload [ 'features' ], payload [ 'target' ]) return {}, 201 To summarize, river can be used in many different ways. The fact that it uses dictionaries to represent features provides a lot of flexibility and space for creativity.","title":"Reading data"}]}